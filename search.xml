<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>与webpack类似的工具还有哪些？区别？</title>
      <link href="/2023/07/29/webpack-Rollup_Parcel_snowpack_Vite/"/>
      <url>/2023/07/29/webpack-Rollup_Parcel_snowpack_Vite/</url>
      
        <content type="html"><![CDATA[<h1 id="与webpack类似的工具还有哪些？区别？"><a href="#与webpack类似的工具还有哪些？区别？" class="headerlink" title="与webpack类似的工具还有哪些？区别？"></a>与webpack类似的工具还有哪些？区别？</h1><p><img src="https://static.vue-js.com/8ed8d520-b1a4-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、模块化工具"><a href="#一、模块化工具" class="headerlink" title="一、模块化工具"></a>一、模块化工具</h2><p>模块化是一种处理复杂系统分解为更好的可管理模块的方式</p><span id="more"></span><p>可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(<code>bundle</code>)</p><p>在前端领域中，并非只有<code>webpack</code>这一款优秀的模块打包工具，还有其他类似的工具，例如<code>Rollup</code>、<code>Parcel</code>、<code>snowpack</code>，以及最近风头无两的<code>Vite</code></p><p>通过这些模块打包工具，能够提高我们的开发效率，减少开发成本</p><p>这里没有提及<code>gulp</code>、<code>grunt</code>是因为它们只是定义为构建工具，不能类比</p><h3 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h3><p><code>Rollup</code> 是一款 <code>ES Modules</code> 打包器，从作用上来看，<code>Rollup</code> 与 <code>Webpack</code> 非常类似。不过相比于 <code>Webpack</code>，<code>Rollup </code>要小巧的多</p><p>现在很多我们熟知的库都都使用它进行打包，比如：<code>Vue</code>、<code>React</code>和<code>three.js</code>等</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/messages.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">hi</span>: <span class="string">&#x27;Hey Guys, I am zce~&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/logger.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">log</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------- INFO ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------------------------&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">error</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;---------- ERROR ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(msg)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;---------------------------&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; log &#125; <span class="keyword">from</span> <span class="string">&#x27;./logger&#x27;</span></span><br><span class="line"><span class="keyword">import</span> messages <span class="keyword">from</span> <span class="string">&#x27;./messages&#x27;</span></span><br><span class="line"><span class="title function_">log</span>(messages.<span class="property">hi</span>)</span><br></pre></td></tr></table></figure><p>然后通过<code>rollup</code>进行打包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx rollup ./src/index.<span class="property">js</span> --file ./dist/bundle.<span class="property">js</span></span><br></pre></td></tr></table></figure><p>打包结果如下图<img src="https://static.vue-js.com/8fe07830-b143-11eb-85f6-6fac77c0c9b3.png"></p><p>可以看到，代码非常简洁，完成不像<code>webpack</code>那样存在大量引导代码和模块函数</p><p>并且<code>error</code>方法由于没有被使用，输出的结果中并无<code>error</code>方法，可以看到，<code>rollup</code>默认开始<code>Tree-shaking</code> 优化输出结果</p><p>因此，可以看到<code>Rollup</code>的优点：</p><ul><li>代码效率更简洁、效率更高</li><li>默认支持 Tree-shaking</li></ul><p>但缺点也十分明显，加载其他类型的资源文件或者支持导入 <code>CommonJS</code> 模块，又或是编译 <code>ES</code> 新特性，这些额外的需求 <code>Rollup </code>需要使用插件去完成</p><p>综合来看，<code>rollup</code>并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用<code>CommonJs</code>方式导出成员，并且<code>rollup</code>不支持<code>HMR</code>，使开发效率降低</p><p>但是在用于打包<code> JavaScript</code> 库时，<code>rollup</code>比 <code>webpack</code> 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略</p><h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><p>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序</p><p><code>Parcel</code> 跟 <code>Webpack</code> 一样都支持以任意类型文件作为打包入口，但建议使用<code>HTML</code>文件作为入口，该<code>HTML</code>文件像平时一样正常编写代码、引用资源。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ./src/index.<span class="property">html</span> --&gt;</span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Parcel Tutorials<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>main.js文件通过<code>ES Moudle</code>方法导入其他模块成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; log &#125; <span class="keyword">from</span> <span class="string">&#x27;./logger&#x27;</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;hello parcel&#x27;</span>)</span><br><span class="line"><span class="comment">// ./src/logger.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">log</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------- INFO ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，使用命令打包</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx parcel src/index.html</span><br></pre></td></tr></table></figure><p>执行命令后，<code>Parcel</code>不仅打包了应用，同时也启动了一个开发服务器，跟<code>webpack Dev Server</code>一样</p><p>跟<code>webpack</code>类似，也支持模块热替换，但用法更简单</p><p>同时，<code>Parcel</code>有个十分好用的功能：支持自动安装依赖，像<code>webpack</code>开发阶段突然使用安装某个第三方依赖，必然会终止<code>dev server</code>然后安装再启动。而<code>Parcel</code>则免了这繁琐的工作流程</p><p>同时，<code>Parcel</code>能够零配置加载其他类型的资源文件，无须像<code>webpack</code>那样配置对应的<code>loader</code></p><p>打包命令如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx parcel src/index.html</span><br></pre></td></tr></table></figure><p>由于打包过程是多进程同时工作，构建速度会比<code>Webpack</code> 快，输出文件也会被压缩，并且样式代码也会被单独提取到单个文件中</p><p><img src="https://static.vue-js.com/ec17e7a0-b1a2-11eb-85f6-6fac77c0c9b3.png"></p><p>可以感受到，<code>Parcel </code>给开发者一种很大的自由度，只管去实现业务代码，其他事情用<code>Parcel</code>解决</p><h3 id="Snowpack"><a href="#Snowpack" class="headerlink" title="Snowpack"></a>Snowpack</h3><p>Snowpack，是一种闪电般快速的前端构建工具，专为现代<code>Web</code>设计，较复杂的打包工具（如<code>Webpack</code>或<code>Parcel</code>）的替代方案，利用<code>JavaScript</code>的本机模块系统，避免不必要的工作并保持流畅的开发体验</p><p>开发阶段，每次保存单个文件时，<code>Webpack</code>和<code>Parcel</code>都需要重新构建和重新打包应用程序的整个<code>bundle</code>。而<code>Snowpack</code>为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，<code>Snowpack</code>会重新构建该单个文件</p><p>下图给出<code>webpack</code>与<code>snowpack</code>打包区别：</p><p> <img src="https://static.vue-js.com/79197830-b1a3-11eb-85f6-6fac77c0c9b3.png"></p><p>在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行HMR更新</p><h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p><p>它主要由两部分组成：</p><ul><li>一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR</li><li>一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li></ul><p>其作用类似<code>webpack </code>+ <code>webpack-dev-server</code>，其特点如下：</p><ul><li>快速的冷启动</li><li>即时的模块热更新</li><li>真正的按需编译</li></ul><p><code>vite</code>会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快</p><p>利用现代浏览器支持<code>ES Module</code>的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</p><p>原理图如下所示：</p><p> <img src="https://static.vue-js.com/9f2eed30-b143-11eb-85f6-6fac77c0c9b3.png"></p><p>在热模块<code>HMR</code>方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像<code>webpack</code>那样需要把该模块的相关依赖模块全部编译一次，效率更高</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>相比上述的模块化工具，<code>webpack</code>大而全，很多常用的功能做到开箱即用。有两大最核心的特点：<strong>一切皆模块</strong>和<strong>按需加载</strong></p><p>与其他构建工具相比，有如下优势：</p><ul><li>智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容</li><li>万物模块：对 js、css、图片等资源文件都支持打包</li><li>开箱即用：HRM、Tree-shaking等功能</li><li>代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li><li>插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性</li><li>易于调试：支持 SourceUrls 和 SourceMaps</li><li>快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快</li><li>生态环境好：社区更丰富，出现的问题更容易解决</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/95684686">https://zhuanlan.zhihu.com/p/95684686</a></li><li><a href="https://cn.vitejs.dev/guide/">https://cn.vitejs.dev/guide/</a></li><li><a href="https://segmentfault.com/a/1190000039370642">https://segmentfault.com/a/1190000039370642</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack类似的工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack proxy工作原理？为什么能解决跨域?</title>
      <link href="/2023/07/27/webpack-proxy/"/>
      <url>/2023/07/27/webpack-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack-proxy工作原理？为什么能解决跨域"><a href="#webpack-proxy工作原理？为什么能解决跨域" class="headerlink" title="webpack proxy工作原理？为什么能解决跨域?"></a>webpack proxy工作原理？为什么能解决跨域?</h1><p> <img src="https://static.vue-js.com/5b871600-ace5-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>webpack proxy</code>，即<code>webpack</code>提供的代理服务</p><span id="more"></span><p>基本行为就是接收客户端发送的请求后转发给其他服务器</p><p>其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）</p><p>想要实现代理首先需要一个中间服务器，<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code></p><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p><code>webpack-dev-server</code>是 <code>webpack</code> 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起</p><p>目的是为了提高开发者日常的开发效率，<strong>只适用在开发阶段</strong></p><p>关于配置方面，在<code>webpack</code>配置对象属性中通过<code>devServer</code>属性提供，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">contentBase</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;https://api.github.com&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>devServetr</code>里面<code>proxy</code>则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配</p><p>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为<code> /api</code>，值为对应的代理匹配规则，对应如下：</p><ul><li>target：表示的是代理到的目标地址</li><li>pathRewrite：默认情况下，我们的 &#x2F;api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite</li><li>secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false</li><li>changeOrigin：它表示是否更新代理后请求的 headers 中host地址</li></ul><h2 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h2><p> <code>proxy</code>工作原理实质上是利用<code>http-proxy-middleware</code> 这个<code>http</code>代理中间件，实现请求转发给其他服务器</p><p>举个例子：</p><p>在开发阶段，本地地址为<code>http://localhost:3000</code>，该浏览器发送一个前缀带有<code>/api</code>标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, <span class="title function_">proxy</span>(&#123;<span class="attr">target</span>: <span class="string">&#x27;http://www.example.org&#x27;</span>, <span class="attr">changeOrigin</span>: <span class="literal">true</span>&#125;));</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar</span></span><br></pre></td></tr></table></figure><h2 id="三、跨域"><a href="#三、跨域" class="headerlink" title="三、跨域"></a>三、跨域</h2><p>在开发阶段， <code>webpack-dev-server</code> 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 <code>localhost </code>的一个端口上，而后端服务又是运行在另外一个地址上</p><p>所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题</p><p>通过设置<code>webpack proxy</code>实现代理请求后，相当于浏览器与服务端中添加一个代理者</p><p>当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地</p><p> <img src="https://static.vue-js.com/65b5e5c0-ace5-11eb-85f6-6fac77c0c9b3.png"></p><p>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据</p><p>注意：<strong>服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://webpack.docschina.org/configuration/dev-server/#devserverproxy">https://webpack.docschina.org/configuration/dev-server/#devserverproxy</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack中常见的Plugin？解决了什么问题？</title>
      <link href="/2023/07/17/webpack-Plugin/"/>
      <url>/2023/07/17/webpack-Plugin/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack中常见的Plugin？解决了什么问题？"><a href="#webpack中常见的Plugin？解决了什么问题？" class="headerlink" title="webpack中常见的Plugin？解决了什么问题？"></a>webpack中常见的Plugin？解决了什么问题？</h1><p> <img src="https://static.vue-js.com/8d3978a0-a7c2-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>Plugin</code>（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能</p><p>是一种遵循一定规范的应用程序接口编写出来的程序，只能运行在程序规定的系统下，因为其需要调用原纯净系统提供的函数库或者数据</p><p><code>webpack</code>中的<code>plugin</code>也是如此，<code>plugin</code>赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 <code>webpack</code> 的不同阶段（钩子 &#x2F; 生命周期），贯穿了<code>webpack</code>整个编译周期</p><p><img src="https://static.vue-js.com/9a04ec40-a7c2-11eb-ab90-d9ae814b240d.png"></p><p>目的在于解决<code>loader</code> 无法实现的其他事</p><span id="more"></span><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>这里讲述文件的配置方式，一般情况，通过配置文件导出对象中<code>plugins</code>属性传入<code>new</code>实例对象。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 访问内置的插件</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">ProgressPlugin</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123; <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span> &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h2><p>其本质是一个具有<code>apply</code>方法<code>javascript</code>对象</p><p><code>apply</code> 方法会被 <code>webpack compiler </code>调用，并且在整个编译生命周期都可以访问 <code>compiler </code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pluginName = <span class="string">&#x27;ConsoleLogOnBuildWebpackPlugin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsoleLogOnBuildWebpackPlugin</span> &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">run</span>.<span class="title function_">tap</span>(pluginName, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;webpack 构建过程开始！&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">ConsoleLogOnBuildWebpackPlugin</span>;</span><br></pre></td></tr></table></figure><p><code>compiler hook</code> 的 <code>tap </code>方法的第一个参数，应是驼峰式命名的插件名称</p><p>关于整个编译生命周期钩子，有如下：</p><ul><li>entry-option ：初始化 option</li><li>run</li><li>compile： 真正开始的编译，在创建 compilation 对象之前</li><li>compilation ：生成好了 compilation 对象</li><li>make 从 entry 开始递归分析依赖，准备对每个模块进行 build</li><li>after-compile： 编译 build 过程结束</li><li>emit ：在将内存中 assets 内容写到磁盘文件夹之前</li><li>after-emit ：在将内存中 assets 内容写到磁盘文件夹之后</li><li>done： 完成所有的编译过程</li><li>failed： 编译失败的时候</li></ul><h2 id="三、常见的Plugin"><a href="#三、常见的Plugin" class="headerlink" title="三、常见的Plugin"></a>三、常见的Plugin</h2><p>常见的<code>plugin</code>有如图所示：</p><p><img src="https://static.vue-js.com/bd749400-a7c2-11eb-85f6-6fac77c0c9b3.png"></p><p>下面介绍几个常用的插件用法：</p><h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>在打包结束后，⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code> js</code> 模块引⼊到该 <code>html</code> 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"> ...</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">       <span class="attr">title</span>: <span class="string">&quot;My App&quot;</span>,</span><br><span class="line">       <span class="attr">filename</span>: <span class="string">&quot;app.html&quot;</span>,</span><br><span class="line">       <span class="attr">template</span>: <span class="string">&quot;./src/html/index.html&quot;</span></span><br><span class="line">     &#125;) </span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--./src/html/index.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%=htmlWebpackPlugin.options.title%&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>html-webpack-plugin<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>html</code> 模板中，可以通过 <code>&lt;%=htmlWebpackPlugin.options.XXX%&gt;</code> 的方式获取配置的值</p><p>更多的配置可以自寻查找</p><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>删除（清理）构建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">CleanWebpackPlugin</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"> ...</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    ...,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(),</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><p>提取 <code>CSS</code> 到一个单独的文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"> ...,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">   <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">     <span class="attr">use</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="attr">loader</span>: <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span></span><br><span class="line">     &#125;,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;sass-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    ...,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">     <span class="attr">filename</span>: <span class="string">&#x27;[name].css&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h3><p>允许在编译时创建配置的全局对象，是一个<code>webpack</code>内置的插件，不需要安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">DefinePlugun</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="attr">plugins</span>:[</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">            <span class="attr">BASE_URL</span>:<span class="string">&#x27;&quot;./&quot;&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候编译<code>template</code>模块的时候，就能通过下述形式获取全局对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL%&gt;favicon.ico&gt;&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h3><p>复制文件或目录到执行区域，如<code>vue</code>的打包过程中，如果我们将一些文件放到<code>public</code>的目录下，那么这个目录会被复制到<code>dist</code>文件夹中</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="built_in">copy</span>-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">CopyWebpackPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">parrerns</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">from</span>:<span class="string">&quot;public&quot;</span>,</span><br><span class="line">            <span class="attr">globOptions</span>:&#123;</span><br><span class="line">                <span class="attr">ignore</span>:[</span><br><span class="line">                    <span class="string">&#x27;**/index.html&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>复制的规则在<code>patterns</code>属性中设置：</p><ul><li><p>from：设置从哪一个源中开始复制</p></li><li><p>to：复制到的位置，可以省略，会默认复制到打包的目录下</p></li><li><p>globOptions：设置一些额外的选项，其中可以编写需要忽略的文件</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://webpack.docschina.org/concepts/plugins/">https://webpack.docschina.org/concepts/plugins/</a></li><li><a href="https://baike.baidu.com/item/Plugin">https://baike.baidu.com/item/Plugin</a></li><li><a href="https://segmentfault.com/a/1190000018695134">https://segmentfault.com/a/1190000018695134</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack中常见的Plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对webpack的理解？解决了什么问题？</title>
      <link href="/2023/07/12/webpack/"/>
      <url>/2023/07/12/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="你对webpack的理解？解决了什么问题？"><a href="#你对webpack的理解？解决了什么问题？" class="headerlink" title="你对webpack的理解？解决了什么问题？"></a>你对webpack的理解？解决了什么问题？</h1><p> <img src="https://static.vue-js.com/898ed570-a578-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p><code>Webpack</code> 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源</p><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的<code> JS</code> 文件中</p><p>约定每个文件是一个独立的模块，然后再将这些<code>js</code>文件引入到页面，一个<code>script</code>标签对应一个模块，然后调用模块化的成员</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;module-a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;module-b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题</p><p>项目一旦变大，上述问题会尤其明显</p><p>随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">moduleA</span> = &#123;</span><br><span class="line">  <span class="attr">method1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;moduleA#method1&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式也并没有解决第一种方式的依赖等问题</p><p>再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module-a.js</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">$</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;module-a&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">method1</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name + <span class="string">&#x27;#method1&#x27;</span>)</span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">animate</span>(&#123; <span class="attr">margin</span>: <span class="string">&#x27;200px&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">moduleA</span> = &#123;</span><br><span class="line">    <span class="attr">method1</span>: method1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(jQuery)</span><br></pre></td></tr></table></figure><p>上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过<code>script</code>标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦</p><p>理想的解决方式是，在页面中引入一个<code>JS</code>入口文件，其余用到的模块可以通过代码控制，按需加载进来</p><p>除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是<code>CommonJS </code>、<code>ES Modules</code></p><h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><p>从后端渲染的<code>JSP</code>、<code>PHP</code>，到前端原生<code>JavaScript</code>，再到<code>jQuery</code>开发，再到目前的三大框架<code>Vue</code>、<code>React</code>、<code>Angular</code></p><p>开发方式，也从<code>javascript</code>到后面的<code>es5</code>、<code>es6、7、8、9、10</code>，再到<code>typescript</code>，包括编写<code>CSS</code>的预处理器<code>less</code>、<code>scss</code>等</p><p>现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：</p><ul><li>需要通过模块化的方式来开发</li><li>使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码</li><li>监听文件的变化来并且反映到浏览器上，提高开发的效率</li><li>JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题</li><li>开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化</li></ul><p>而<code>webpack</code>恰巧可以解决以上问题</p><h2 id="三、是什么"><a href="#三、是什么" class="headerlink" title="三、是什么"></a>三、是什么</h2><p><code>webpack</code> 是一个用于现代<code>JavaScript</code>应用程序的静态模块打包工具</p><ul><li>静态模块</li></ul><p>这里的静态模块指的是开发阶段，可以被 <code>webpack</code> 直接引用的资源（可以直接被获取打包进<code>bundle.js</code>的资源）</p><p>当 <code>webpack </code>处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限<code>js</code>文件），并生成一个或多个 <code>bundle</code></p><p> <img src="https://static.vue-js.com/9ce194a0-a578-11eb-85f6-6fac77c0c9b3.png"></p><h4 id="webpack的能力："><a href="#webpack的能力：" class="headerlink" title="webpack的能力："></a><code>webpack</code>的能力：</h4><p><strong>编译代码能力</strong>，提高效率，解决浏览器兼容问题<br><img src="https://static.vue-js.com/c5c2d360-a592-11eb-ab90-d9ae814b240d.png"><br><strong>模块整合能力</strong>，提高性能，可维护性，解决浏览器频繁请求文件的问题<br><img src="https://static.vue-js.com/d306d260-a592-11eb-ab90-d9ae814b240d.png"><br><strong>万物皆可模块能力</strong>，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制<br><img src="https://static.vue-js.com/e3c5a040-a592-11eb-ab90-d9ae814b240d.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://webpack.docschina.org/concepts/">https://webpack.docschina.org/concepts/</a></li><li><a href="https://zhuanlan.zhihu.com/p/267875652">https://zhuanlan.zhihu.com/p/267875652</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对webpack的理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何借助webpack来优化前端性能？</title>
      <link href="/2023/07/11/webpack-performance/"/>
      <url>/2023/07/11/webpack-performance/</url>
      
        <content type="html"><![CDATA[<h1 id="如何借助webpack来优化前端性能？"><a href="#如何借助webpack来优化前端性能？" class="headerlink" title="如何借助webpack来优化前端性能？"></a>如何借助webpack来优化前端性能？</h1><p> <img src="https://static.vue-js.com/15e1ace0-aee4-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>随着前端的项目逐渐扩大，必然会带来的一个问题就是性能</p><p>尤其在大型复杂的项目中，前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至奔溃</p><p>一般项目在完成后，会通过<code>webpack</code>进行打包，利用<code>webpack</code>对前端项目性能优化是一个十分重要的环节</p><span id="more"></span><h2 id="二、如何优化"><a href="#二、如何优化" class="headerlink" title="二、如何优化"></a>二、如何优化</h2><p>通过<code>webpack</code>优化前端的手段有：</p><ul><li>JS代码压缩</li><li>CSS代码压缩</li><li>Html文件代码压缩</li><li>文件大小压缩</li><li>图片压缩</li><li>Tree Shaking</li><li>代码分离</li><li>内联 chunk</li></ul><h3 id="JS代码压缩"><a href="#JS代码压缩" class="headerlink" title="JS代码压缩"></a>JS代码压缩</h3><p><code>terser</code>是一个<code>JavaScript</code>的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让<code>bundle</code>更小</p><p>在<code>production</code>模式下，<code>webpack</code> 默认就是使用 <code>TerserPlugin</code> 来处理我们的代码的。如果想要自定义配置它，配置方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">                <span class="attr">parallel</span>: <span class="literal">true</span> <span class="comment">// 电脑cpu核数-1</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性介绍如下：</p><ul><li>extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释</li><li>parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1</li><li>terserOptions：设置我们的terser相关的配置：</li><li>compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true</li><li>mangle：设置丑化相关的选项，可以直接设置为true</li><li>toplevel：底层变量是否进行转换</li><li>keep_classnames：保留类的名称</li><li>keep_fnames：保留函数的名称</li></ul><h3 id="CSS代码压缩"><a href="#CSS代码压缩" class="headerlink" title="CSS代码压缩"></a>CSS代码压缩</h3><p><code>CSS</code>压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等</p><p>CSS的压缩我们可以使用另外一个插件：<code>css-minimizer-webpack-plugin</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-minimizer-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>配置方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CssMinimizerPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>(&#123;</span><br><span class="line">                <span class="attr">parallel</span>: <span class="literal">true</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Html文件代码压缩"><a href="#Html文件代码压缩" class="headerlink" title="Html文件代码压缩"></a>Html文件代码压缩</h3><p>使用<code>HtmlWebpackPlugin</code>插件来生成<code>HTML</code>的模板时候，通过配置属性<code>minify</code>进行<code>html</code>优化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">plugin</span>:[</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HtmlwebpackPlugin</span>(&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="attr">minify</span>:&#123;</span><br><span class="line">                <span class="attr">minifyCSS</span>:<span class="literal">false</span>, <span class="comment">// 是否压缩css</span></span><br><span class="line">                <span class="attr">collapseWhitespace</span>:<span class="literal">false</span>, <span class="comment">// 是否折叠空格</span></span><br><span class="line">                <span class="attr">removeComments</span>:<span class="literal">true</span> <span class="comment">// 是否移除注释</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置了<code>minify</code>，实际会使用另一个插件<code>html-minifier-terser</code></p><h3 id="文件大小压缩"><a href="#文件大小压缩" class="headerlink" title="文件大小压缩"></a>文件大小压缩</h3><p>对文件的大小进行压缩，减少<code>http</code>传输过程中宽带的损耗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install compression-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ComepressionPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">test</span>:<span class="regexp">/\.(css|js)$/</span>,  <span class="comment">// 哪些文件需要压缩</span></span><br><span class="line">    <span class="attr">threshold</span>:<span class="number">500</span>, <span class="comment">// 设置文件多大开始压缩</span></span><br><span class="line">    <span class="attr">minRatio</span>:<span class="number">0.7</span>, <span class="comment">// 至少压缩的比例</span></span><br><span class="line">    <span class="attr">algorithm</span>:<span class="string">&quot;gzip&quot;</span>, <span class="comment">// 采用的压缩算法</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h3><p>一般来说在打包之后，一些图片文件的大小是远远要比 <code>js</code> 或者 <code>css</code> 文件要来的大，所以图片压缩较为重要</p><p>配置方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;image-webpack-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="comment">// 压缩 jpeg 的配置</span></span><br><span class="line">            <span class="attr">mozjpeg</span>: &#123;</span><br><span class="line">              <span class="attr">progressive</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">quality</span>: <span class="number">65</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 使用 imagemin**-optipng 压缩 png，enable: false 为关闭</span></span><br><span class="line">            <span class="attr">optipng</span>: &#123;</span><br><span class="line">              <span class="attr">enabled</span>: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 使用 imagemin-pngquant 压缩 png</span></span><br><span class="line">            <span class="attr">pngquant</span>: &#123;</span><br><span class="line">              <span class="attr">quality</span>: <span class="string">&#x27;65-90&#x27;</span>,</span><br><span class="line">              <span class="attr">speed</span>: <span class="number">4</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 压缩 gif 的配置</span></span><br><span class="line">            <span class="attr">gifsicle</span>: &#123;</span><br><span class="line">              <span class="attr">interlaced</span>: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class="line">            <span class="attr">webp</span>: &#123;</span><br><span class="line">              <span class="attr">quality</span>: <span class="number">75</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h3><p><code>Tree Shaking</code> 是一个术语，在计算机中表示消除死代码，依赖于<code>ES Module</code>的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）</p><p>在<code>webpack</code>实现<code>Trss shaking</code>有两种不同的方案：</p><ul><li>usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的</li><li>sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用</li></ul><p>两种不同的配置方案， 有不同的效果</p><h4 id="usedExports"><a href="#usedExports" class="headerlink" title="usedExports"></a>usedExports</h4><p>配置方法也很简单，只需要将<code>usedExports</code>设为<code>true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">optimization</span>:&#123;</span><br><span class="line">        usedExports</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用之后，没被用上的代码在<code>webpack</code>打包中会加入<code>unused harmony export mul</code>注释，用来告知 <code>Terser</code> 在优化时，可以删除掉这段代码</p><p> 如下面<code>sum</code>函数没被用到，<code>webpack</code>打包会添加注释，<code>terser</code>在优化时，则将该函数去掉</p><p> <img src="https://static.vue-js.com/21b2e200-aee4-11eb-85f6-6fac77c0c9b3.png"></p><h4 id="sideEffects"><a href="#sideEffects" class="headerlink" title="sideEffects"></a>sideEffects</h4><p><code>sideEffects</code>用于告知<code>webpack compiler</code>哪些模块时有副作用，配置方法是在<code>package.json</code>中设置<code>sideEffects</code>属性</p><p>如果<code>sideEffects</code>设置为false，就是告知<code>webpack</code>可以安全的删除未用到的<code>exports</code></p><p>如果有些文件需要保留，可以设置为数组的形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;sideEffecis&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;./src/util/format.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.css&quot;</span> <span class="comment">// 所有的css文件</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>上述都是关于<code>javascript</code>的<code>tree shaking</code>，<code>css</code>同样也能够实现<code>tree shaking</code></p><h4 id="css-tree-shaking"><a href="#css-tree-shaking" class="headerlink" title="css tree shaking"></a>css tree shaking</h4><p><code>css</code>进行<code>tree shaking</code>优化可以安装<code>PurgeCss</code>插件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install purgecss-plugin-webpack -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PurgeCssPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;purgecss-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">plugins</span>:[</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PurgeCssPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">path</span>:glob.<span class="title function_">sync</span>(<span class="string">`<span class="subst">$&#123;path.resolve(<span class="string">&#x27;./src&#x27;</span>)&#125;</span>/**/*`</span>), &#123;<span class="attr">nodir</span>:<span class="literal">true</span>&#125;<span class="comment">// src里面的所有文件</span></span><br><span class="line">            <span class="attr">satelist</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">standard</span>:[<span class="string">&quot;html&quot;</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>paths：表示要检测哪些目录下的内容需要被分析，配合使用glob</li><li>默认情况下，Purgecss会将我们的html标签的样式移除掉，如果我们希望保留，可以添加一个safelist的属性</li></ul><h3 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h3><p>将代码分离到不同的<code>bundle</code>中，之后我们可以按需加载，或者并行加载这些文件</p><p>默认情况下，所有的<code>JavaScript</code>代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度</p><p>代码分离可以分出出更小的<code>bundle</code>，以及控制资源加载优先级，提供代码的加载性能</p><p>这里通过<code>splitChunksPlugin</code>来实现，该插件<code>webpack</code>已经默认安装和集成，只需要配置即可</p><p>默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为initial或者all</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">optimization</span>:&#123;</span><br><span class="line">        <span class="attr">splitChunks</span>:&#123;</span><br><span class="line">            <span class="attr">chunks</span>:<span class="string">&quot;all&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>splitChunks</code>主要属性有如下：</p><ul><li>Chunks，对同步代码还是异步代码进行处理</li><li>minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分</li><li>maxSize： 将大于maxSize的包，拆分为不小于minSize的包</li><li>minChunks：被引入的次数，默认是1</li></ul><h3 id="内联chunk"><a href="#内联chunk" class="headerlink" title="内联chunk"></a>内联chunk</h3><p>可以通过<code>InlineChunkHtmlPlugin</code>插件将一些<code>chunk</code>的模块内联到<code>html</code>，如<code>runtime</code>的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">InlineChunkHtmlPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;react-dev-utils/InlineChunkHtmlPlugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">plugin</span>:[</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InlineChunkHtmlPlugin</span>(<span class="title class_">HtmlWebpackPlugin</span>,[<span class="regexp">/runtime.+\.js/</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>关于<code>webpack</code>对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少http请求次数等方式，实现对前端性能的优化</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/139498741">https://zhuanlan.zhihu.com/p/139498741</a></li><li><a href="https://vue3js.cn/interview/">https://vue3js.cn/interview/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack来优化前端性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack中常见的Loader？解决了什么问题</title>
      <link href="/2023/06/29/webpack-Loader/"/>
      <url>/2023/06/29/webpack-Loader/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack中常见的Loader？解决了什么问题？"><a href="#webpack中常见的Loader？解决了什么问题？" class="headerlink" title="webpack中常见的Loader？解决了什么问题？"></a>webpack中常见的Loader？解决了什么问题？</h1><p> <img src="https://static.vue-js.com/5660fc40-a6ff-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>loader</code> 用于对模块的”源代码”进行转换，在 <code>import</code> 或”加载”模块时预处理文件</p><p><code>webpack</code>做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。如下图所示：</p><p> <img src="https://static.vue-js.com/7b8d9640-a6ff-11eb-ab90-d9ae814b240d.png"></p><span id="more"></span><p>在<code>webpack</code>内部中，任何文件都是模块，不仅仅只是<code>js</code>文件</p><p>默认情况下，在遇到<code>import</code>或者<code>require</code>加载模块的时候，<code>webpack</code>只支持对<code>js</code> 和 <code>json</code> 文件打包</p><p>像<code>css</code>、<code>sass</code>、<code>png</code>等这些类型的文件的时候，<code>webpack</code>则无能为力，这时候就需要配置对应的<code>loader</code>进行文件内容的解析</p><p>在加载模块的时候，执行顺序如下：</p><p> <img src="https://static.vue-js.com/9c2c43b0-a6ff-11eb-85f6-6fac77c0c9b3.png"></p><p>当 <code>webpack</code> 碰到不识别的模块的时候，<code>webpack</code> 会在配置的中查找该文件解析规则</p><p>关于配置<code>loader</code>的方式有三种：</p><ul><li>配置方式（推荐）：在 webpack.config.js文件中指定 loader</li><li>内联方式：在每个 import 语句中显式指定 loader</li><li>CLI 方式：在 shell 命令中指定它们</li></ul><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>关于<code>loader</code>的配置，我们是写在<code>module.rules</code>属性中，属性介绍如下：</p><ul><li><p><code>rules</code>是一个数组的形式，因此我们可以配置很多个<code>loader</code></p></li><li><p>每一个<code>loader</code>对应一个对象的形式，对象属性<code>test</code> 为匹配的规则，一般情况为正则表达式</p></li><li><p>属性<code>use</code>针对匹配到文件类型，调用对应的 <code>loader</code> 进行处理</p></li></ul><p>代码编写，如下形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">&#x27;style-loader&#x27;</span> &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">modules</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">&#x27;sass-loader&#x27;</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h2><p>这里继续拿上述代码，来讲讲<code>loader</code>的特性</p><p>从上述代码可以看到，在处理<code>css</code>模块的时候，<code>use</code>属性中配置了三个<code>loader</code>分别处理<code>css</code>文件</p><p>因为<code>loader </code>支持链式调用，链中的每个<code>loader</code>会处理之前已处理过的资源，最终变为<code>js</code>代码。顺序为相反的顺序执行，即上述执行方式为<code>sass-loader</code>、<code>css-loader</code>、<code>style-loader</code></p><p>除此之外，<code>loader</code>的特性还有如下：</p><ul><li>loader 可以是同步的，也可以是异步的</li><li>loader 运行在 Node.js 中，并且能够执行任何操作</li><li>除了常见的通过 <code>package.json</code> 的 <code>main</code> 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 <code>loader</code> 字段直接引用一个模块</li><li>插件(plugin)可以为 loader 带来更多特性</li><li>loader 能够产生额外的任意文件</li></ul><p>可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言翻译和更多其他特性</p><h2 id="三、常见的loader"><a href="#三、常见的loader" class="headerlink" title="三、常见的loader"></a>三、常见的loader</h2><p>在页面开发过程中，我们经常性加载除了<code>js</code>文件以外的内容，这时候我们就需要配置响应的<code>loader</code>进行加载</p><p>常见的<code>loader</code>如下：</p><ul><li>style-loader: 将css添加到DOM的内联样式标签style里</li><li>css-loader :允许将css文件通过require的方式引入，并返回css代码</li><li>less-loader: 处理less</li><li>sass-loader: 处理sass</li><li>postcss-loader: 用postcss来处理CSS</li><li>autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss</li><li>file-loader: 分发文件到output目录并返回相对路径</li><li>url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</li><li>html-minify-loader: 压缩HTML</li><li>babel-loader :用babel来转换ES6文件到ES</li></ul><p>下面给出一些常见的<code>loader</code>的使用：</p><h3 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h3><p>分析 <code>css</code> 模块之间的关系，并合成⼀个 <code>css</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">  ...,</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    <span class="attr">use</span>: &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">     <span class="comment">// 启用/禁用 url() 处理</span></span><br><span class="line">     <span class="attr">url</span>: <span class="literal">true</span>,</span><br><span class="line">     <span class="comment">// 启用/禁用 @import 处理</span></span><br><span class="line">     <span class="attr">import</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 启用/禁用 Sourcemap</span></span><br><span class="line">        <span class="attr">sourceMap</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果只通过<code>css-loader</code>加载文件，这时候页面代码设置的样式并没有生效</p><p>原因在于，<code>css-loader</code>只是负责将<code>.css</code>文件进行一个解析，而并不会将解析后的<code>css</code>插入到页面中</p><p>如果我们希望再完成插入<code>style</code>的操作，那么我们还需要另外一个<code>loader</code>，就是<code>style-loader</code></p><h3 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h3><p>把 <code>css-loader</code> 生成的内容，用 <code>style</code> 标签挂载到页面的 <code>head</code> 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">  ...,</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>]</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>同一个任务的 <code>loader</code> 可以同时挂载多个，处理顺序为：从右到左，从下往上</p><h3 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h3><p>开发中，我们也常常会使用<code>less</code>、<code>sass</code>、<code>stylus</code>预处理器编写<code>css</code>样式，使开发效率提高，这里需要使用<code>less-loader</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less-loader -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">  ...,</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>,<span class="string">&quot;less-loader&quot;</span>]</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="raw-loader"><a href="#raw-loader" class="headerlink" title="raw-loader"></a>raw-loader</h3><p>在 <code>webpack </code>中通过 <code>import </code>方式导入文件内容，该<code>loader </code>并不是内置的，所以首先要安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev raw-loader</span><br></pre></td></tr></table></figure><p>然后在 webpack.config.js 中进行配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  ...,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">      <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(txt|md)$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;raw-loader&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line">    ]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p>把识别出的资源模块，移动到指定的输出⽬目录，并且返回这个资源在输出目录的地址(字符串)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">  ...,</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif)$/</span>,</span><br><span class="line">    <span class="attr">use</span>: &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;file-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="comment">// placeholder 占位符 [name] 源资源模块的名称</span></span><br><span class="line">        <span class="comment">// [ext] 源资源模块的后缀</span></span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;[name]_[hash].[ext]&quot;</span>,</span><br><span class="line">        <span class="comment">//打包后的存放位置</span></span><br><span class="line">        <span class="attr">outputPath</span>: <span class="string">&quot;./images&quot;</span>,</span><br><span class="line">        <span class="comment">// 打包后文件的 url</span></span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;./images&#x27;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p>可以处理理 <code>file-loader</code> 所有的事情，但是遇到图片格式的模块，可以选择性的把图片转成 <code>base64</code>  格式的字符串，并打包到 <code>js</code> 中，对小体积的图片比较合适，大图片不合适。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev url-loader</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">  ...,</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif)$/</span>,</span><br><span class="line">    <span class="attr">use</span>: &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;url-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="comment">// placeholder 占位符 [name] 源资源模块的名称</span></span><br><span class="line">        <span class="comment">// [ext] 源资源模块的后缀</span></span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;[name]_[hash].[ext]&quot;</span>,</span><br><span class="line">        <span class="comment">//打包后的存放位置</span></span><br><span class="line">        <span class="attr">outputPath</span>: <span class="string">&quot;./images&quot;</span></span><br><span class="line">        <span class="comment">// 打包后文件的 url</span></span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;./images&#x27;</span>,</span><br><span class="line">        <span class="comment">// 小于 100 字节转成 base64 格式</span></span><br><span class="line">        <span class="attr">limit</span>: <span class="number">100</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://webpack.docschina.org/concepts/loaders/">https://webpack.docschina.org/concepts/loaders/</a></li><li><a href="https://segmentfault.com/a/1190000018680530">https://segmentfault.com/a/1190000018680530</a></li><li><a href="https://vue3js.cn/interview/">https://vue3js.cn/interview/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Loader和Plugin的区别？编写Loader，Plugin的思路？</title>
      <link href="/2023/06/23/webpack-Loader_Plugin/"/>
      <url>/2023/06/23/webpack-Loader_Plugin/</url>
      
        <content type="html"><![CDATA[<h1 id="Loader和Plugin的区别？编写Loader，Plugin的思路？"><a href="#Loader和Plugin的区别？编写Loader，Plugin的思路？" class="headerlink" title="Loader和Plugin的区别？编写Loader，Plugin的思路？"></a>Loader和Plugin的区别？编写Loader，Plugin的思路？</h1><p><img src="https://static.vue-js.com/93042280-a894-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、区别"><a href="#一、区别" class="headerlink" title="一、区别"></a>一、区别</h2><p>前面两节我们有提到<code>Loader</code>与<code>Plugin</code>对应的概念，先来回顾下</p><ul><li>loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</li><li>plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事<span id="more"></span>从整个运行时机上来看，如下图所示：</li></ul><p><img src="https://static.vue-js.com/9a04ec40-a7c2-11eb-ab90-d9ae814b240d.png"></p><p>可以看到，两者在运行时机上的区别：</p><ul><li>loader 运行在打包文件之前</li><li>plugins 在整个编译周期都起作用</li></ul><p>在<code> Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过<code>Webpack</code>提供的 <code>API </code>改变输出结果</p><p>对于<code>loader</code>，实质是一个转换器，将A文件进行编译形成B文件，操作的是文件，比如将<code>A.scss</code>或<code>A.less</code>转变为<code>B.css</code>，单纯的文件转换过程</p><h2 id="二、编写loader"><a href="#二、编写loader" class="headerlink" title="二、编写loader"></a>二、编写loader</h2><p>在编写 <code>loader</code> 前，我们首先需要了解 <code>loader</code> 的本质</p><p>其本质为函数，函数中的 <code>this</code> 作为上下文会被 <code>webpack</code> 填充，因此我们不能将 <code>loader</code>设为一个箭头函数</p><p>函数接受一个参数，为 <code>webpack</code> 传递给 <code>loader</code> 的文件源内容</p><p>函数中 <code>this</code> 是由 <code>webpack</code> 提供的对象，能够获取当前 <code>loader</code> 所需要的各种信息</p><p>函数中有异步操作或同步操作，异步操作通过 <code>this.callback</code> 返回，返回值要求为 <code>string</code> 或者 <code>Buffer</code></p><p>代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出一个函数，source为webpack传递给loader的文件源内容</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> content = <span class="title function_">doSomeThing2JsString</span>(source);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 loader 配置了 options 对象，那么this.query将指向 options</span></span><br><span class="line">    <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">query</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以用作解析其他模块路径的上下文</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this.context&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this.callback 参数：</span></span><br><span class="line"><span class="comment">     * error：Error | null，当 loader 出错时向外抛出一个 error</span></span><br><span class="line"><span class="comment">     * content：String | Buffer，经过 loader 编译后需要导出的内容</span></span><br><span class="line"><span class="comment">     * sourceMap：为方便调试生成的编译后内容的 source map</span></span><br><span class="line"><span class="comment">     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="literal">null</span>, content); <span class="comment">// 异步</span></span><br><span class="line">    <span class="keyword">return</span> content; <span class="comment">// 同步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在编写<code>loader</code>的过程中，保持功能单一，避免做多种功能</p><p>如<code>less</code>文件转换成 <code>css </code>文件也不是一步到位，而是 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code>几个 <code>loader </code>的链式调用才能完成转换</p><h2 id="三、编写plugin"><a href="#三、编写plugin" class="headerlink" title="三、编写plugin"></a>三、编写plugin</h2><p>由于<code>webpack</code>基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务</p><p>在之前也了解过，<code>webpack</code>编译会创建两个核心对象：</p><ul><li>compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子</li><li>compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建</li></ul><p>如果自己要实现<code>plugin</code>，也需要遵循一定的规范：</p><ul><li>插件必须是一个函数或者是一个包含 <code>apply</code> 方法的对象，这样才能访问<code>compiler</code>实例</li><li>传给每个插件的 <code>compiler</code> 和 <code>compilation</code> 对象都是同一个引用，因此不建议修改</li><li>异步的事件需要在插件处理完任务时调用回调函数通知 <code>Webpack</code> 进入下一个流程，不然会卡住</li></ul><p>实现<code>plugin</code>的模板如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPlugin</span> &#123;</span><br><span class="line">    <span class="comment">// Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span></span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    <span class="comment">// 找到合适的事件钩子，实现自己的插件功能</span></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// compilation: 当前打包构建流程的上下文</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(compilation);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://webpack.docschina.org/api/loaders/">https://webpack.docschina.org/api/loaders/</a></li><li><a href="https://webpack.docschina.org/api/compiler-hooks/">https://webpack.docschina.org/api/compiler-hooks/</a></li><li><a href="https://segmentfault.com/a/1190000039877943">https://segmentfault.com/a/1190000039877943</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Loader，Plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何提高webpack的构建速度？</title>
      <link href="/2023/06/12/webpack-improve_build/"/>
      <url>/2023/06/12/webpack-improve_build/</url>
      
        <content type="html"><![CDATA[<h1 id="如何提高webpack的构建速度？"><a href="#如何提高webpack的构建速度？" class="headerlink" title="如何提高webpack的构建速度？"></a>如何提高webpack的构建速度？</h1><p> <img src="https://static.vue-js.com/3a1b8620-b01b-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>随着我们的项目涉及到页面越来越多，功能和业务代码也会随着越多，相应的 <code>webpack</code> 的构建时间也会越来越久</p><p>构建时间与我们日常开发效率密切相关，当我们本地开发启动 <code>devServer</code> 或者 <code>build</code> 的时候，如果时间过长，会大大降低我们的工作效率</p><p>所以，优化<code>webpack</code> 构建速度是十分重要的环节</p><span id="more"></span><h2 id="二、如何优化"><a href="#二、如何优化" class="headerlink" title="二、如何优化"></a>二、如何优化</h2><p>常见的提升构建速度的手段有如下：</p><ul><li>优化 loader 配置</li><li>合理使用 resolve.extensions</li><li>优化 resolve.modules</li><li>优化 resolve.alias</li><li>使用 DLLPlugin 插件</li><li>使用 cache-loader</li><li>terser 启动多线程</li><li>合理使用 sourceMap</li></ul><h3 id="优化loader配置"><a href="#优化loader配置" class="headerlink" title="优化loader配置"></a>优化loader配置</h3><p>在使用<code>loader</code>时，可以通过配置<code>include</code>、<code>exclude</code>、<code>test</code>属性来匹配文件，接触<code>include</code>、<code>exclude</code>规定哪些匹配应用<code>loader</code></p><p>如采用 ES6 的项目为例，在配置 <code>babel-loader </code>时，可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启</span></span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&#x27;babel-loader?cacheDirectory&#x27;</span>],</span><br><span class="line">        <span class="comment">// 只对项目根目录下的 src 目录中的文件采用 babel-loader</span></span><br><span class="line">        <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="合理使用-resolve-extensions"><a href="#合理使用-resolve-extensions" class="headerlink" title="合理使用 resolve.extensions"></a>合理使用 resolve.extensions</h3><p>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， <code>resolve</code>可以帮助<code>webpack</code>从每个 <code>require/import</code> 语句中，找到需要引入到合适的模块代码</p><p>通过<code>resolve.extensions</code>是解析到文件时自动添加拓展名，默认情况如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">extensions</span>:[<span class="string">&quot;.warm&quot;</span>,<span class="string">&quot;.mjs&quot;</span>,<span class="string">&quot;.js&quot;</span>,<span class="string">&quot;.json&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找</p><p>当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度</p><h3 id="优化-resolve-modules"><a href="#优化-resolve-modules" class="headerlink" title="优化 resolve.modules"></a>优化 resolve.modules</h3><p><code>resolve.modules</code> 用于配置 <code>webpack</code> 去哪些目录下寻找第三方模块。默认值为<code>[&#39;node_modules&#39;]</code>，所以默认会从<code>node_modules</code>中查找文件<br>当安装的第三方模块都放在项目根目录下的 <code>./node_modules </code>目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span><br><span class="line">    // 其中 __dirname 表示当前工作目录，也就是项目根目录</span><br><span class="line">    modules: [path.resolve(__dirname, &#x27;node_modules&#x27;)]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="优化-resolve-alias"><a href="#优化-resolve-alias" class="headerlink" title="优化 resolve.alias"></a>优化 resolve.alias</h3><p><code>alias</code>给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是<code>./../../</code>的形式</p><p>通过配置<code>alias</code>以减少查找过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">resolve</span>:&#123;</span><br><span class="line">        <span class="attr">alias</span>:&#123;</span><br><span class="line">            <span class="string">&quot;@&quot;</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;./src&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-DLLPlugin-插件"><a href="#使用-DLLPlugin-插件" class="headerlink" title="使用 DLLPlugin 插件"></a>使用 DLLPlugin 插件</h3><p><code>DLL</code>全称是 动态链接库，是为软件在winodw种实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中</p><p>使用步骤分成两部分：</p><ul><li>打包一个 DLL 库</li><li>引入 DLL 库</li></ul><h4 id="打包一个-DLL-库"><a href="#打包一个-DLL-库" class="headerlink" title="打包一个 DLL 库"></a>打包一个 DLL 库</h4><p><code>webpack</code>内置了一个<code>DllPlugin</code>可以帮助我们打包一个DLL的库文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">plugins</span>:[</span><br><span class="line">        <span class="keyword">new</span> webpack.<span class="title class_">DllPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;dll_[name]&#x27;</span>,</span><br><span class="line">            <span class="attr">path</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./dll/[name].mainfest.json&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引入-DLL-库"><a href="#引入-DLL-库" class="headerlink" title="引入 DLL 库"></a>引入 DLL 库</h4><p>使用 <code>webpack</code> 自带的 <code>DllReferencePlugin</code> 插件对 <code>mainfest.json</code> 映射文件进行分析，获取要使用的<code>DLL</code>库</p><p>然后再通过<code>AddAssetHtmlPlugin</code>插件，将我们打包的<code>DLL</code>库引入到<code>Html</code>模块中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllReferencePlugin</span>(&#123;</span><br><span class="line">        <span class="attr">context</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./dll/dll_react.js&quot;</span>),</span><br><span class="line">        <span class="attr">mainfest</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./dll/react.mainfest.json&quot;</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AddAssetHtmlPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">outputPath</span>:<span class="string">&quot;./auto&quot;</span>,</span><br><span class="line">        <span class="attr">filepath</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./dll/dll_react.js&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-cache-loader"><a href="#使用-cache-loader" class="headerlink" title="使用 cache-loader"></a>使用 cache-loader</h3><p>在一些性能开销较大的 <code>loader </code>之前添加 <code>cache-loader</code>，以将结果缓存到磁盘里，显著提升二次构建速度</p><p>保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 <code>loader</code> 使用此<code> loader</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ext$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;cache-loader&#x27;</span>, ...loaders],</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="terser-启动多线程"><a href="#terser-启动多线程" class="headerlink" title="terser 启动多线程"></a>terser 启动多线程</h3><p>使用多进程并行运行来提高构建速度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">parallel</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="合理使用-sourceMap"><a href="#合理使用-sourceMap" class="headerlink" title="合理使用 sourceMap"></a>合理使用 sourceMap</h3><p>打包生成  <code>sourceMap</code> 的时候，如果信息越详细，打包速度就会越慢。对应属性取值如下所示：</p><p><img src="https://static.vue-js.com/11647af0-b01d-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>可以看到，优化<code>webpack</code>构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://github.com/ly2011/blog/issues/44">https://github.com/ly2011/blog/issues/44</a></li><li><a href="https://xie.infoq.cn/article/541418eb82a674741a0ad8865">https://xie.infoq.cn/article/541418eb82a674741a0ad8865</a></li><li><a href="https://zhuanlan.zhihu.com/p/139498741">https://zhuanlan.zhihu.com/p/139498741</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack的构建速度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack的热更新是如何做到的？原理是什么？</title>
      <link href="/2023/05/21/webpack-HMR/"/>
      <url>/2023/05/21/webpack-HMR/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack的热更新是如何做到的？原理是什么？"><a href="#webpack的热更新是如何做到的？原理是什么？" class="headerlink" title="webpack的热更新是如何做到的？原理是什么？"></a>webpack的热更新是如何做到的？原理是什么？</h1><p> <img src="https://static.vue-js.com/a076da40-acd4-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h3><p><code>HMR </code>全称 <code>Hot Module Replacement</code>，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用</p><span id="more"></span><p>例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失</p><p>如果使用的是 <code>HMR</code>，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用</p><p>在<code>webpack</code>中配置开启热模块也非常的简单，如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 开启 HMR 特性</span></span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// hotOnly: true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述这种配置，如果我们修改并保存<code>css</code>文件，确实能够以不刷新的形式更新到页面中</p><p>但是，当我们修改并保存<code>js</code>文件之后，页面依旧自动刷新了，这里并没有触发热模块</p><p>所以，<code>HMR </code>并不像 <code>Webpack</code> 的其他特性一样可以开箱即用，需要有一些额外的操作</p><p>我们需要去指定哪些模块发生更新时进行<code>HRM</code>，如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable language_">module</span>.<span class="property">hot</span>)&#123;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./util.js&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;util.js更新了&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><p>首先来看看一张图，如下：</p><p> <img src="https://static.vue-js.com/adc05780-acd4-11eb-ab90-d9ae814b240d.png"></p><ul><li>Webpack Compile：将 JS 源代码编译成 bundle.js</li><li>HMR Server：用来将热更新的文件输出给 HMR Runtime</li><li>Bundle Server：静态资源文件服务器，提供文件访问路径</li><li>HMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化</li><li>bundle.js：构建输出的文件</li><li>在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化</li></ul><p>上面图中，可以分成两个阶段：</p><ul><li>启动阶段为上图 1 - 2 - A - B</li></ul><p>在编写未经过<code>webpack</code>打包的源代码后，<code>Webpack Compile</code> 将源代码和 <code>HMR Runtime</code> 一起编译成 <code>bundle </code>文件，传输给<code> Bundle Server</code> 静态资源服务器</p><ul><li>更新阶段为上图 1 - 2 - 3 - 4</li></ul><p>当某一个文件或者模块发生变化时，<code>webpack </code>监听到文件变化对文件重新编译打包，编译生成唯一的<code>hash</code>值，这个<code>hash </code>值用来作为下一次热更新的标识</p><p>根据变化的内容生成两个补丁文件：<code>manifest</code>（包含了 <code>hash</code> 和 <code>chundId </code>，用来说明变化的内容）和<code> chunk.js</code> 模块</p><p>由于<code>socket</code>服务器在<code>HMR Runtime</code> 和 <code>HMR Server</code>之间建立 <code>websocket</code>链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的<code>hash</code>值，如下图的<code>h</code>属性，作为下一次热更细的标识</p><p> <img src="https://static.vue-js.com/05a0edf0-ad4a-11eb-85f6-6fac77c0c9b3.png"></p><p>在浏览器接受到这条消息之前，浏览器已经在上一次<code> socket</code> 消息中已经记住了此时的<code> hash</code> 标识，这时候我们会创建一个 <code>ajax</code> 去服务端请求获取到变化内容的 <code>manifest</code> 文件</p><p><code>mainfest</code>文件包含重新<code>build</code>生成的<code>hash</code>值，以及变化的模块，对应上图的<code>c</code>属性</p><p>浏览器根据 <code>manifest</code> 文件获取模块变化的内容，从而触发<code>render</code>流程，实现局部模块更新</p><p> <img src="https://static.vue-js.com/0e7b7850-ad4a-11eb-ab90-d9ae814b240d.png"></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>关于<code>webpack</code>热模块更新的总结如下：</p><ul><li>通过<code>webpack-dev-server</code>创建两个服务器：提供静态资源的服务（express）和Socket服务</li><li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li><li>socket server 是一个 websocket 的长连接，双方可以通信</li><li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li><li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li><li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/138446061">https://zhuanlan.zhihu.com/p/138446061</a></li><li><a href="https://github.com/Jocs/jocs.github.io/issues/15">https://github.com/Jocs/jocs.github.io/issues/15</a></li><li><a href="https://juejin.cn/post/6844904134697549832">https://juejin.cn/post/6844904134697549832</a></li><li><a href="https://vue3js.cn/interview/">https://vue3js.cn/interview/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack的热更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack的构建流程?</title>
      <link href="/2023/05/13/webpack-build_process/"/>
      <url>/2023/05/13/webpack-build_process/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack的构建流程"><a href="#webpack的构建流程" class="headerlink" title="webpack的构建流程?"></a>webpack的构建流程?</h1><p><img src="https://static.vue-js.com/96cf6840-a658-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、运行流程"><a href="#一、运行流程" class="headerlink" title="一、运行流程"></a>一、运行流程</h2><p><code>webpack</code> 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来</p><p>在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条<code>webpack</code>机制中，去改变<code>webpack</code>的运作，使得整个系统扩展性良好</p><span id="more"></span><p>从启动到结束会依次执行以下三大步骤：</p><ul><li>初始化流程：从配置文件和 <code>Shell</code> 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li><li>编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li><li>输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统</li></ul><p> <img src="https://static.vue-js.com/b566d400-a658-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p>从配置文件和 <code>Shell</code> 语句中读取与合并参数，得出最终的参数</p><p>配置文件默认下为<code>webpack.config.js</code>，也或者通过命令的形式指定配置文件，主要作用是用于激活<code>webpack</code>的加载项和插件</p><p>关于文件配置内容分析，如下注释：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> node_modules = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;node_modules&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> pathToReact = path.<span class="title function_">resolve</span>(node_modules, <span class="string">&#x27;react/dist/react.min.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span>，</span><br><span class="line">  <span class="comment">// 文件路径指向(可加快打包过程)。</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;react&#x27;</span>: pathToReact</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生成文件，是模块构建的终点，包括输出文件与输出路径。</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">loaders</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel&#x27;</span>,</span><br><span class="line">        <span class="attr">query</span>: &#123;</span><br><span class="line">          <span class="attr">presets</span>: [<span class="string">&#x27;es2015&#x27;</span>, <span class="string">&#x27;react&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">noParse</span>: [pathToReact]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// webpack 各插件对象，在 webpack 的事件流中执行对应的方法。</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>webpack</code> 将 <code>webpack.config.js</code> 中的各个配置项拷贝到 <code>options</code> 对象中，并加载用户配置的 <code> plugins</code></p><p>完成上述步骤之后，则开始初始化<code>Compiler</code>编译对象，该对象掌控者<code>webpack</code>声明周期，不执行具体的任务，只是进行一些调度工作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compiler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Tapable</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">context</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">hooks</span> = &#123;</span><br><span class="line">            <span class="attr">beforeCompile</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;params&quot;</span>]),</span><br><span class="line">            <span class="attr">compile</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>([<span class="string">&quot;params&quot;</span>]),</span><br><span class="line">            <span class="attr">afterCompile</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;compilation&quot;</span>]),</span><br><span class="line">            <span class="attr">make</span>: <span class="keyword">new</span> <span class="title class_">AsyncParallelHook</span>([<span class="string">&quot;compilation&quot;</span>]),</span><br><span class="line">            <span class="attr">entryOption</span>: <span class="keyword">new</span> <span class="title class_">SyncBailHook</span>([<span class="string">&quot;context&quot;</span>, <span class="string">&quot;entry&quot;</span>])</span><br><span class="line">            <span class="comment">// 定义了很多不同类型的钩子</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">webpack</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> compiler = <span class="keyword">new</span> <span class="title class_">Compiler</span>();</span><br><span class="line">  ...<span class="comment">// 检查options,若watch字段为true,则开启watch线程</span></span><br><span class="line">  <span class="keyword">return</span> compiler;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>Compiler</code> 对象继承自 <code>Tapable</code>，初始化时定义了很多钩子函数</p><h3 id="编译构建流程"><a href="#编译构建流程" class="headerlink" title="编译构建流程"></a>编译构建流程</h3><p>根据配置中的 <code>entry</code> 找出所有的入口文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/file.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完成后会调用<code>Compiler</code>的<code>run</code>来真正启动<code>webpack</code>编译构建流程，主要流程如下：</p><ul><li><code>compile</code> 开始编译</li><li><code>make</code> 从入口点分析模块及其依赖的模块，创建这些模块对象</li><li><code>build-module</code> 构建模块</li><li><code>seal</code> 封装构建结果</li><li><code>emit</code> 把各个chunk输出到结果文件</li></ul><h4 id="compile-编译"><a href="#compile-编译" class="headerlink" title="compile 编译"></a>compile 编译</h4><p>执行了<code>run</code>方法后，首先会触发<code>compile</code>，主要是构建一个<code>Compilation</code>对象</p><p>该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象</p><h4 id="make-编译模块"><a href="#make-编译模块" class="headerlink" title="make 编译模块"></a>make 编译模块</h4><p>当完成了上述的<code>compilation</code>对象后，就开始从<code>Entry</code>入口文件开始读取，主要执行<code>_addModuleChain()</code>函数，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">_addModuleChain</span>(<span class="params">context, dependency, onModule, callback</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 根据依赖查找对应的工厂函数</span></span><br><span class="line">   <span class="keyword">const</span> <span class="title class_">Dep</span> = <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">DepConstructor</span>&#125; */</span> (dependency.<span class="property">constructor</span>);</span><br><span class="line">   <span class="keyword">const</span> moduleFactory = <span class="variable language_">this</span>.<span class="property">dependencyFactories</span>.<span class="title function_">get</span>(<span class="title class_">Dep</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象</span></span><br><span class="line">   moduleFactory.<span class="title function_">create</span>(&#123;</span><br><span class="line">       <span class="attr">dependencies</span>: [dependency]</span><br><span class="line">       ...</span><br><span class="line">   &#125;, <span class="function">(<span class="params">err, <span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">const</span> <span class="title function_">afterBuild</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">processModuleDependencies</span>(<span class="variable language_">module</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line">         <span class="title function_">callback</span>(<span class="literal">null</span>, <span class="variable language_">module</span>);</span><br><span class="line">           &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">       </span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">buildModule</span>(<span class="variable language_">module</span>, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">           ...</span><br><span class="line">           <span class="title function_">afterBuild</span>();</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程如下：</p><p><code>_addModuleChain</code>中接收参数<code>dependency</code>传入的入口依赖，使用对应的工厂函数<code>NormalModuleFactory.create</code>方法生成一个空的<code>module</code>对象</p><p>回调中会把此<code>module</code>存入<code>compilation.modules</code>对象和<code>dependencies.module</code>对象中，由于是入口文件，也会存入<code>compilation.entries</code>中</p><p>随后执行<code>buildModule</code>进入真正的构建模块<code>module</code>内容的过程</p><h4 id="build-module-完成模块编译"><a href="#build-module-完成模块编译" class="headerlink" title="build module 完成模块编译"></a>build module 完成模块编译</h4><p>这里主要调用配置的<code>loaders</code>，将我们的模块转成标准的<code>JS</code>模块</p><p>在用<code> Loader</code> 对一个模块转换完后，使用 <code>acorn</code> 解析转换后的内容，输出对应的抽象语法树（<code>AST</code>），以方便 <code>Webpack </code>后面对代码的分析</p><p>从配置的入口模块开始，分析其 <code>AST</code>，当遇到<code>require</code>等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系</p><h3 id="输出流程"><a href="#输出流程" class="headerlink" title="输出流程"></a>输出流程</h3><h4 id="seal-输出资源"><a href="#seal-输出资源" class="headerlink" title="seal 输出资源"></a>seal 输出资源</h4><p><code>seal</code>方法主要是要生成<code>chunks</code>，对<code>chunks</code>进行一系列的优化操作，并生成要输出的代码</p><p><code>webpack</code> 中的 <code>chunk</code> ，可以理解为配置在 <code>entry</code> 中的模块，或者是动态引入的模块</p><p>根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表</p><h4 id="emit-输出完成"><a href="#emit-输出完成" class="headerlink" title="emit 输出完成"></a>emit 输出完成</h4><p>在确定好输出内容后，根据配置确定输出的路径和文件名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Compiler</code> 开始生成文件前，钩子 <code>emit</code> 会被执行，这是我们修改最终文件的最后一个机会</p><p>从而<code>webpack</code>整个打包过程则结束了</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> <img src="https://static.vue-js.com/d77fc560-a658-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://github.com/Cosen95/blog/issues/48">https://github.com/Cosen95/blog/issues/48</a></li><li><a href="https://developer.aliyun.com/article/61047">https://developer.aliyun.com/article/61047</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack的构建流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 3.0中Treeshaking特性？举例说明一下？</title>
      <link href="/2023/05/06/vue3-treeshaking/"/>
      <url>/2023/05/06/vue3-treeshaking/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-3-0中Treeshaking特性？举例说明一下？"><a href="#Vue-3-0中Treeshaking特性？举例说明一下？" class="headerlink" title="Vue 3.0中Treeshaking特性？举例说明一下？"></a>Vue 3.0中Treeshaking特性？举例说明一下？</h1><p> <img src="https://static.vue-js.com/5e8bf1d0-6097-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>Tree shaking</code> 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 <code>Dead code elimination</code></p><p>简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码</p><p>如果把代码打包比作制作蛋糕，传统的方式是把鸡蛋（带壳）全部丢进去搅拌，然后放入烤箱，最后把（没有用的）蛋壳全部挑选并剔除出去</p><p>而<code>treeshaking</code>则是一开始就把有用的蛋白蛋黄（import）放入搅拌，最后直接作出蛋糕</p><p>也就是说 ，<code>tree shaking</code> 其实是找出使用的代码</p><span id="more"></span><p>在<code>Vue2</code>中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是<code>Vue</code>实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>而<code>Vue3</code>源码引入<code>tree shaking</code>特性，将全局 API 进行分块。如果您不使用其某些功能，它们将不会包含在您的基础包中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick, observable &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="二、如何做"><a href="#二、如何做" class="headerlink" title="二、如何做"></a>二、如何做</h2><p><code>Tree shaking</code>是基于<code>ES6</code>模板语法（<code>import</code>与<code>exports</code>），主要是借助<code>ES6</code>模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量</p><p><code>Tree shaking</code>无非就是做了两件事：</p><ul><li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li><li>判断那些模块和变量未被使用或者引用，进而删除对应代码</li></ul><p>下面就来举个例子：</p><p>通过脚手架<code>vue-cli</code>安装<code>Vue2</code>与<code>Vue3</code>项目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vue-demo</span><br></pre></td></tr></table></figure><h3 id="Vue2-项目"><a href="#Vue2-项目" class="headerlink" title="Vue2 项目"></a>Vue2 项目</h3><p>组件中使用<code>data</code>属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data: () =&gt; (&#123;</span><br><span class="line">            count: 1,</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>对项目进行打包，体积如下图</p><p><img src="https://static.vue-js.com/6bd2aff0-6097-11eb-85f6-6fac77c0c9b3.png"></p><p>为组件设置其他属性（<code>compted</code>、<code>watch</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">question</span>:<span class="string">&quot;&quot;</span>, </span><br><span class="line">        <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="attr">double</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">        <span class="attr">question</span>: <span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再一次打包，发现打包出来的体积并没有变化</p><p><img src="https://static.vue-js.com/7c29e260-6097-11eb-ab90-d9ae814b240d.png"></p><h3 id="Vue3-项目"><a href="#Vue3-项目" class="headerlink" title="Vue3 项目"></a>Vue3 项目</h3><p>组件中简单使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将项目进行打包</p><p><img src="https://static.vue-js.com/95df0000-6097-11eb-85f6-6fac77c0c9b3.png"></p><p>在组件中引入<code>computed</code>和<code>watch</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, defineComponent, computed, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> state.<span class="property">count</span>,</span><br><span class="line">      <span class="function">(<span class="params">count, preCount</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(preCount);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">      double,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再次对项目进行打包，可以看到在引入<code>computer</code>和<code>watch</code>之后，项目整体体积变大了</p><p> <img src="https://static.vue-js.com/b36a7a00-6097-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="三、作用"><a href="#三、作用" class="headerlink" title="三、作用"></a>三、作用</h2><p>通过<code>Tree shaking</code>，<code>Vue3</code>给我们带来的好处是：</p><ul><li>减少程序体积（更小）</li><li>减少程序执行时间（更快）</li><li>便于将来对程序架构进行优化（更友好）</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000038962700">https://segmentfault.com/a/1190000038962700</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue 3.0中Treeshaking特 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</title>
      <link href="/2023/04/23/vue3-proxy/"/>
      <url>/2023/04/23/vue3-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h1><p> <img src="https://static.vue-js.com/57aa5c80-5f7f-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、Object-defineProperty"><a href="#一、Object-defineProperty" class="headerlink" title="一、Object.defineProperty"></a>一、Object.defineProperty</h2><p>定义：<code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象</p><h5 id="为什么能实现响应式"><a href="#为什么能实现响应式" class="headerlink" title="为什么能实现响应式"></a>为什么能实现响应式</h5><p>通过<code>defineProperty</code> 两个属性，<code>get</code>及<code>set</code></p><ul><li>get</li></ul><p>属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值</p><span id="more"></span><ul><li>set</li></ul><p>属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined</p><p>下面通过代码展示：</p><p>定义一个响应式函数<code>defineReactive</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    app.<span class="property">innerText</span> = obj.<span class="property">foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>defineReactive</code>，数据发生变化触发<code>update</code>方法，实现数据响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title function_">defineReactive</span>(obj, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    obj.<span class="property">foo</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleTimeString</span>()</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>在对象存在多个<code>key</code>情况下，需要进行遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在嵌套对象的情况，还需要在<code>defineReactive</code>中进行递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="title function_">observe</span>(val)</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当给<code>key</code>赋值为对象的时候，还需要在<code>set</code>属性中进行递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">        <span class="title function_">observe</span>(newVal) <span class="comment">// 新值是对象的情况</span></span><br><span class="line">        <span class="title function_">notifyUpdate</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题</p><p>现在对一个对象进行删除与添加属性操作，无法劫持到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">observe</span>(obj)</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">foo</span> <span class="comment">// no ok</span></span><br><span class="line">obj.<span class="property">jar</span> = <span class="string">&#x27;xxx&#x27;</span> <span class="comment">// no ok</span></span><br></pre></td></tr></table></figure><p>当我们对一个数组进行监听的时候，并不那么好使了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrData = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arrData.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">defineProperty</span>(arrData,index,val)</span><br><span class="line">&#125;)</span><br><span class="line">arrData.<span class="title function_">push</span>() <span class="comment">// no ok</span></span><br><span class="line">arrData.<span class="title function_">pop</span>()  <span class="comment">// no ok</span></span><br><span class="line">arrDate[<span class="number">0</span>] = <span class="number">99</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>可以看到数据的<code>api</code>无法劫持到，从而无法实现数据响应式，</p><p>所以在<code>Vue2</code>中，增加了<code>set</code>、<code>delete</code> API，并且对数组<code>api</code>方法进行一个重写</p><p>还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>检测不到对象属性的添加和删除</li><li>数组<code>API</code>方法无法监听到</li><li>需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题</li></ul><h2 id="二、proxy"><a href="#二、proxy" class="headerlink" title="二、proxy"></a>二、proxy</h2><p><code>Proxy</code>的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了</p><p>在<code>ES6</code>系列中，我们详细讲解过<code>Proxy</code>的使用，就不再述说了</p><p>下面通过代码进行展示：</p><p>定义一个响应式方法<code>reactive</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下简单数据的操作，发现都能劫持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1.获取</span></span><br><span class="line">state.<span class="property">foo</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 2.设置已存在属性</span></span><br><span class="line">state.<span class="property">foo</span> = <span class="string">&#x27;fooooooo&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 3.设置不存在属性</span></span><br><span class="line">state.<span class="property">dong</span> = <span class="string">&#x27;dong&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 4.删除属性</span></span><br><span class="line"><span class="keyword">delete</span> state.<span class="property">dong</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>再测试嵌套对象情况，这时候发现就不那么 OK 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">bar</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置嵌套对象属性</span></span><br><span class="line">state.<span class="property">bar</span>.<span class="property">a</span> = <span class="number">10</span> <span class="comment">// no ok</span></span><br></pre></td></tr></table></figure><p>如果要解决，需要在<code>get</code>之上再进行一层代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">isObject</span>(res) ? <span class="title function_">reactive</span>(res) : res</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><code>Object.defineProperty</code>只能遍历对象属性进行劫持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy</code>直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy</code>可以直接监听数组的变化（<code>push</code>、<code>shift</code>、<code>splice</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> proxtObj = <span class="title function_">reactive</span>(obj)</span><br><span class="line">obj.<span class="title function_">psuh</span>(<span class="number">4</span>) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p><code>Proxy</code>有多达13种拦截方法,不限于<code>apply</code>、<code>ownKeys</code>、<code>deleteProperty</code>、<code>has</code>等等，这是<code>Object.defineProperty</code>不具备的</p><p>正因为<code>defineProperty</code>自身的缺陷，导致<code>Vue2</code>在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外<code>set</code>、<code>delete</code>方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组重写</span></span><br><span class="line"><span class="keyword">const</span> originalProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Object</span>.<span class="title function_">create</span>(originalProto)</span><br><span class="line">[<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>, <span class="string">&#x27;reverse&#x27;</span>, <span class="string">&#x27;sort&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  arrayProto[method] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    originalProto[method].<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">arguments</span>)</span><br><span class="line">    dep.<span class="title function_">notice</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set、delete</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(obj,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;newbar&#x27;</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">delete</span>(obj),<span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>Proxy</code> 不兼容IE，也没有 <code>polyfill</code>, <code>defineProperty</code> 能支持到IE9</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proxy API 替代 defineProperty API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3.0性能提升主要是通过哪几方面体现的？</title>
      <link href="/2023/04/17/vue3-performance/"/>
      <url>/2023/04/17/vue3-performance/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-0性能提升主要是通过哪几方面体现的？"><a href="#Vue3-0性能提升主要是通过哪几方面体现的？" class="headerlink" title="Vue3.0性能提升主要是通过哪几方面体现的？"></a>Vue3.0性能提升主要是通过哪几方面体现的？</h1><p> <img src="https://static.vue-js.com/2aac1020-5ed0-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、编译阶段"><a href="#一、编译阶段" class="headerlink" title="一、编译阶段"></a>一、编译阶段</h2><p>回顾<code>Vue2</code>，我们知道每个组件实例都对应一个 <code>watcher</code> 实例，它会在组件渲染的过程中把用到的数据<code>property</code>记录为依赖，当依赖发生改变，触发<code>setter</code>，则会通知<code>watcher</code>，从而使关联的组件重新渲染</p><p> <img src="https://static.vue-js.com/39066120-5ed0-11eb-85f6-6fac77c0c9b3.png"></p><span id="more"></span><p>试想一下，一个组件结构如下图</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 <code>diff</code> 和遍历其实都是不需要的，造成性能浪费</p><p>因此，<code>Vue3</code>在编译阶段，做了进一步优化。主要有如下：</p><ul><li>diff算法优化</li><li>静态提升</li><li>事件监听缓存</li><li>SSR优化</li></ul><h4 id="diff算法优化"><a href="#diff算法优化" class="headerlink" title="diff算法优化"></a>diff算法优化</h4><p><code>vue3</code>在<code>diff</code>算法中相比<code>vue2</code>增加了静态标记</p><p>关于这个静态标记，其作用是为了会发生变化的地方添加一个<code>flag</code>标记，下次发生变化的时候直接找该地方进行比较</p><p>下图这里，已经标记静态节点的<code>p</code>标签在<code>diff</code>过程中则不会比较，把性能进一步提高</p><p> <img src="https://static.vue-js.com/c732e150-5c58-11eb-ab90-d9ae814b240d.png"></p><p>关于静态类型枚举如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> enum <span class="title class_">PatchFlags</span> &#123;</span><br><span class="line">  <span class="variable constant_">TEXT</span> = <span class="number">1</span>,<span class="comment">// 动态的文本节点</span></span><br><span class="line">  <span class="variable constant_">CLASS</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,  <span class="comment">// 2 动态的 class</span></span><br><span class="line">  <span class="variable constant_">STYLE</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,  <span class="comment">// 4 动态的 style</span></span><br><span class="line">  <span class="variable constant_">PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,  <span class="comment">// 8 动态属性，不包括类名和样式</span></span><br><span class="line">  <span class="variable constant_">FULL_PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,  <span class="comment">// 16 动态 key，当 key 变化时需要完整的 diff 算法做比较</span></span><br><span class="line">  <span class="variable constant_">HYDRATE_EVENTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,  <span class="comment">// 32 表示带有事件监听器的节点</span></span><br><span class="line">  <span class="variable constant_">STABLE_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,   <span class="comment">// 64 一个不会改变子节点顺序的 Fragment</span></span><br><span class="line">  <span class="variable constant_">KEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">// 128 带有 key 属性的 Fragment</span></span><br><span class="line">  <span class="variable constant_">UNKEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">// 256 子节点没有 key 的 Fragment</span></span><br><span class="line">  <span class="variable constant_">NEED_PATCH</span> = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">// 512</span></span><br><span class="line">  <span class="variable constant_">DYNAMIC_SLOTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,  <span class="comment">// 动态 solt</span></span><br><span class="line">  <span class="variable constant_">HOISTED</span> = -<span class="number">1</span>,  <span class="comment">// 特殊标志是负整数表示永远不会用作 diff</span></span><br><span class="line">  <span class="variable constant_">BAIL</span> = -<span class="number">2</span> <span class="comment">// 一个特殊的标志，指代差异算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态提升"><a href="#静态提升" class="headerlink" title="静态提升"></a>静态提升</h4><p><code>Vue3</code>中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用</p><p>这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;你好&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>没有做静态提升之前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;你好&quot;</span>),</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">message</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做了静态提升之后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createVNode</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;你好&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    _hoisted_1,</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">message</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></table></figure><p>静态内容<code>_hoisted_1</code>被放置在<code>render</code> 函数外，每次渲染的时候只要取 <code>_hoisted_1</code> 即可</p><p>同时 <code>_hoisted_1</code> 被打上了 <code>PatchFlag</code> ，静态标记值为 -1 ，特殊标志是负整数表示永远不会用于 Diff</p><h4 id="事件监听缓存"><a href="#事件监听缓存" class="headerlink" title="事件监听缓存"></a>事件监听缓存</h4><p>默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;button @click = &#x27;onClick&#x27;&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>没开启事件监听器缓存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> render = <span class="comment">/*#__PURE__*/</span><span class="title function_">_withId</span>(<span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;button&quot;</span>, &#123; <span class="attr">onClick</span>: _ctx.<span class="property">onClick</span> &#125;, <span class="string">&quot;点我&quot;</span>, <span class="number">8</span> <span class="comment">/* PROPS */</span>, [<span class="string">&quot;onClick&quot;</span>])</span><br><span class="line">                                             <span class="comment">// PROPS=1&lt;&lt;3,// 8 //动态属性，但不包含类名和样式</span></span><br><span class="line">  ]))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>开启事件侦听器缓存后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">onClick</span>: _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span> (_ctx.<span class="title function_">onClick</span>(...args)))</span><br><span class="line">    &#125;, <span class="string">&quot;点我&quot;</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述发现开启了缓存后，没有了静态标记。也就是说下次<code>diff</code>算法的时候直接使用</p><h4 id="SSR优化"><a href="#SSR优化" class="headerlink" title="SSR优化"></a>SSR优化</h4><p>当静态内容大到一定量级时候，会用<code>createStaticVNode</code>方法在客户端去生成一个static node，这些静态<code>node</code>，会被直接<code>innerHtml</code>，就不需要创建对象，然后根据对象渲染</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">...  <span class="comment">// 很多个静态属性</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mergeProps <span class="keyword">as</span> _mergeProps &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ssrRenderAttrs <span class="keyword">as</span> _ssrRenderAttrs, ssrInterpolate <span class="keyword">as</span> _ssrInterpolate &#125; <span class="keyword">from</span> <span class="string">&quot;@vue/server-renderer&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ssrRender</span>(<span class="params">_ctx, _push, _parent, _attrs, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> _cssVars = &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: _ctx.<span class="property">color</span> &#125;&#125;</span><br><span class="line">  <span class="title function_">_push</span>(<span class="string">`&lt;div<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    _ssrRenderAttrs(_mergeProps(_attrs, _cssVars))</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span>&gt;&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;...&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&lt;span&gt;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    _ssrInterpolate(_ctx.message)</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span>&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、源码体积"><a href="#二、源码体积" class="headerlink" title="二、源码体积"></a>二、源码体积</h2><p>相比<code>Vue2</code>，<code>Vue3</code>整体体积变小了，除了移出一些不常用的API，再重要的是<code>Tree shanking</code></p><p>任何一个函数，如<code>ref</code>、<code>reavtived</code>、<code>computed</code>等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed, defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> readOnlyAge = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> age.<span class="property">value</span>++) <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            age,</span><br><span class="line">            state,</span><br><span class="line">            readOnlyAge</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="三、响应式系统"><a href="#三、响应式系统" class="headerlink" title="三、响应式系统"></a>三、响应式系统</h2><p><code>vue2</code>中采用 <code>defineProperty</code>来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加<code>getter</code>和<code>setter</code>，实现响应式</p><p><code>vue3</code>采用<code>proxy</code>重写了响应式系统，因为<code>proxy</code>可以对整个对象进行监听，所以不需要深度遍历</p><ul><li>可以监听动态属性的添加</li><li>可以监听到数组的索引和数组<code>length</code>属性</li><li>可以监听删除属性</li></ul><p>关于这两个 API 具体的不同，我们下篇文章会进行一个更加详细的介绍</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6903171037211557895">https://juejin.cn/post/6903171037211557895</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3.0性能提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？</title>
      <link href="/2023/04/08/vue3-modal_component/"/>
      <url>/2023/04/08/vue3-modal_component/</url>
      
        <content type="html"><![CDATA[<h1 id="用Vue3-0-写过组件吗？如果想实现一个-Modal你会怎么设计？"><a href="#用Vue3-0-写过组件吗？如果想实现一个-Modal你会怎么设计？" class="headerlink" title="用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？"></a>用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？</h1><p> <img src="https://static.vue-js.com/e294c660-6370-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、组件设计"><a href="#一、组件设计" class="headerlink" title="一、组件设计"></a>一、组件设计</h2><p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式</p><p>现在有一个场景，点击新增与编辑都弹框出来进行填写，功能上大同小异，可能只是标题内容或者是显示的主体内容稍微不同</p><p>这时候就没必要写两个组件，只需要根据传入的参数不同，组件显示不同内容即可</p><p>这样，下次开发相同界面程序时就可以写更少的代码，意义着更高的开发效率，更少的 <code>Bug </code>和更少的程序体积</p><span id="more"></span><h2 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h2><p>实现一个<code>Modal</code>组件，首先确定需要完成的内容：</p><ul><li><p>遮罩层</p></li><li><p>标题内容</p></li><li><p>主体内容</p></li><li><p>确定和取消按钮</p></li></ul><p>主体内容需要灵活，所以可以是字符串，也可以是一段 <code>html</code> 代码</p><p>特点是它们在当前<code>vue</code>实例之外独立存在，通常挂载于<code>body</code>之上</p><p>除了通过引入<code>import</code>的形式，我们还可通过<code>API</code>的形式进行组件的调用</p><p>还可以包括配置全局样式、国际化、与<code>typeScript</code>结合</p><h2 id="三、实现流程"><a href="#三、实现流程" class="headerlink" title="三、实现流程"></a>三、实现流程</h2><p>首先看看大致流程：</p><ul><li><p>目录结构</p></li><li><p>组件内容</p></li><li><p>实现 API 形式</p></li><li><p>事件处理</p></li><li><p>其他完善</p></li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><code>Modal</code>组件相关的目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── plugins</span><br><span class="line">│   └── modal</span><br><span class="line">│       ├── Content.tsx // 维护 Modal 的内容，用于 h 函数和 jsx 语法</span><br><span class="line">│       ├── Modal.vue // 基础组件</span><br><span class="line">│       ├── config.ts // 全局默认配置</span><br><span class="line">│       ├── index.ts // 入口</span><br><span class="line">│       ├── locale // 国际化相关</span><br><span class="line">│       │   ├── index.ts</span><br><span class="line">│       │   └── lang</span><br><span class="line">│       │       ├── en-US.ts</span><br><span class="line">│       │       ├── zh-CN.ts</span><br><span class="line">│       │       └── zh-TW.ts</span><br><span class="line">│       └── modal.type.ts // ts类型声明相关</span><br></pre></td></tr></table></figure><p>因为 Modal 会被 <code>app.use(Modal)</code> 调用作为一个插件，所以都放在<code>plugins</code>目录下</p><h3 id="组件内容"><a href="#组件内容" class="headerlink" title="组件内容"></a>组件内容</h3><p>首先实现<code>modal.vue</code>的主体显示内容大致如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Teleport</span> <span class="attr">to</span>=<span class="string">&quot;body&quot;</span> <span class="attr">:disabled</span>=<span class="string">&quot;!isTeleport&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;modelValue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;modal&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">             <span class="attr">class</span>=<span class="string">&quot;mask&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">:style</span>=<span class="string">&quot;style&quot;</span></span></span><br><span class="line"><span class="tag">             @<span class="attr">click</span>=<span class="string">&quot;maskClose &amp;&amp; !loading &amp;&amp; handleCancel()&quot;</span></span></span><br><span class="line"><span class="tag">             &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal__main&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal__title line line--b&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; title || t(&quot;r.title&quot;) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">v-if</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">:title</span>=<span class="string">&quot;t(&#x27;r.close&#x27;)&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">class</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">                      @<span class="attr">click</span>=<span class="string">&quot;!loading &amp;&amp; handleCancel()&quot;</span></span></span><br><span class="line"><span class="tag">                      &gt;</span>✕&lt;/span</span><br><span class="line">                    &gt;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal__content&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Content</span> <span class="attr">v-if</span>=<span class="string">&quot;typeof content === &#x27;function&#x27;&quot;</span> <span class="attr">:render</span>=<span class="string">&quot;content&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">                    &#123;&#123; content &#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal__btns line line--t&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">:disabled</span>=<span class="string">&quot;loading&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleConfirm&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;loading&quot;</span>&gt;</span> ❍ <span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#123; t(&quot;r.confirm&quot;) &#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;!loading &amp;&amp; handleCancel()&quot;</span>&gt;</span></span><br><span class="line">                    &#123;&#123; t(&quot;r.cancel&quot;) &#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最外层上通过Vue3 <code>Teleport</code> 内置组件进行包裹，其相当于传送门，将里面的内容传送至<code>body</code>之上</p><p>并且从<code>DOM</code>结构上来看，把<code>modal</code>该有的内容（遮罩层、标题、内容、底部按钮）都实现了</p><p>关于主体内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal__content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Content</span> <span class="attr">v-if</span>=<span class="string">&quot;typeof content===&#x27;function&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">:render</span>=<span class="string">&quot;content&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">        &#123;&#123;content&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到根据传入<code>content</code>的类型不同，对应显示不同得到内容</p><p>最常见的则是通过调用字符串和默认插槽的形式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 默认插槽</span><br><span class="line"><span class="tag">&lt;<span class="name">Modal</span> <span class="attr">v-model</span>=<span class="string">&quot;show&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">title</span>=<span class="string">&quot;演示 slot&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world~<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Modal</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 字符串</span><br><span class="line"><span class="tag">&lt;<span class="name">Modal</span> <span class="attr">v-model</span>=<span class="string">&quot;show&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">title</span>=<span class="string">&quot;演示 content&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">content</span>=<span class="string">&quot;hello world~&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>通过 API 形式调用<code>Modal</code>组件的时候，<code>content</code>可以使用下面两种</p><ul><li>h 函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$modal.<span class="title function_">show</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;演示 h 函数&#x27;</span>,</span><br><span class="line">  <span class="title function_">content</span>(<span class="params">h</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(</span><br><span class="line">      <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;color:red;&#x27;</span>,</span><br><span class="line">        <span class="attr">onClick</span>: <span class="function">(<span class="params">$event: Event</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;clicked&#x27;</span>, $event.<span class="property">target</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;hello world ~&#x27;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>JSX</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$modal.<span class="title function_">show</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;演示 jsx 语法&#x27;</span>,</span><br><span class="line">  <span class="title function_">content</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;($event:</span> <span class="attr">Event</span>) =&gt;</span> console.log(&#x27;clicked&#x27;, $event.target)&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        hello world ~</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="实现-API-形式"><a href="#实现-API-形式" class="headerlink" title="实现 API 形式"></a>实现 API 形式</h3><p>那么组件如何实现<code>API</code>形式调用<code>Modal</code>组件呢？</p><p>在<code>Vue2</code>中，我们可以借助<code>Vue</code>实例以及<code>Vue.extend</code>的方式获得组件实例，然后挂载到<code>body</code>上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Modal</span> <span class="keyword">from</span> <span class="string">&#x27;./Modal.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ComponentClass</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(<span class="title class_">Modal</span>);</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">ComponentClass</span>(&#123; <span class="attr">el</span>: <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>) &#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(instance.<span class="property">$el</span>);</span><br></pre></td></tr></table></figure><p>虽然<code>Vue3</code>移除了<code>Vue.extend</code>方法，但可以通过<code>createVNode</code>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Modal</span> <span class="keyword">from</span> <span class="string">&#x27;./Modal.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">createVNode</span>(<span class="title class_">Modal</span>);</span><br><span class="line"><span class="title function_">render</span>(vnode, container);</span><br><span class="line"><span class="keyword">const</span> instance = vnode.<span class="property">component</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(container);</span><br></pre></td></tr></table></figure><p>在<code>Vue2</code>中，可以通过<code>this</code>的形式调用全局 API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">install</span>(<span class="params">vue</span>) &#123;</span><br><span class="line">       vue.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$create</span> = create</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 Vue3 的 <code>setup</code> 中已经没有 <code>this </code>概念了，需要调用<code>app.config.globalProperties</code>挂载到全局</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">install</span>(<span class="params">app</span>) &#123;</span><br><span class="line">        app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$create</span> = create</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>下面再看看看<code>Modal</code>组件内部是如何处理「确定」「取消」事件的，既然是<code>Vue3</code>，当然采用<code>Compositon API</code> 形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modal.vue</span></span><br><span class="line"><span class="title function_">setup</span>(<span class="params">props, ctx</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="title function_">getCurrentInstance</span>(); <span class="comment">// 获得当前组件实例</span></span><br><span class="line">  <span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    instance.<span class="property">_hub</span> = &#123;</span><br><span class="line">      <span class="string">&#x27;on-cancel&#x27;</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">      <span class="string">&#x27;on-confirm&#x27;</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleConfirm</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    ctx.<span class="title function_">emit</span>(<span class="string">&#x27;on-confirm&#x27;</span>);</span><br><span class="line">    instance.<span class="property">_hub</span>[<span class="string">&#x27;on-confirm&#x27;</span>]();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleCancel</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    ctx.<span class="title function_">emit</span>(<span class="string">&#x27;on-cancel&#x27;</span>);</span><br><span class="line">    ctx.<span class="title function_">emit</span>(<span class="string">&#x27;update:modelValue&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">    instance.<span class="property">_hub</span>[<span class="string">&#x27;on-cancel&#x27;</span>]();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    handleConfirm,</span><br><span class="line">    handleCancel</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，可以看得到除了使用传统<code>emit</code>的形式使父组件监听，还可通过<code>_hub</code>属性中添加 <code>on-cancel</code>，<code>on-confirm</code>方法实现在<code>API</code>中进行监听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$modal</span> = &#123;</span><br><span class="line">   <span class="title function_">show</span>(<span class="params">&#123;&#125;</span>) &#123;</span><br><span class="line">     <span class="comment">/* 监听 确定、取消 事件 */</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再来目睹下<code>_hub</code>是如何实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line">app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$modal</span> = &#123;</span><br><span class="line">    <span class="title function_">show</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">        /* 其他选项 */</span></span><br><span class="line"><span class="params">        onConfirm,</span></span><br><span class="line"><span class="params">        onCancel</span></span><br><span class="line"><span class="params">    &#125;</span>) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; props, _hub &#125; = instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">_closeModal</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">            props.<span class="property">modelValue</span> = <span class="literal">false</span>;</span><br><span class="line">            container.<span class="property">parentNode</span>!.<span class="title function_">removeChild</span>(container);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 往 _hub 新增事件的具体实现</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(_hub, &#123;</span><br><span class="line">            <span class="keyword">async</span> <span class="string">&#x27;on-confirm&#x27;</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (onConfirm) &#123;</span><br><span class="line">                <span class="keyword">const</span> fn = <span class="title function_">onConfirm</span>();</span><br><span class="line">                <span class="comment">// 当方法返回为 Promise</span></span><br><span class="line">                <span class="keyword">if</span> (fn &amp;&amp; fn.<span class="property">then</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        props.<span class="property">loading</span> = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">await</span> fn;</span><br><span class="line">                        props.<span class="property">loading</span> = <span class="literal">false</span>;</span><br><span class="line">                        <span class="title function_">_closeModal</span>();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                        <span class="comment">// 发生错误时，不关闭弹框</span></span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">                        props.<span class="property">loading</span> = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">_closeModal</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">_closeModal</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">            <span class="string">&#x27;on-cancel&#x27;</span>() &#123;</span><br><span class="line">                onCancel &amp;&amp; <span class="title function_">onCancel</span>();</span><br><span class="line">                <span class="title function_">_closeModal</span>();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="其他完善"><a href="#其他完善" class="headerlink" title="其他完善"></a>其他完善</h3><p>关于组件实现国际化、与<code>typsScript</code>结合，大家可以根据自身情况在此基础上进行更改</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000038928664">https://segmentfault.com/a/1190000038928664</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3.0 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3.0的设计目标是什么？做了哪些优化</title>
      <link href="/2023/04/03/vue3-goal/"/>
      <url>/2023/04/03/vue3-goal/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-0的设计目标是什么？做了哪些优化"><a href="#Vue3-0的设计目标是什么？做了哪些优化" class="headerlink" title="Vue3.0的设计目标是什么？做了哪些优化"></a>Vue3.0的设计目标是什么？做了哪些优化</h1><p><img src="https://static.vue-js.com/b93b49c0-5c58-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、设计目标"><a href="#一、设计目标" class="headerlink" title="一、设计目标"></a>一、设计目标</h2><p>不以解决实际业务痛点的更新都是耍流氓，下面我们来列举一下<code>Vue3</code>之前我们或许会面临的问题</p><ul><li><p>随着功能的增长，复杂组件的代码变得越来越难以维护</p></li><li><p>缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制</p></li><li><p>类型推断不够友好</p></li><li><p><code>bundle</code>的时间太久了</p></li></ul><p>而 <code>Vue3</code> 经过长达两三年时间的筹备，做了哪些事情？</p><p>我们从结果反推</p><ul><li>更小</li><li>更快</li><li>TypeScript支持</li><li>API设计一致性</li><li>提高自身可维护性</li><li>开放更多底层功能</li></ul><p>一句话概述，就是更小更快更友好了</p><h3 id="更小"><a href="#更小" class="headerlink" title="更小"></a>更小</h3><p><code>Vue3</code>移除一些不常用的 <code>API</code></p><p>引入<code>tree-shaking</code>，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了</p><h3 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h3><p>主要体现在编译方面：</p><ul><li>diff算法优化</li><li>静态提升</li><li>事件监听缓存</li><li>SSR优化</li></ul><p>下篇文章我们会进一步介绍</p><h3 id="更友好"><a href="#更友好" class="headerlink" title="更友好"></a>更友好</h3><p><code>vue3</code>在兼顾<code>vue2</code>的<code>options API</code>的同时还推出了<code>composition API</code>，大大增加了代码的逻辑组织和代码复用能力</p><p>这里代码简单演示下：</p><p>存在一个获取鼠标位置的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = e=&gt;&#123;</span><br><span class="line">        state.<span class="property">x</span> = e.<span class="property">pageX</span>;</span><br><span class="line">        state.<span class="property">y</span> = e.<span class="property">pageY</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要调用这个函数，即可获取<code>x</code>、<code>y</code>的坐标，完全不用关注实现过程</p><p>试想一下，如果很多类似的第三方库，我们只需要调用即可，不必关注实现过程，开发效率大大提高</p><p>同时，<code>VUE3</code>是基于<code>typescipt</code>编写的，可以享受到自动的类型定义提示</p><h2 id="三、优化方案"><a href="#三、优化方案" class="headerlink" title="三、优化方案"></a>三、优化方案</h2><p><code>vue3</code>从很多层面都做了优化，可以分成三个方面：</p><ul><li>源码</li><li>性能</li><li>语法 API</li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>源码可以从两个层面展开：</p><ul><li>源码管理</li><li>TypeScript</li></ul><h4 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h4><p><code>vue3</code>整个源码是通过 <code>monorepo </code>的方式维护的，根据功能将不同的模块拆分到<code>packages </code>目录下面不同的子目录中</p><p> <img src="https://static.vue-js.com/d7c32520-5c58-11eb-ab90-d9ae814b240d.png"></p><p>这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性</p><p>另外一些 <code>package</code>（比如 <code>reactivity</code> 响应式库）是可以独立于 <code>Vue</code> 使用的，这样用户如果只想使用 <code>Vue3 </code>的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 <code>Vue</code></p><h4 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h4><p><code>Vue3</code>是基于<code>typeScript</code>编写的，提供了更好的类型检查，能支持复杂的类型推导</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><code>vue3</code>是从什么哪些方面对性能进行进一步优化呢？</p><ul><li>体积优化</li><li>编译优化</li><li>数据劫持优化</li></ul><p>这里讲述数据劫持：</p><p>在<code>vue2</code>中，数据劫持是通过<code>Object.defineProperty </code>，这个 API 有一些缺陷，并不能检测对象属性的添加和删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>尽管<code> Vue</code>为了解决这个问题提供了 <code>set </code>和<code>delete </code>实例方法，但是对于用户来说，还是增加了一定的心智负担</p><p>同时在面对嵌套层级比较深的情况下，就存在性能问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">      <span class="attr">b</span>: &#123;</span><br><span class="line">          <span class="attr">c</span>: &#123;</span><br><span class="line">          <span class="attr">d</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之下，<code>vue3</code>是通过<code>proxy</code>监听整个对象，那么对于删除还是监听当然也能监听到</p><p>同时<code>Proxy </code> 并不能监听到内部深层次的对象变化，而 <code>Vue3</code> 的处理方式是在<code> getter</code> 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归</p><h3 id="语法-API"><a href="#语法-API" class="headerlink" title="语法 API"></a>语法 API</h3><p>这里当然说的就是<code>composition API</code>，其两大显著的优化：</p><ul><li>优化逻辑组织</li><li>优化逻辑复用</li></ul><h4 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h4><p>一张图，我们可以很直观地感受到 <code>Composition API </code>在逻辑组织方面的优势</p><p> <img src="https://static.vue-js.com/e5804bc0-5c58-11eb-85f6-6fac77c0c9b3.png"></p><p>相同功能的代码编写在一块，而不像<code>options API</code>那样，各个功能的代码混成一块</p><h4 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h4><p>在<code>vue2</code>中，我们是通过<code>mixin</code>实现功能混合，如果多个<code>mixin</code>混合，会存在两个非常明显的问题：命名冲突和数据来源不清晰</p><p>而通过<code>composition</code>这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可</p><p>同样是上文的获取鼠标位置的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs, reactive, onUnmounted, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = e=&gt;&#123;</span><br><span class="line">        state.<span class="property">x</span> = e.<span class="property">pageX</span>;</span><br><span class="line">        state.<span class="property">y</span> = e.<span class="property">pageY</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useMousePosition <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMousePosition</span>()</span><br><span class="line">        <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，整个数据来源清晰了，即使去编写更多的<code>hook</code>函数，也不会出现命名冲突的问题</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6850418112878575629#heading-5">https://juejin.cn/post/6850418112878575629#heading-5</a></li><li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3.0的设计目标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？？</title>
      <link href="/2023/04/01/vue3-composition/"/>
      <url>/2023/04/01/vue3-composition/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h1><p> <img src="https://static.vue-js.com/8d6dd7b0-6048-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p><code>Composition API</code> 可以说是<code>Vue3</code>的最大特点，那么为什么要推出<code>Composition Api</code>，解决了什么问题？</p><p>通常使用<code>Vue2</code>开发的项目，普遍会存在以下问题：</p><ul><li>代码的可读性随着组件变大而变差</li><li>每一种代码复用的方式，都存在缺点</li><li>TypeScript支持有限</li></ul><p>以上通过使用<code>Composition Api</code>都能迎刃而解</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一、Options-Api"><a href="#一、Options-Api" class="headerlink" title="一、Options Api"></a>一、Options Api</h3><p><code>Options API</code>，即大家常说的选项API，即以<code>vue</code>为后缀的文件，通过定义<code>methods</code>，<code>computed</code>，<code>watch</code>，<code>data</code>等属性与方法，共同处理页面逻辑</p><p>如下图：</p><p> <img src="https://static.vue-js.com/9bf6d9d0-6048-11eb-85f6-6fac77c0c9b3.png"></p><p>可以看到<code>Options</code>代码编写方式，如果是组件状态，则写在<code>data</code>属性上，如果是方法，则写在<code>methods</code>属性上…</p><p>用组件的选项 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组织逻辑在大多数情况下都有效</p><p>然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解</p><h3 id="二、Composition-Api"><a href="#二、Composition-Api" class="headerlink" title="二、Composition Api"></a>二、Composition Api</h3><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p><p>即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API</p><p> <img src="https://static.vue-js.com/acee9200-6048-11eb-ab90-d9ae814b240d.png"></p><h3 id="三、对比"><a href="#三、对比" class="headerlink" title="三、对比"></a>三、对比</h3><p>下面对<code>Composition Api </code>与<code>Options Api</code>进行两大方面的比较</p><ul><li>逻辑组织</li><li>逻辑复用</li></ul><h4 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h4><h5 id="Options-API"><a href="#Options-API" class="headerlink" title="Options API"></a>Options API</h5><p>假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）</p><p> <img src="https://static.vue-js.com/dc83d070-6048-11eb-ab90-d9ae814b240d.png"></p><p>可以看到，这种碎片化使得理解和维护复杂组件变得困难</p><p>选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块</p><h5 id="Compostion-API"><a href="#Compostion-API" class="headerlink" title="Compostion API"></a>Compostion API</h5><p>而<code>Compositon API</code>正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去</p><p>下面举个简单例子，将处理<code>count</code>属性相关的代码放在同一个函数了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="title function_">ref</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleConut</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        count.<span class="property">value</span> = count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count,</span><br><span class="line">        double,</span><br><span class="line">        handleConut,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件上中使用<code>count</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count, double, handleConut &#125; = <span class="title function_">useCount</span>();</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count,</span><br><span class="line">            double,</span><br><span class="line">            handleConut</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再来一张图进行对比，可以很直观地感受到 <code>Composition API </code>在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可</p><p><img src="https://static.vue-js.com/e5804bc0-5c58-11eb-85f6-6fac77c0c9b3.png"></p><h4 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h4><p>在<code>Vue2</code>中，我们是用过<code>mixin</code>去复用相同的逻辑</p><p>下面举个例子，我们会另起一个<code>mixin.js</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MoveMixin</span> = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">handleKeyup</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">      <span class="comment">// 上下左右 x y</span></span><br><span class="line">      <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在组件中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> mousePositionMixin <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">mixins</span>: [mousePositionMixin]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mixins</span>: [mousePositionMixin, fooMixin, barMixin, otherMixin]</span><br></pre></td></tr></table></figure><p>会存在两个非常明显的问题：</p><ul><li>命名冲突</li><li>数据来源不清晰</li></ul><p>现在通过<code>Compositon API</code>这种方式改写上面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUnmounted, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useMove</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> position = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleKeyup</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">    <span class="comment">// 上下左右 x y</span></span><br><span class="line">    <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value--;</span></span><br><span class="line">        position.<span class="property">y</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value++;</span></span><br><span class="line">        position.<span class="property">y</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value--;</span></span><br><span class="line">        position.<span class="property">x</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value++;</span></span><br><span class="line">        position.<span class="property">x</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; position &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; useMove &#125; <span class="keyword">from</span> <span class="string">&quot;./useMove&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> &#123; position &#125; = <span class="title function_">useMove</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">toRefs</span>(position);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      x,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      y,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>在逻辑组织和逻辑复用方面，<code>Composition API</code>是优于<code>Options  API</code></li><li>因为<code>Composition API</code>几乎是函数，会有更好的类型推断。</li><li><code>Composition API </code>对 <code>tree-shaking</code> 友好，代码也更容易压缩</li><li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li><li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的</li></ul>]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Composition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对树的理解？相关的操作有哪些？</title>
      <link href="/2023/03/12/algorithm-tree/"/>
      <url>/2023/03/12/algorithm-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="对树的理解？相关的操作有哪些？"><a href="#对树的理解？相关的操作有哪些？" class="headerlink" title="对树的理解？相关的操作有哪些？"></a>对树的理解？相关的操作有哪些？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>在计算机领域，树形数据结构是一类重要的非线性数据结构，可以表示数据之间一对多的关系。以树与二叉树最为常用，直观看来，树是以分支关系定义的层次结构</p><p>二叉树满足以下两个条件：</p><ul><li>本身是有序树</li><li>树中包含的各个结点的不能超过 2，即只能是 0、1 或者 2</li></ul><p>如下图，左侧的为二叉树，而右侧的因为头结点的子结点超过2，因此不属于二叉树：</p><p> <img src="https://static.vue-js.com/66758800-1dfe-11ec-a752-75723a64e8f5.png"></p><p>同时，二叉树可以继续进行分类，分成了满二叉树和完成二叉树：</p><ul><li>满二叉树：如果二叉树中除了叶子结点，每个结点的度都为 2</li></ul><p> <img src="https://static.vue-js.com/759db050-1dfe-11ec-a752-75723a64e8f5.png"></p><ul><li>完成二叉树：如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布</li></ul><p> <img src="https://static.vue-js.com/84ae31f0-1dfe-11ec-8e64-91fdec0f05a1.png"></p><h2 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h2><p>关于二叉树的遍历，常见的有：</p><ul><li><p>前序遍历</p></li><li><p>中序遍历</p></li><li><p>后序遍历</p></li><li><p>层序遍历</p></li></ul><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>前序遍历的实现思想是：</p><ul><li>访问根节点</li><li>访问当前节点的左子树</li><li>若当前节点无左子树，则访问当前节点的右子</li></ul><p>根据遍历特性，递归版本用代码表示则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">preOrder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root)&#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root)</span><br><span class="line">  <span class="title function_">preOrder</span>(root.<span class="property">left</span>)</span><br><span class="line">  <span class="title function_">preOrder</span>(root.<span class="property">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用递归版本，可以借助栈先进后出的特性实现，先将根节点压入栈，再分别压入右节点和左节点，直到栈中没有元素，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">preOrder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root)&#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [root]</span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = stack.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>)</span><br><span class="line">    <span class="keyword">if</span> (n.<span class="property">right</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(n.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n.<span class="property">left</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(n.<span class="property">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>前序遍历的实现思想是：</p><ul><li>访问当前节点的左子树</li><li>访问根节点</li><li>访问当前节点的右子</li></ul><p>递归版本很好理解，用代码表示则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">inOrder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="title function_">inOrder</span>(root.<span class="property">left</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>)</span><br><span class="line">  <span class="title function_">inOrder</span>(root.<span class="property">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归版本也是借助栈先进后出的特性，可以一直首先一直压入节点的左元素，当左节点没有后，才开始进行出栈操作，压入右节点，然后有依次压入左节点，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">inOrder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [root]</span><br><span class="line">  <span class="keyword">let</span> p = root</span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span> || p)&#123;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(p)</span><br><span class="line">      p = p.<span class="property">left</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> n = stack.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>)</span><br><span class="line">    p = n.<span class="property">right</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>前序遍历的实现思想是：</p><ul><li>访问当前节点的左子树</li><li>访问当前节点的右子</li><li>访问根节点</li></ul><p>递归版本，用代码表示则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">postOrder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="title function_">postOrder</span>(root.<span class="property">left</span>)</span><br><span class="line">  <span class="title function_">postOrder</span>(root.<span class="property">right</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>后序遍历非递归版本实际根全序遍历是逆序关系，可以再多创建一个栈用来进行输出，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">preOrder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root)&#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [root]</span><br><span class="line">  <span class="keyword">const</span> outPut = []</span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = stack.<span class="title function_">pop</span>()</span><br><span class="line">    outPut.<span class="title function_">push</span>(n.<span class="property">val</span>)</span><br><span class="line">    <span class="keyword">if</span> (n.<span class="property">right</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(n.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n.<span class="property">left</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(n.<span class="property">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (outPut.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = outPut.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>按照二叉树中的层次从左到右依次遍历每层中的结点</p><p>借助队列先进先出的特性，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果</p><p>用代码表示则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">levelOrder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">    <span class="keyword">const</span> queue = [[root, <span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> n = queue.<span class="title function_">shift</span>()</span><br><span class="line">        <span class="keyword">const</span> [node, leval] = n</span><br><span class="line">        <span class="keyword">if</span> (!res[leval]) &#123;</span><br><span class="line">            res[leval] = [node.<span class="property">val</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[leval].<span class="title function_">push</span>(node.<span class="property">val</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">left</span>) &#123; queue.<span class="title function_">push</span>([node.<span class="property">left</span>, leval + <span class="number">1</span>]) &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">right</span>) &#123; queue.<span class="title function_">push</span>([node.<span class="property">right</span>, leval + <span class="number">1</span>]) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>树是一个非常重要的非线性结构，其中二叉树以二叉树最常见，二叉树的遍历方式可以分成前序遍历、中序遍历、后序遍历</p><p>同时，二叉树又分成了完成二叉树和满二叉树</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91">https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91</a></li><li><a href="http://data.biancheng.net/view/27.html">http://data.biancheng.net/view/27.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对算法中时间复杂度，空间复杂度的理解？如何计算？</title>
      <link href="/2023/03/09/algorithm-timeSpace/"/>
      <url>/2023/03/09/algorithm-timeSpace/</url>
      
        <content type="html"><![CDATA[<h1 id="对算法中时间复杂度，空间复杂度的理解？如何计算？"><a href="#对算法中时间复杂度，空间复杂度的理解？如何计算？" class="headerlink" title="对算法中时间复杂度，空间复杂度的理解？如何计算？"></a>对算法中时间复杂度，空间复杂度的理解？如何计算？</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别</p><p>衡量不同算法之间的优劣主要是通过<strong>时间</strong>和<strong>空间</strong>两个维度去考量：</p><ul><li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li><li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述</li></ul><p>通常会遇到一种情况，时间和空间维度不能够兼顾，需要在两者之间取得一个平衡点是我们需要考虑的</p><p>一个算法通常存在最好、平均、最坏三种情况，我们一般关注的是最坏情况</p><p>最坏情况是算法运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，也意味着平均情况和最坏情况一样差</p><h2 id="二、时间复杂度"><a href="#二、时间复杂度" class="headerlink" title="二、时间复杂度"></a>二、时间复杂度</h2><p>时间复杂度是指执行这个算法所需要的计算工作量，其复杂度反映了程序执行时间「随输入规模增长而增长的量级」，在很大程度上能很好地反映出算法的优劣与否</p><p>一个算法花费的时间与算法中语句的「执行次数成正比」，执行次数越多，花费的时间就越多</p><p>算法的复杂度通常用大O符号表述，定义为<code>T(n) = O(f(n))</code>，常见的时间复杂度有：O(1)常数型、O(log n)对数型、O(n)线性型、O(nlogn)线性对数型、O(n^2)平方型、O(n^3)立方型、O(n^k)k次方型、O(2^n)指数型，如下图所示：</p><p> <img src="https://static.vue-js.com/33d5ebf0-16fc-11ec-8e64-91fdec0f05a1.png"></p><p>从上述可以看到，随着问题规模<code>n</code>的不断增大，上述时间复杂度不断增大，算法的执行效率越低，由小到大排序如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ο(<span class="number">1</span>)＜Ο(log n)＜Ο(n)＜Ο(nlog n)＜Ο(n2)＜Ο(n3)＜…＜Ο(<span class="number">2</span>^n)＜Ο(n!)</span><br></pre></td></tr></table></figure><p>注意的是，算法复杂度只是描述算法的增长趋势，并不能说一个算法一定比另外一个算法高效，如果常数项过大的时候也会导致算法的执行时间变长</p><p>关于如何计算时间复杂度，可以看看如下简单例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">process</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">  <span class="keyword">let</span> sum = a + b</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    sum += i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数算法需要执行的运算次数用输入大小<code>n</code>的函数表示，即 <code>T(n) = 2 + n  + 1</code>，那么时间复杂度为<code>O(n + 3)</code>，又因为时间复杂度只关注最高数量级，且与之系数也没有关系，因此上述的时间复杂度为<code>O(n)</code></p><p>又比如下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">process</span>(<span class="params">n</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      count += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环里面嵌套循环，外面的循环执行一次，里面的循环执行<code>n</code>次，因此时间复杂度为 <code>O(n*n*1 + 2) = O(n^2)</code></p><p>对于顺序执行的语句，总的时间复杂度等于其中最大的时间复杂度，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">process</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    sum += i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      sum += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述第一部分复杂度为<code>O(n)</code>，第二部分复杂度为<code>O(n^2)</code>，总复杂度为<code>max(O(n^2), O(n)) = O(n^2)</code></p><p>又如下一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">process</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>; <span class="comment">// ①</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">     i = i * <span class="number">2</span>; <span class="comment">// ②</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环语句中以2的倍数来逼近<code>n</code>，每次都乘以2。如果用公式表示就是1 *  2 * 2 * 2 … * 2 &lt;&#x3D;n，也就是说2的<code>x</code>次方小于等于<code>n</code>时会执行循环体，记作<code>2^x &lt;= n</code>，于是得出<code>x&lt;=logn</code></p><p>因此循环在执行<code>logn</code>次之后，便结束，因此时间复杂度为<code>O(logn)</code></p><p>同理，如果一个<code>O(n)</code>循环里面嵌套<code>O(logn)</code>的循环，则时间复杂度为<code>O(nlogn)</code>，像<code>O(n^3)</code>无非也就是嵌套了三层<code>O(n)</code>循环</p><h2 id="三、空间复杂度"><a href="#三、空间复杂度" class="headerlink" title="三、空间复杂度"></a>三、空间复杂度</h2><p>空间复杂度主要指执行算法所需内存的大小，用于对程序运行过程中所需要的临时存储空间的度量</p><p>除了需要存储空间、指令、常数、变量和输入数据外，还包括对数据进行操作的工作单元和存储计算所需信息的辅助空间</p><p>下面给出空间复杂度为<code>O(1)</code>的示例，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>上述代码的临时空间不会随着<code>n</code>的变化而变化，因此空间复杂度为<code>O(1)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr []</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">  arr.<span class="title function_">push</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述可以看到，随着<code>n</code>的增加，数组的占用的内存空间越大</p><p>通常来说，只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为<code>O(1)</code>，一个一维数组<code>a[n]</code>，空间复杂度<code>O(n)</code>，二维数组为<code>O(n^2)</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://juejin.cn/post/6844904167824162823#heading-7">https://juejin.cn/post/6844904167824162823#heading-7</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/50479555">https://zhuanlan.zhihu.com/p/50479555</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1769988">https://cloud.tencent.com/developer/article/1769988</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_timeSpace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对数据结构的理解？有哪些？区别？</title>
      <link href="/2023/03/06/algorithm-structure/"/>
      <url>/2023/03/06/algorithm-structure/</url>
      
        <content type="html"><![CDATA[<h1 id="对数据结构的理解？有哪些？区别？"><a href="#对数据结构的理解？有哪些？区别？" class="headerlink" title="对数据结构的理解？有哪些？区别？"></a>对数据结构的理解？有哪些？区别？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>数据结构是计算机存储、组织数据的方式，是指相互之间存在一种或多种特定关系的数据元素的集合</p><p>前面讲到，一个程序 &#x3D; 算法 + 数据结构，数据结构是实现算法的基础，选择合适的数据结构可以带来更高的运行或者存储效率</p><p>数据元素相互之间的关系称为结构，根据数据元素之间关系的不同特性，通常有如下四类基本的结构：</p><ul><li>集合结构：该结构的数据元素间的关系是“属于同一个集合”</li><li>线性结构：该结构的数据元素之间存在着一对一的关系</li><li>树型结构：该结构的数据元素之间存在着一对多的关系</li><li>图形结构：该结构的数据元素之间存在着多对多的关系，也称网状结构</li></ul><p>由于数据结构种类太多，逻辑结构可以再分成为：</p><ul><li>线性结构：有序数据元素的集合，其中数据元素之间的关系是一对一的关系，除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的</li><li>非线性结构：各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生关联</li></ul><p><img src="https://static.vue-js.com/9aedc5d0-1aa6-11ec-8e64-91fdec0f05a1.png"></p><h2 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h2><p>常见的数据结构有如下：</p><ul><li>数组</li><li>栈</li><li>队列</li><li>链表</li><li>树</li><li>图</li><li>堆</li><li>散列表</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在程序设计中，为了处理方便， 一般情况把具有相同类型的若干变量按有序的形式组织起来，这些按序排列的同类数据元素的集合称为数组</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>一种特殊的线性表，只能在某一端插入和删除的特殊线性表，按照先进后出的特性存储数据</p><p>先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>跟栈基本一致，也是一种特殊的线性表，其特性是先进先出，只允许在表的前端进行删除操作，而在表的后端进行插入操作</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的</p><p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成</p><p>一般情况，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树是典型的非线性结构，在树的结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个以上的后继结点</p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>一种非线性结构。在图结结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一种特殊的树形数据结构，每个结点都有一个值，特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆</p><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>若结构中存在关键字和<code>K</code>相等的记录，则必定在<code>f(K)</code>的存储位置上，不需比较便可直接取得所查记录</p><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>上述的数据结构，之前的区别可以分成线性结构和非线性结构：</p><ul><li>线性结构有：数组、栈、队列、链表等</li><li>非线性结构有：树、图、堆等</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84</a></li><li><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450">https://baike.baidu.com/item/数据结构/1450</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对栈、队列的理解？应用场景？</title>
      <link href="/2023/03/02/algorithm-stack-queue/"/>
      <url>/2023/03/02/algorithm-stack-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="对栈、队列的理解？应用场景？"><a href="#对栈、队列的理解？应用场景？" class="headerlink" title="对栈、队列的理解？应用场景？"></a>对栈、队列的理解？应用场景？</h1><h2 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h2><p>栈（stack）又名堆栈，它是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表</p><p>表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈</p><p>所以其按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用</p><p>关于栈的简单实现，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加一个（或几个）新元素到栈顶</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; element 新元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(element)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除栈顶的元素，同时返回被移除的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">pop</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果栈里没有任何元素就返回true,否则返回false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除栈里的所有元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回栈里的元素个数。这个方法和数组的length属性很类似</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于栈的操作主要的方法如下：</p><ul><li>push：入栈操作</li><li>pop：出栈操作</li></ul><h2 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h2><p>跟栈十分相似，队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</p><p>进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列</p><p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出</p><p>简单实现一个队列的方式，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span> = []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">frontIndex</span> = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tailIndex</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">enqueue</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">tailIndex</span>++] = item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">unqueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> item  = <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">frontIndex</span>]</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">frontIndex</span>++        </span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述这种入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用</p><p>当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作，出该现象称为”假溢”</p><p>在实际使用队列时，为了使队列空间能重复使用，往往对队列的使用方法稍加改进：</p><p>无论插入或删除，一旦<code>rear</code>指针增1或<code>front</code>指针增1 时超出了所分配的队列空间，就让它指向这片连续空间的起始位置，这种队列也就是循环队列</p><p>下面实现一个循环队列，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">size</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">size</span> = size; <span class="comment">// 长度需要限制, 来达到空间的利用, 代表空间的长度</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">font</span> = <span class="number">0</span>; <span class="comment">// 指向首元素</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rear</span> = <span class="number">0</span>;  <span class="comment">// 指向准备插入元素的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">enQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isFull</span>() == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rear</span> = <span class="variable language_">this</span>.<span class="property">rear</span> % <span class="variable language_">this</span>.<span class="property">k</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_data</span>[<span class="variable language_">this</span>.<span class="property">rear</span>++] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">deQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">font</span>++;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">font</span> = <span class="variable language_">this</span>.<span class="property">font</span> % <span class="variable language_">this</span>.<span class="property">k</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">font</span> == <span class="variable language_">this</span>.<span class="property">rear</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">isFull</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">rear</span> % <span class="variable language_">this</span>.<span class="property">k</span> == <span class="variable language_">this</span>.<span class="property">font</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述通过求余的形式代表首尾指针增1 时超出了所分配的队列空间</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>借助栈的先进后出的特性，可以简单实现一个逆序数处的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出</p><p>包括编译器的在对输入的语法进行分析的时候，例如<code>&quot;()&quot;</code>、<code>&quot;&#123;&#125;&quot;</code>、<code>&quot;[]&quot;</code>这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p><p>包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值</p><p>生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题</p><p>队列的使用广泛应用在广度优先搜索种，例如层次遍历一个二叉树的节点值（后续将到）</p><p>生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://baike.baidu.com/item/%E6%A0%88/12808149">https://baike.baidu.com/item/%E6%A0%88/12808149</a></li><li><a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481">https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_stack_queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的排序算法有哪些？区别？</title>
      <link href="/2023/02/28/algorithm-sort/"/>
      <url>/2023/02/28/algorithm-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的排序算法有哪些？区别？"><a href="#常见的排序算法有哪些？区别？" class="headerlink" title="常见的排序算法有哪些？区别？"></a>常见的排序算法有哪些？区别？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>排序是程序开发中非常常见的操作，对一组任意的数据元素经过排序操作后，就可以把他们变成一组一定规则排序的有序序列</p><p>排序算法属于算法中的一种，而且是覆盖范围极小的一种，彻底掌握排序算法对程序开发是有很大的帮助的</p><p>对与排序算法的好坏衡量，主要是从时间复杂度、空间复杂度、稳定性</p><p>时间复杂度、空间复杂度前面已经讲过，这里主要看看稳定性的定义</p><p>稳定性指的是假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变</p><p>即在原序列中，r[i] &#x3D; r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的</p><h2 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h2><p>常见的算法排序算法有：</p><ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>归并排序</li><li>快速排序</li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来</p><p>思路如下：</p><ul><li><p>比较相邻的元素，如果第一个比第二个大，就交换它们两个</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个</p></li><li><p>重复上述步骤，直到没有任何一堆数字需要比较</p></li></ul><p><img src="https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp"></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法</p><p>无论什么数据进去都是 <code>O(n²) </code>的时间复杂度。所以用到它的时候，数据规模越小越好</p><p>唯一的好处是不占用额外的内存存储空间</p><p>思路如下：</p><ul><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕</li></ul><p><img src="https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp"></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序是一种简单直观的排序算法</p><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p><p>解决思路如下：</p><ul><li>把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的</li><li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li><li>重复上述过程直到最后一个元素被插入有序子数组中</li></ul><p><img src="https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp"></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是建立在归并操作上的一种有效的排序算法</p><p>该算法是采用分治法的一个非常典型的应用</p><p>将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序</p><p>解决思路如下：</p><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ul><p><img src="https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.jpg"></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是对冒泡排序算法的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小</p><p>再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列</p><p>解决思路如下：</p><ul><li>从数列中挑出一个元素，称为”基准”（pivot）</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序</li></ul><p><img src="https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.jpg"></p><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>除了上述的排序算法之外，还存在其他的排序算法，例如希尔排序、堆排序等等……</p><p>区别如下图所示：</p><p><img src="https://static.vue-js.com/5c3d7b50-2131-11ec-a752-75723a64e8f5.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.runoob.com/w3cnote/bubble-sort.html">https://www.runoob.com/w3cnote/bubble-sort.html</a></li><li><a href="http://www.x-lab.info/post/sort-algorithm/">http://www.x-lab.info/post/sort-algorithm/</a></li><li><a href="https://zhuanlan.zhihu.com/p/42586566">https://zhuanlan.zhihu.com/p/42586566</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对集合的理解？常见的操作有哪些？</title>
      <link href="/2023/02/27/algorithm-set/"/>
      <url>/2023/02/27/algorithm-set/</url>
      
        <content type="html"><![CDATA[<h1 id="对集合的理解？常见的操作有哪些？"><a href="#对集合的理解？常见的操作有哪些？" class="headerlink" title="对集合的理解？常见的操作有哪些？"></a>对集合的理解？常见的操作有哪些？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>集合（Set），指具有某种特定性质的事物的总体，里面的每一项内容称作元素</p><p>在数学中，我们经常会遇到集合的概念：</p><ul><li>有限集合：例如一个班集所有的同学构成的集合</li><li>无限集合：例如全体自然数集合</li></ul><p>在计算机中集合道理也基本一致，具有三大特性：</p><ul><li>确定性：于一个给定的集合，集合中的元素是确定的。即一个元素，或者属于该集合，或者不属于该集合，两者必居其一</li><li>无序性：在一个集合中，不考虑元素之间的顺序，只要元素完全相同，就认为是同一个集合</li><li>互异性：集合中任意两个元素都是不同的</li></ul><h2 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h2><p>在<code>ES6</code>中，集合本身是一个构建函数<code>Set</code>，用来生成 <code>Set</code> 数据结构，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br></pre></td></tr></table></figure><p>关于集合常见的方法有：</p><ul><li>add()：增</li><li>delete()：删</li><li>has()：改</li><li>clear()：查</li></ul><h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><p>添加某个值，返回 <code>Set</code> 结构本身</p><p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">2</span>); <span class="comment">// 2只被添加了一次</span></span><br></pre></td></tr></table></figure><p>体现了集合的互异性特性</p><h3 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h3><p>删除某个值，返回一个布尔值，表示删除是否成功</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">delete</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p>返回一个布尔值，判断该值是否为<code>Set</code>的成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>清除所有成员，没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure><p>关于多个集合常见的操作有：</p><ul><li>并集</li><li>交集</li><li>差集</li></ul><h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><p>两个集合的共同元素，如下图所示：</p><p> <img src="https://static.vue-js.com/ed96df50-1d36-11ec-a752-75723a64e8f5.png"></p><p>代码实现方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><p>两个集合<code>A</code> 和 <code>B</code>，即属于<code>A</code>又属于<code>B</code>的元素，如下图所示：</p><p> <img src="https://static.vue-js.com/f8a9cd80-1d36-11ec-a752-75723a64e8f5.png"></p><p>用代码标识则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br></pre></td></tr></table></figure><h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><p>两个集合<code>A</code> 和 <code>B</code>，属于<code>A</code>的元素但不属于<code>B</code>的元素称为<code>A</code>相对于<code>B</code>的差集，如下图所示：</p><p> <img src="https://static.vue-js.com/0191c560-1d37-11ec-8e64-91fdec0f05a1.png"></p><p>代码标识则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>一般情况下，使用数组的概率会比集合概率高很多</p><p>使用<code>set</code>集合的场景一般是借助其确定性，其本身只包含不同的元素</p><p>所以，可以利用<code>Set</code>的一些原生方法轻松的完成数组去重，查找数组公共元素及不同元素等操作</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E9%9B%86">https://zh.wikipedia.org/wiki/%E5%B9%B6%E9%9B%86</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%A1%A5%E9%9B%86">https://zh.wikipedia.org/wiki/%E8%A1%A5%E9%9B%86</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对快速排序的理解？如何实现？应用场景？</title>
      <link href="/2023/02/23/algorithm-quickSort/"/>
      <url>/2023/02/23/algorithm-quickSort/</url>
      
        <content type="html"><![CDATA[<h1 id="对快速排序的理解？如何实现？应用场景？"><a href="#对快速排序的理解？如何实现？应用场景？" class="headerlink" title="对快速排序的理解？如何实现？应用场景？"></a>对快速排序的理解？如何实现？应用场景？</h1><p> <img src="https://static.vue-js.com/bafae570-268a-11ec-8e64-91fdec0f05a1.png"></p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>快速排序（Quick Sort）算法是在冒泡排序的基础上进行改进的一种算法，从名字上看就知道该排序算法的特点是快、效率高，是处理大数据最快的排序算法之一</p><p>实现的基本思想是：通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小</p><p>然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就变成有序序列</p><p>例如，对无序表49，38，65，97，76，13，27，49进行快速排序，大致过程为：</p><ul><li><p>首先从表中选取一个记录的关键字作为分割点（称为“枢轴”或者支点，一般选择第一个关键字），例如选取 49</p></li><li><p>将表格中大于 49 个放置于 49 的右侧，小于 49 的放置于 49 的左侧，假设完成后的无序表为：{27，38，13，49，65，97，76，49}</p></li><li><p>以 49 为支点，将整个无序表分割成了两个部分，分别为{27，38，13}和{65，97，76，49}，继续采用此种方法分别对两个子表进行排序</p></li><li><p>前部分子表以 27 为支点，排序后的子表为{13，27，38}，此部分已经有序；后部分子表以 65 为支点，排序后的子表为{49，65，97，76}</p></li><li><p>此时前半部分子表中的数据已完成排序；后部分子表继续以 65 为支点，将其分割为{49}和{97，76}，前者不需排序，后者排序后的结果为{76， 97}</p></li><li><p>通过以上几步的排序，最后由子表{13，27，38}、{49}、{49}、{65}、{76，97}构成有序表：{13，27，38，49，49，65，76，97}</p></li></ul><h2 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h2><p>可以分成以下步骤：</p><ul><li>分区：从数组中选择任意一个基准，所有比基准小的元素放在基准的左边，比基准大的元素放到基准的右边</li><li>递归：递归地对基准前后的子数组进行分区</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif"></p><p>用代码表示则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span> (arr) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">rec</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">    <span class="keyword">const</span> left = [];</span><br><span class="line">    <span class="keyword">const</span> right = [];</span><br><span class="line">    <span class="keyword">const</span> mid = arr[<span class="number">0</span>]; <span class="comment">// 基准元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; mid) &#123;</span><br><span class="line">        left.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="title function_">rec</span>(left), mid, ...<span class="title function_">rec</span>(right)]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">res</span>(arr)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>快速排序是冒泡排序的升级版，最坏情况下每一次基准元素都是数组中最小或者最大的元素，则快速排序就是冒泡排序</p><p>这种情况时间复杂度就是冒泡排序的时间复杂度：<code>T[n] = n * (n-1) = n^2 + n</code>，也就是<code>O(n^2)</code></p><p>最好情况下是<code>O(nlogn)</code>，其中递归算法的时间复杂度公式：<code>T[n] = aT[n/b] + f(n)</code>，推导如下所示：</p><p> <img src="https://static.vue-js.com/b6019540-2b5e-11ec-8e64-91fdec0f05a1.png"></p><p>关于上述代码实现的快速排序，可以看到是稳定的</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>快速排序时间复杂度为<code>O(nlogn)</code>，是目前基于比较的内部排序中被认为最好的方法，当数据过大且数据杂乱无章时，则适合采用快速排序</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842">https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842</a></li><li><a href="https://www.cnblogs.com/l199616j/p/10597245.html">https://www.cnblogs.com/l199616j/p/10597245.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_quickSort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对插入排序的理解？如何实现？应用场景？</title>
      <link href="/2023/02/19/algorithm-insertionSort/"/>
      <url>/2023/02/19/algorithm-insertionSort/</url>
      
        <content type="html"><![CDATA[<h1 id="对插入排序的理解？如何实现？应用场景？"><a href="#对插入排序的理解？如何实现？应用场景？" class="headerlink" title="对插入排序的理解？如何实现？应用场景？"></a>对插入排序的理解？如何实现？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>插入排序（Insertion Sort），一般也被称为直接插入排序。对于少量元素的排序，它是一个有效、简单的算法</p><p>其主要的实现思想是将数据按照一定的顺序一个一个的插入到有序的表中，最终得到的序列就是已经排序好的数据</p><p>插入排序的工作方式像许多人排序一手扑克牌，开始时，我们的左手为空并且桌子上的牌面向下</p><p>然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置，该正确位置需要从右到左将它与已在手中的每张牌进行比较</p><p>例如一个无序数组 3、1、7、5、2、4、9、6，将其升序的结果则如下：</p><p>一开始有序表中无数据，直接插入3</p><p>从第二个数开始，插入一个元素1，然后和有序表中记录3比较，1&lt;3，所以插入到记录 3 的左侧</p><p> <img src="https://static.vue-js.com/9d24f5f0-267f-11ec-a752-75723a64e8f5.png"></p><p>向有序表插入记录 7 时，同有序表中记录 3 进行比较，3&lt;7，所以插入到记录 3 的右侧</p><p> <img src="https://static.vue-js.com/a6a954e0-267f-11ec-8e64-91fdec0f05a1.png"></p><p>向有序表中插入记录 5 时，同有序表中记录 7 进行比较，5&lt;7，同时 5&gt;3，所以插入到 3 和 7 中间</p><p> <img src="https://static.vue-js.com/b1981940-267f-11ec-8e64-91fdec0f05a1.png"></p><p>照此规律，依次将无序表中的记录 4，9 和 6插入到有序表中</p><p> <img src="https://static.vue-js.com/bc2ed290-267f-11ec-a752-75723a64e8f5.png"></p><h2 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h2><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置</p><p>如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif"></p><p>用代码表示则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> preIndex, current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex+<span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较<code>N- 1</code>次，时间复杂度为<code>O(n)</code></p><p>最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为<code>O(n^2)</code></p><p>通过上面了解，可以看到插入排序是一种稳定的排序方式</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>插入排序时间复杂度是 O(n2)，适用于数据量不大，算法稳定性要求高，且数据局部或整体有序的数列排序</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992">https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992</a></li><li><a href="http://data.biancheng.net/view/65.html">http://data.biancheng.net/view/65.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_insertionSort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对选择排序的理解？如何实现？应用场景？</title>
      <link href="/2023/02/15/algorithm-selectionSort/"/>
      <url>/2023/02/15/algorithm-selectionSort/</url>
      
        <content type="html"><![CDATA[<h1 id="对选择排序的理解？如何实现？应用场景？"><a href="#对选择排序的理解？如何实现？应用场景？" class="headerlink" title="对选择排序的理解？如何实现？应用场景？"></a>对选择排序的理解？如何实现？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>选择排序（Selection sort）是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²) </code>的时间复杂度，所以用到它的时候，数据规模越小越好</p><p>其基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置</p><p>然后再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾</p><p>以此类推，直到所有元素均排序完毕</p><p>举个例子，一个数组为 56、12、80、91、29，其排序过程如下：</p><ul><li>第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置。此时数组为 12、56、80、91、20</li></ul><p> <img src="https://static.vue-js.com/60bd2050-2671-11ec-a752-75723a64e8f5.png"></p><ul><li>第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置，此时数组为12、20、80、91、56</li></ul><p> <img src="https://static.vue-js.com/6b04cf40-2671-11ec-8e64-91fdec0f05a1.png"></p><ul><li>第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置，此时数组为 12、20、56、91、80</li></ul><p> <img src="https://static.vue-js.com/757f4e00-2671-11ec-a752-75723a64e8f5.png"></p><ul><li>第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置，此时排序完成，变成有序数组</li></ul><p> <img src="https://static.vue-js.com/757f4e00-2671-11ec-a752-75723a64e8f5.png"></p><h2 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h2><p>从上面可以看到，对于具有 <code>n</code> 个记录的无序表遍历 <code>n-1</code> 次，第<code> i</code> 次从无序表中第 <code>i</code> 个记录开始，找出后序关键字中最小的记录，然后放置在第 <code>i</code> 的位置上</p><p>直至到从第<code>n</code>个和第<code>n-1</code>个元素中选出最小的放在第<code>n-1</code>个位置</p><p>如下动画所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif"></p><p>用代码表示则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">// 寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次内循环比较<code>N - 1</code>次，然后是<code>N-2</code>次，<code>N-3</code>次，……，最后一次内循环比较1次<br>共比较的次数是 <code>(N - 1) + (N - 2) + ... + 1</code>，求等差数列和，得 <code>(N - 1 + 1)* N / 2 = N^2 / 2</code>，舍去最高项系数，其时间复杂度为 <code>O(N^2)</code></p><p>从上述也可以看到，选择排序是一种稳定的排序</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>和冒泡排序一致，相比其它排序算法，这也是一个相对较高的时间复杂度，一般情况不推荐使用</p><p>但是我们还是要掌握冒泡排序的思想及实现，这对于我们的算法思维是有很大帮助的</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/9762418">https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/9762418</a></li><li><a href="https://zhuanlan.zhihu.com/p/29889599">https://zhuanlan.zhihu.com/p/29889599</a></li><li><a href="http://data.biancheng.net/view/72.html">http://data.biancheng.net/view/72.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_selectionSort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对归并排序的理解？如何实现？应用场景？</title>
      <link href="/2023/02/14/algorithm-mergeSort/"/>
      <url>/2023/02/14/algorithm-mergeSort/</url>
      
        <content type="html"><![CDATA[<h1 id="对归并排序的理解？如何实现？应用场景？"><a href="#对归并排序的理解？如何实现？应用场景？" class="headerlink" title="对归并排序的理解？如何实现？应用场景？"></a>对归并排序的理解？如何实现？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>归并排序（Merge Sort）是建立归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用</p><p>将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序</p><p>例如对于含有 <code>n</code> 个记录的无序表，首先默认表中每个记录各为一个有序表（只不过表的长度都为 1）</p><p>然后进行两两合并，使 <code>n</code> 个有序表变为<code>n/2</code>  个长度为 2 或者 1 的有序表（例如 4 个小有序表合并为 2 个大的有序表）</p><p>通过不断地进行两两合并，直到得到一个长度为 <code>n</code> 的有序表为止</p><p>例如对无序表{49，38，65，97，76，13，27}进行归并排序分成了分、合两部分：</p><p>如下图所示：</p><p> <img src="https://static.vue-js.com/05f14b60-26ad-11ec-a752-75723a64e8f5.png"></p><p>归并合过程中，每次得到的新的子表本身有序，所以最终得到有序表</p><p>上述分成两部分，则称为二路归并，如果分成三个部分则称为三路归并，以此类推</p><h2 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h2><p>关于归并排序的算法思路如下：</p><ul><li><p>分：把数组分成两半，再递归对子数组进行分操作，直至到一个个单独数字</p></li><li><p>合：把两个数合成有序数组，再对有序数组进行合并操作，直到全部子数组合成一个完整的数组</p><ul><li>合并操作可以新建一个数组，用于存放排序后的数组</li><li>比较两个有序数组的头部，较小者出队并且推入到上述新建的数组中</li><li>如果两个数组还有值，则重复上述第二步</li><li>如果只有一个数组有值，则将该数组的值出队并推入到上述新建的数组中</li></ul></li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif"></p><p>用代码表示则如下图所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>) &#123;  <span class="comment">// 采用自上而下的递归方法</span></span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="title class_">Math</span>.<span class="title function_">floor</span>(len / <span class="number">2</span>),</span><br><span class="line">        left = arr.<span class="title function_">slice</span>(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.<span class="title function_">slice</span>(middle);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.<span class="property">length</span> &amp;&amp; right.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(left.<span class="title function_">shift</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(right.<span class="title function_">shift</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.<span class="property">length</span>)</span><br><span class="line">        result.<span class="title function_">push</span>(left.<span class="title function_">shift</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right.<span class="property">length</span>)</span><br><span class="line">        result.<span class="title function_">push</span>(right.<span class="title function_">shift</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述归并分成了分、合两部分，在处理分过程中递归调用两个分的操作，所花费的时间为2乘<code>T(n/2)</code>，合的操作时间复杂度则为<code>O(n)</code>，因此可以得到以下公式：</p><p>总的执行时间 &#x3D; 2 × 输入长度为<code>n/2</code>的<code>sort</code>函数的执行时间 + <code>merge</code>函数的执行时间<code>O(n)</code></p><p>当只有一个元素时，<code>T(1) = O(1)</code></p><p>如果对<code>T(n) = 2 * T(n/2) + O(n) </code>进行左右 &#x2F; n的操作，得到 <code>T(n) / n = (n / 2) * T(n/2) + O(1)</code></p><p>现在令 <code>S(n) = T(n)/n</code>，则<code>S(1) = O(1)</code>，然后利用表达式带入得到<code>S(n) = S(n/2) + O(1)</code></p><p>所以可以得到：<code>S(n) = S(n/2) + O(1) = S(n/4) + O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) = S(1) + O(logn) = O(logn)</code></p><p>综上可得，<code>T(n) = n * log(n) = nlogn</code></p><p>关于归并排序的稳定性，在进行合并过程，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也不会交换，由此可见归并排序是稳定的排序算法</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>在外排序中通常使用排序-归并的策略，外排序是指处理超过内存限度的数据的排序算法，通常将中间结果放在读写较慢的外存储器，如下分成两个阶段：</p><ul><li>排序阶段：读入能够放进内存中的数据量，将其排序输出到临时文件，一次进行，将带排序数据组织为多个有序的临时文件</li><li>归并阶段：将这些临时文件组合为大的有序文件</li></ul><p>例如，使用100m内存对900m的数据进行排序，过程如下：</p><ul><li>读入100m数据内存，用常规方式排序</li><li>将排序后的数据写入磁盘</li><li>重复前两个步骤，得到9个100m的临时文件</li><li>将100m的内存划分为10份，将9份为输入缓冲区，第10份为输出缓冲区</li><li>进行九路归并排序，将结果输出到缓冲区<ul><li>若输出缓冲区满，将数据写到目标文件，清空缓冲区</li><li>若缓冲区空，读入相应文件的下一份数据</li></ul></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015">https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015</a></li><li><a href="https://chowdera.com/2021/09/20210920201630258d.html#_127">https://chowdera.com/2021/09/20210920201630258d.html#_127</a></li><li><a href="https://juejin.cn/post/6844904007899561998">https://juejin.cn/post/6844904007899561998</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_mergeSort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对堆的理解？如何实现？应用场景？</title>
      <link href="/2023/02/14/algorithm-heap/"/>
      <url>/2023/02/14/algorithm-heap/</url>
      
        <content type="html"><![CDATA[<h1 id="对堆的理解？如何实现？应用场景？"><a href="#对堆的理解？如何实现？应用场景？" class="headerlink" title="对堆的理解？如何实现？应用场景？"></a>对堆的理解？如何实现？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>堆(Heap)是计算机科学中一类特殊的数据结构的统称</p><p>堆通常是一个可以被看做一棵完全二叉树的数组对象，如下图：</p><p> <img src="https://static.vue-js.com/ea0fd1f0-1ed7-11ec-8e64-91fdec0f05a1.png"></p><p>总是满足下列性质：</p><ul><li>堆中某个结点的值总是不大于或不小于其父结点的值</li><li>堆总是一棵完全二叉树</li></ul><p>堆又可以分成最大堆和最小堆：</p><ul><li>最大堆：每个根结点，都有根结点的值大于两个孩子结点的值</li><li>最小堆：每个根结点，都有根结点的值小于孩子结点的值</li></ul><h2 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h2><p>堆的元素存储方式，按照完全二叉树的顺序存储方式存储在一个一维数组中，如下图：</p><p><img src="https://static.vue-js.com/ea0fd1f0-1ed7-11ec-8e64-91fdec0f05a1.png"></p><p>用一维数组存储则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><p>根据完全二叉树的特性，可以得到如下特性：</p><ul><li>数组零坐标代码的是堆顶元素</li><li>一个节点的父亲节点的坐标等于其坐标除以2整数部分</li><li>一个节点的左节点等于其本身节点坐标 * 2 + 1</li><li>一个节点的右节点等于其本身节点坐标 * 2 + 2</li></ul><p>根据上述堆的特性，下面构建最小堆的构造函数和对应的属性方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 存储堆元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取父元素坐标</span></span><br><span class="line">  <span class="title function_">getParentIndex</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取左节点元素坐标</span></span><br><span class="line">  <span class="title function_">getLeftIndex</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取右节点元素坐标</span></span><br><span class="line">  <span class="title function_">getRightIndex</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换元素</span></span><br><span class="line">  <span class="title function_">swap</span>(<span class="params">i1, i2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="variable language_">this</span>.<span class="property">heap</span>[i1]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>[i1] = <span class="variable language_">this</span>.<span class="property">heap</span>[i2]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>[i2] = temp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查看堆顶元素</span></span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取堆元素的大小</span></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到堆的操作有：</p><ul><li>插入</li><li>删除</li></ul><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>将值插入堆的底部，即数组的尾部，当插入一个新的元素之后，堆的结构就会被破坏，因此需要堆中一个元素做上移操作</p><p>将这个值和它父节点进行交换，直到父节点小于等于这个插入的值，大小为<code>k</code>的堆中插入元素的时间复杂度为<code>O(logk)</code></p><p>如下图所示，22节点是新插入的元素，然后进行上移操作：</p><p> <img src="https://static.vue-js.com/06893fb0-1ed8-11ec-8e64-91fdec0f05a1.png"></p><p>相关代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="title function_">insert</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">push</span>(value)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">shifUp</span>(<span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上移操作</span></span><br><span class="line"><span class="title function_">shiftUp</span>(<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> parentIndex = <span class="variable language_">this</span>.<span class="title function_">getParentIndex</span>(index)</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">heap</span>[parentIndex] &gt; <span class="variable language_">this</span>.<span class="property">heap</span>[index])&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">swap</span>(parentIndex, index)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">shiftUp</span>(parentIndex)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>常见操作是用数组尾部元素替换堆顶，这里不直接删除堆顶，因为所有的元素会向前移动一位，会破坏了堆的结构</p><p>然后进行下移操作，将新的堆顶和它的子节点进行交换，直到子节点大于等于这个新的堆顶，删除堆顶的时间复杂度为<code>O(logk)</code></p><p>整体如下图操作：</p><p> <img src="https://static.vue-js.com/12a2a160-1ed8-11ec-a752-75723a64e8f5.png"></p><p>相关代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">pop</span>()</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">shiftDown</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下移操作</span></span><br><span class="line"><span class="title function_">shiftDown</span>(<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> leftIndex = <span class="variable language_">this</span>.<span class="title function_">getLeftIndex</span>(index)</span><br><span class="line">  <span class="keyword">const</span> rightIndex = <span class="variable language_">this</span>.<span class="title function_">getRightIndex</span>(index)</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">heap</span>[leftIndex] &lt; <span class="variable language_">this</span>.<span class="property">heap</span>[index])&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">swap</span>(leftIndex, index)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">shiftDown</span>(leftIndex)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">heap</span>[rightIndex] &lt; <span class="variable language_">this</span>.<span class="property">heap</span>[index])&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">swap</span>(rightIndex, index)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">shiftDown</span>(rightIndex)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>关于堆的插入和删除时间复杂度都是<code>Olog(n)</code>，原因在于包含n个节点的完全二叉树，树的高度不会超过<code>log2n</code></p><p>堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是<code>Olog(n)</code>，插入数据和删除堆顶元素的主要逻辑就是堆化</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><ul><li>堆是一个完全二叉树</li><li>堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值</li><li>对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”</li><li>对于每个节点的值都小于等于子树中每个节点值的堆，叫作“小顶堆”</li><li>根据堆的特性，我们可以使用堆来进行排序操作，也可以使用其来求第几大或者第几小的值</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://baike.baidu.com/item/%E5%A0%86/20606834">https://baike.baidu.com/item/%E5%A0%86/20606834</a></li><li><a href="https://xlbpowder.cn/2021/02/26/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/">https://xlbpowder.cn/2021/02/26/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对图的理解？相关操作有哪些？</title>
      <link href="/2023/02/12/algorithm-graph/"/>
      <url>/2023/02/12/algorithm-graph/</url>
      
        <content type="html"><![CDATA[<h1 id="对图的理解？相关操作有哪些？"><a href="#对图的理解？相关操作有哪些？" class="headerlink" title="对图的理解？相关操作有哪些？"></a>对图的理解？相关操作有哪些？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>在计算机科学中，图是一种抽象的数据类型，在图中的数据元素通常称为结点，<code>V</code>是所有顶点的集合，<code>E</code>是所有边的集合</p><p>如果两个顶点<code>v</code>,<code> w</code>，只能由<code>v</code>向<code>w</code>，而不能由<code>w</code>向<code>v</code>，那么我们就把这种情况叫做一个从 <code>v</code> 到 <code>w</code> 的有向边。<code>v </code>也被称做初始点，<code>w</code>也被称为终点。这种图就被称做有向图</p><p>如果<code>v</code>和<code>w</code>是没有顺序的，从<code>v</code>到达<code>w</code>和从<code>w</code>到达<code>v</code>是完全相同的，这种图就被称为无向图</p><p>图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系</p><p>常见表达图的方式有如下：</p><ul><li><p>邻接矩阵</p></li><li><p>邻接表</p></li></ul><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>通过使用一个二维数组<code>G[N][N]</code>进行表示<code>N</code>个点到<code>N-1</code>编号，通过邻接矩阵可以立刻看出两顶点之间是否存在一条边，只需要检查邻接矩阵行<code>i</code>和列<code>j</code>是否是非零值，对于无向图，邻接矩阵是对称的</p><p> <img src="https://static.vue-js.com/881d4300-2059-11ec-a752-75723a64e8f5.png"></p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>存储方式如下图所示：</p><p> <img src="https://static.vue-js.com/949fedd0-2059-11ec-a752-75723a64e8f5.png"></p><p>在<code>javascript</code>中，可以使用<code>Object</code>进行表示，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = &#123;</span><br><span class="line">  <span class="attr">A</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>],</span><br><span class="line">  <span class="attr">B</span>: [<span class="number">2</span>],</span><br><span class="line">  <span class="attr">C</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="attr">D</span>: [<span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">  <span class="attr">E</span>: [<span class="number">6</span>],</span><br><span class="line">  <span class="attr">F</span>: [<span class="number">0</span>, <span class="number">6</span>],</span><br><span class="line">  <span class="attr">G</span>: [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图的数据结构还可能包含和每条边相关联的数值（edge value），例如一个标号或一个数值（即权重，weight；表示花费、容量、长度等）</p><h2 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h2><p>关于的图的操作常见的有：</p><ul><li>深度优先遍历</li><li>广度优先遍历</li></ul><p>首先构建一个图的邻接矩阵表示，如下面的图：</p><p> <img src="https://static.vue-js.com/a1311790-2059-11ec-8e64-91fdec0f05a1.png"></p><p>用代码表示则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = &#123;</span><br><span class="line">  <span class="number">0</span>: [<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">  <span class="number">1</span>: [<span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">  <span class="number">2</span>: [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="number">3</span>: [],</span><br><span class="line">  <span class="number">4</span>: [<span class="number">3</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>也就是尽可能的往深处的搜索图的分支</p><p>实现思路是，首先应该确定一个根节点，然后对根节点的没访问过的相邻节点进行深度优先遍历</p><p>确定以 0 为根节点，然后进行深度遍历，然后遍历1，接着遍历 2，然后3，此时完成一条分支<code>0 - 1- 2- 3</code>的遍历，换一条分支，也就是4，4后面因为3已经遍历过了，所以就不访问了</p><p>用代码表示则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">n</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">  visited.<span class="title function_">add</span>(n) <span class="comment">// 访问过添加记录</span></span><br><span class="line">  graph[n].<span class="title function_">forEach</span>(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited.<span class="title function_">has</span>(c))&#123; <span class="comment">// 判断是否访问呢过</span></span><br><span class="line">      <span class="title function_">dfs</span>(c)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>先访问离根节点最近的节点，然后进行入队操作，解决思路如下：</p><ul><li>新建一个队列，把根节点入队</li><li>把队头出队并访问</li><li>把队头的没访问过的相邻节点入队</li><li>重复二、三步骤，知道队列为空</li></ul><p>用代码标识则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">n</span>) =&gt; &#123;</span><br><span class="line">  visited.<span class="title function_">add</span>(n)</span><br><span class="line">  <span class="keyword">const</span> q = [n]</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> n = q.<span class="title function_">shift</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">    graph[n].<span class="title function_">forEach</span>(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!visited.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">        q.<span class="title function_">push</span>(c)  </span><br><span class="line">        visited.<span class="title function_">add</span>(c)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>通过上面的初步了解，可以看到图就是由顶点的有穷非空集合和顶点之间的边组成的集合，分成了无向图与有向图</p><p>图的表达形式可以分成邻接矩阵和邻接表两种形式，在<code>javascript</code>中，则可以通过二维数组和对象的形式进行表达</p><p>图实际是很复杂的，后续还可以延伸出无向图和带权图，对应如下图所示：</p><p> <img src="https://static.vue-js.com/b0d88200-2059-11ec-8e64-91fdec0f05a1.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)</a></li><li><a href="https://www.kancloud.cn/imnotdown1019/java_core_full/2159607">https://www.kancloud.cn/imnotdown1019/java_core_full/2159607</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对贪心算法、回溯算法的理解？应用场景？</title>
      <link href="/2023/02/11/algorithm-design2/"/>
      <url>/2023/02/11/algorithm-design2/</url>
      
        <content type="html"><![CDATA[<h1 id="对贪心算法、回溯算法的理解？应用场景？"><a href="#对贪心算法、回溯算法的理解？应用场景？" class="headerlink" title="对贪心算法、回溯算法的理解？应用场景？"></a>对贪心算法、回溯算法的理解？应用场景？</h1><h2 id="一、贪心算法"><a href="#一、贪心算法" class="headerlink" title="一、贪心算法"></a>一、贪心算法</h2><p>贪心算法，又称贪婪算法，是算法设计中的一种思想</p><p>其期待每一个阶段都是局部最优的选择，从而达到全局最优，但是结果并不一定是最优的</p><p>举个零钱兑换的例子，如果你有1元、2元、5元的钱币数张，用于兑换一定的金额，但是要求兑换的钱币张数最少</p><p>如果现在你要兑换11元，按照贪心算法的思想，先选择面额最大的5元钱币进行兑换，那么就得到11 &#x3D; 5 + 5 + 1 的选择，这种情况是最优的</p><p>但是如果你手上钱币的面额为1、3、4，想要兑换6元，按照贪心算法的思路，我们会 6 &#x3D; 4 + 1 + 1这样选择，这种情况结果就不是最优的选择</p><p>从上面例子可以看到，贪心算法存在一些弊端，使用到贪心算法的场景，都会存在一个特性：</p><p>一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法</p><p>至于是否选择贪心算法，主要看是否有如下两大特性：</p><ul><li>贪心选择：当某一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择</li><li>最优子结构：如果一个问题的最优解包含其子问题的最优解，则此问题具备最优子结构的性质。问题的最优子结构性质是该问题是否可以用贪心算法求解的关键所在</li></ul><h2 id="二、回溯算法"><a href="#二、回溯算法" class="headerlink" title="二、回溯算法"></a>二、回溯算法</h2><p>回溯算法，也是算法设计中的一种思想，是一种渐进式寻找并构建问题解决方式的策略</p><p>回溯算法会先从一个可能的工作开始解决问题，如果不行，就回溯并选择另一个动作，知道将问题解决</p><p>使用回溯算法的问题，有如下特性：</p><ul><li>有很多路，例如一个矩阵的方向或者树的路径</li><li>在这些的路里面，有死路也有生路，思路即不符合题目要求的路，生路则符合</li><li>通常使用递归来模拟所有的路</li></ul><p>常见的伪代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">  <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">    result.<span class="title function_">add</span>(路径)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> 选择 <span class="keyword">of</span> 选择列表:</span><br><span class="line">    做选择</span><br><span class="line">    <span class="title function_">backtrack</span>(路径, 选择列表)</span><br><span class="line">    撤销选择</span><br></pre></td></tr></table></figure><p>重点解决三个问题：</p><ul><li>路径：也就是已经做出的选择</li><li>选择列表</li><li>结束条件</li></ul><p>例如经典使用回溯算法为解决全排列的问题，如下：</p><p>一个不含重复数字的数组 <code>nums</code> ，我们要返回其所有可能的全排列，解决这个问题的思路是：</p><ul><li>用递归模拟所有的情况</li><li>遇到包含重复元素的情况则回溯</li><li>收集到所有到达递归终点的情况，并返回、</li></ul><p> <img src="https://static.vue-js.com/2a030f00-2e8e-11ec-8e64-91fdec0f05a1.png"></p><p>用代码表示则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [], path = [];</span><br><span class="line">    <span class="title function_">backtracking</span>(nums, nums.<span class="property">length</span>, []);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">backtracking</span>(<span class="params">n, k, used</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span> === k) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="title function_">push</span>(n[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>; <span class="comment">// 同支</span></span><br><span class="line">            <span class="title function_">backtracking</span>(n, k, used);</span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>前面也初步了解到分而治之、动态规划，现在再了解到贪心算法、回溯算法</p><p>其中关于分而治之、动态规划、贪心策略三者的求解思路如下：</p><p> <img src="https://static.vue-js.com/504b5230-2e8e-11ec-8e64-91fdec0f05a1.png"></p><p>其中三者对应的经典问题如下图：</p><p> <img src="https://static.vue-js.com/62cdc910-2e8e-11ec-8e64-91fdec0f05a1.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95</a></li><li><a href="https://leetcode-cn.com/problems/permutations/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-mfrp/">https://leetcode-cn.com/problems/permutations/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-mfrp/</a></li><li><a href="https://cloud.tencent.com/developer/article/1767046">https://cloud.tencent.com/developer/article/1767046</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_design2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对链表的理解？常见的操作有哪些？</title>
      <link href="/2023/02/10/algorithm-linkedList/"/>
      <url>/2023/02/10/algorithm-linkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="对链表的理解？常见的操作有哪些？"><a href="#对链表的理解？常见的操作有哪些？" class="headerlink" title="对链表的理解？常见的操作有哪些？"></a>对链表的理解？常见的操作有哪些？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>链表（Linked List）是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，由一系列结点（链表中每一个元素称为结点）组成</p><p>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p><p> <img src="https://static.vue-js.com/e4e93490-1c76-11ec-8e64-91fdec0f05a1.png"></p><p>节点用代码表示，则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>data 表示节点存放的数据</li><li>next 表示下一个节点指向的内存空间</li></ul><p>相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到<code>O(1)</code>的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是<code>O(logn)</code>和<code>O(1)</code></p><p>链表的结构也十分多，常见的有四种形式：</p><ul><li>单链表：除了头节点和尾节点，其他节点只包含一个后继指针</li><li>循环链表：跟单链表唯一的区别就在于它的尾结点又指回了链表的头结点，首尾相连，形成了一个环</li><li>双向链表：每个结点具有两个方向指针，后继指针(next)指向后面的结点，前驱指针(prev)指向前面的结点，其中节点的前驱指针和尾结点的后继指针均指向空地址NULL</li><li>双向循环链表：跟双向链表基本一致，不过头节点前驱指针指向尾迹诶单和尾节点的后继指针指向头节点</li></ul><h2 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h2><p>关于链表的操作可以主要分成如下：</p><ul><li>遍历</li><li>插入</li><li>删除</li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>遍历很好理解，就是根据<code>next</code>指针遍历下去，直到为<code>null</code>，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> current = head</span><br><span class="line"><span class="keyword">while</span>(current)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(current.<span class="property">val</span>)</span><br><span class="line">  current = current.<span class="property">next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>向链表中间插入一个元素，可以如下图所示：</p><p> <img src="https://static.vue-js.com/f5fe5fd0-1c76-11ec-8e64-91fdec0f05a1.png"></p><p>可以看到，插入节点可以分成如下步骤：</p><ul><li><p>存储插入位置的前一个节点</p></li><li><p>存储插入位置的后一个节点</p></li><li><p>将插入位置的前一个节点的 next 指向插入节点</p></li><li><p>将插入节点的 next 指向前面存储的 next 节点</p></li></ul><p>相关代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> current = head</span><br><span class="line"><span class="keyword">while</span> (current &lt; position)&#123;</span><br><span class="line">  pervious = current;</span><br><span class="line">  current = current.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line">pervious.<span class="property">next</span> = node;</span><br><span class="line">node.<span class="property">next</span> = current;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果在头节点进行插入操作的时候，会实现<code>previousNode</code>节点为<code>undefined</code>，不适合上述方式</p><p>解放方式可以是在头节点前面添加一个虚拟头节点，保证插入行为一致</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>向链表任意位置删除节点，如下图操作：</p><p> <img src="https://static.vue-js.com/0160cd90-1c77-11ec-a752-75723a64e8f5.png"></p><p>从上图可以看到删除节点的步骤为如下：</p><ul><li>获取删除节点的前一个节点</li><li>获取删除节点的后一个节点</li><li>将前一个节点的 next 指向后一个节点</li><li>向删除节点的 next 指向为null</li></ul><p>如果想要删除制定的节点，示意代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (current != node)&#123;</span><br><span class="line">  pervious = current;</span><br><span class="line">  current = current.<span class="property">next</span>;</span><br><span class="line">  nextNode = current.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line">pervious.<span class="property">next</span> = nextNode</span><br></pre></td></tr></table></figure><p>同样如何希望删除节点处理行为一致，可以在头节点前面添加一个虚拟头节点</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的<code>CPU</code>缓存、数据库缓存、浏览器缓存等等</p><p>当缓存空间被用满时，我们可能会使用<code>LRU</code>最近最好使用策略去清楚，而实现<code>LRU</code>算法的数据结构是链表，思路如下：</p><p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表</p><ul><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表头部</li><li>如果此数据没在缓存链表中<ul><li>如果此时缓存未满，可直接在链表头部插入新节点存储此数据</li><li>如果此时缓存已满，则删除链表尾部节点，再在链表头部插入新节点</li></ul></li></ul><p>由于链表插入删除效率极高，达到O(1)。对于不需要搜索但变动频繁且无法预知数量上限的数据的情况的时候，都可以使用链表</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/zh-hans/%E9%93%BE%E8%A1%A8">https://zh.wikipedia.org/zh-hans/%E9%93%BE%E8%A1%A8</a></li><li><a href="https://mah93.github.io/2019/07/19/js-linked/">https://mah93.github.io/2019/07/19/js-linked/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_linkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对分而治之、动态规划的理解？区别？</title>
      <link href="/2023/02/08/algorithm-design1/"/>
      <url>/2023/02/08/algorithm-design1/</url>
      
        <content type="html"><![CDATA[<h1 id="对分而治之、动态规划的理解？区别？"><a href="#对分而治之、动态规划的理解？区别？" class="headerlink" title="对分而治之、动态规划的理解？区别？"></a>对分而治之、动态规划的理解？区别？</h1><h2 id="一、分而治之"><a href="#一、分而治之" class="headerlink" title="一、分而治之"></a>一、分而治之</h2><p>分而治之是算法设计中的一种方法，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</p><p>关于分而治之的实现，都会经历三个步骤：</p><ul><li>分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题</li><li>解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题</li><li>合并：将各子问题的解合并为原问题的解</li></ul><p>实际上，关于分而治之的思想，我们在前面已经使用，例如归并排序的实现，同样经历了实现分而治之的三个步骤：</p><ul><li><p>分解：把数组从中间一分为二</p></li><li><p>解决：递归地对两个子数组进行归并排序</p></li><li><p>合并：将两个字数组合并称有序数组</p></li></ul><p>同样关于快速排序的实现，亦如此：</p><ul><li>分：选基准，按基准把数组分成两个字数组</li><li>解：递归地对两个字数组进行快速排序</li><li>合：对两个字数组进行合并</li></ul><p>同样二分搜索也能使用分而治之的思想去实现，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">arr,l,r,target</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt; r)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mid = l + <span class="title class_">Math</span>.<span class="title function_">floor</span>((r-l)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] === target)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &lt; target )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">binarySearch</span>(arr,mid + <span class="number">1</span>,r,target)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">binarySearch</span>(arr,l,mid - <span class="number">1</span>,target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h2><p>动态规划，同样是算法设计中的一种方法，是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法</p><p>常常适用于有重叠子问题和最优子结构性质的问题</p><p>简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决</p><p>然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。</p><p>一般这些子问题很相似，可以通过函数关系式递推出来，例如斐波那契数列，我们可以得到公式：当 n 大于 2的时候，F(n) &#x3D;  F(n-1) + F(n-2) ，</p><p>f(10)&#x3D; f(9)+f(8),f(9) &#x3D; f(8) + f(7)…是重叠子问题，当n &#x3D; 1、2的时候，对应的值为2，这时候就通过可以使用一个数组记录每一步计算的结果，以此类推，减少不必要的重复计算</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划</p><p>比如一些求最值的场景，如最长递增子序列、最小编辑距离、背包问题、凑零钱问题等等，都是动态规划的经典应用场景</p><p>关于动态规划题目解决的步骤，一般如下：</p><ul><li>描述最优解的结构</li><li>递归定义最优解的值</li><li>按自底向上的方式计算最优解的值</li><li>由计算出的结果构造一个最优解</li></ul><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</p><p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往<strong>不是互相独立</strong>的，而分而治之的子问题是相互独立的</p><p>若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次</p><p>如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间</p><p>综上，可得：</p><ul><li><p>动态规划：有最优子结构和重叠子问题</p></li><li><p>分而治之：各子问题独立</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408">https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408</a></li><li><a href="https://juejin.cn/post/6951922898638471181">https://juejin.cn/post/6951922898638471181</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_design1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序的理解？如何实现？应用场景？</title>
      <link href="/2023/02/03/algorithm-bubblesort/"/>
      <url>/2023/02/03/algorithm-bubblesort/</url>
      
        <content type="html"><![CDATA[<h1 id="你对冒泡排序的理解？如何实现？应用场景？"><a href="#你对冒泡排序的理解？如何实现？应用场景？" class="headerlink" title="你对冒泡排序的理解？如何实现？应用场景？"></a>你对冒泡排序的理解？如何实现？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法</p><p>冒泡排序的思想就是在每次遍历一遍未排序的数列之后，将一个数据元素浮上去（也就是排好了一个数据）</p><p>如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”</p><p>假如我们要把 12、35、99、18、76 这 5 个数从大到小进行排序，那么数越大，越需要把它放在前面</p><p>思路如下：</p><ul><li>从后开始遍历，首先比较 18 和 76，发现 76 比 18 大，就把两个数交换顺序，得到 12、35、99、76、18</li><li>接着比较 76 和 99，发现 76 比 99 小，所以不用交换顺序</li><li>接着比较 99 和 35，发现 99 比 35 大，交换顺序</li><li>接着比较 99 和 12，发现 99 比 12 大，交换顺序</li></ul><p>最终第 1 趟排序的结果变成了 99、12、35、76、18，如下图所示：</p><p> <img src="https://static.vue-js.com/7a363770-2652-11ec-8e64-91fdec0f05a1.png"></p><p>上述可以看到，经过第一趟的排序，可以得到最大的元素，接下来第二趟排序则对剩下的的4个元素进行排序，如下图所示：</p><p> <img src="https://static.vue-js.com/84b9ddf0-2652-11ec-a752-75723a64e8f5.png"></p><p>经过第 2 趟排序，结果为 99、76、12、35、18</p><p>然后开始第3趟的排序，结果为99、76、35、12、18</p><p>然后第四趟排序结果为99、76、35、18、12</p><p>经过 4 趟排序之后，只剩一个 12 需要排序了，这时已经没有可比较的元素了，这时排序完成</p><h2 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h2><p>如果要实现一个从小到大的排序，算法原理如下：</p><ul><li>首先比较相邻的元素，如果第一个元素比第二个元素大，则交换它们</li><li>针对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样，最后的元素回事最大的数</li><li>针对所有的元素重复以上的步骤，除了最后一个</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif"></p><p>用代码表示则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">// 相邻元素两两对比</span></span><br><span class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">// 元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：冒泡排序在每一轮排序中都会使一个元素排到一趟， 也就是最终需要 n-1 轮这样的排序</p><p>而在每轮排序中都需要对相邻的两个元素进行比较，在最坏的情况下，每次比较之后都需要交换位置，此时时间复杂度为<code>O(n^2)</code></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>对冒泡排序常见的改进方法是加入一标志性变量<code>exchange</code>，用于标志某一趟排序过程中是否有数据交换</p><p>如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程</p><p>可以设置一标志性变量<code>pos</code>，用于记录每趟排序中最后一次进行交换的位置，由于<code>pos</code>位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到<code>pos</code>位置即可，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort1</span>(<span class="params">arr</span>)&#123;</span><br><span class="line"> <span class="keyword">const</span> i=arr.<span class="property">length</span>-<span class="number">1</span>;<span class="comment">//初始时,最后位置保持不变  </span></span><br><span class="line"> <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> pos = <span class="number">0</span>;<span class="comment">//每趟开始时,无记录交换</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = arr[j];</span><br><span class="line">        arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">        arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">    pos = j;<span class="comment">//记录最后交换的位置  </span></span><br><span class="line">   &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">  i = pos;<span class="comment">//为下一趟排序作准备</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在待排序的数列有序的情况下，只需要一轮排序并且不用交换，此时情况最好，时间复杂度为<code>O(n)</code></p><p>并且从上述比较中看到，只有后一个元素比前面的元素大（小）时才会对它们交换位置并向上冒出，对于同样大小的元素，是不需要交换位置的，所以对于同样大小的元素来说，相对位置是不会改变的，因此， 冒泡排序是稳定的</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>冒泡排的核心部分是双重嵌套循环，<br>时间复杂度是 O(N 2 )，相比其它排序算法，这是一个相对较高的时间复杂度，一般情况不推荐使用，由于冒泡排序的简洁性，通常被用来对于程序设计入门的学生介绍算法的概念</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306">https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306</a></li><li><a href="https://www.runoob.com/w3cnote/bubble-sort.html">https://www.runoob.com/w3cnote/bubble-sort.html</a></li><li><a href="http://data.biancheng.net/view/116.html">http://data.biancheng.net/view/116.html</a></li><li><a href="https://dsb123dsb.github.io/2017/03/07/js%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/">https://dsb123dsb.github.io/2017/03/07/js%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_bubblesort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你对二分查找的理解？如何实现？应用场景？</title>
      <link href="/2023/02/02/algorithm-binarySearch/"/>
      <url>/2023/02/02/algorithm-binarySearch/</url>
      
        <content type="html"><![CDATA[<h1 id="你对二分查找的理解？如何实现？应用场景？"><a href="#你对二分查找的理解？如何实现？应用场景？" class="headerlink" title="你对二分查找的理解？如何实现？应用场景？"></a>你对二分查找的理解？如何实现？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>在计算机科学中，二分查找算法，也称折半搜索算法，是一种在有序数组中查找某一特定元素的搜索算法</p><p>想要应用二分查找法，则这一堆数应有如下特性：</p><ul><li>存储在数组中</li><li>有序排序</li></ul><p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束</p><p>如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较</p><p>如果在某一步骤数组为空，则代表找不到</p><p>这种搜索算法每一次比较都使搜索范围缩小一半</p><p>如下图所示：</p><p> <img src="https://static.vue-js.com/e2108520-2987-11ec-a752-75723a64e8f5.png"></p><p>相比普通的顺序查找，除了数据量很少的情况下，二分查找会比顺序查找更快，区别如下所示：</p><p><img src="https://pic2.zhimg.com/v2-43339b963db63b33107b56503ad6b1b5_b.gif"></p><h2 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h2><p>基于二分查找的实现，如果数据是有序的，并且不存在重复项，实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BinarySearch</span>(<span class="params">arr, target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment">// 低位下标</span></span><br><span class="line">    <span class="keyword">let</span> lowIndex = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 高位下标</span></span><br><span class="line">    <span class="keyword">let</span> highIndex = arr.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lowIndex &lt;= highIndex) &#123;</span><br><span class="line">        <span class="comment">// 中间下标</span></span><br><span class="line">        <span class="keyword">const</span> midIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((lowIndex + highIndex) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (target &lt; arr[midIndex]) &#123;</span><br><span class="line">            highIndex = midIndex - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[midIndex]) &#123;</span><br><span class="line">            lowIndex = midIndex + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// target === arr[midIndex]</span></span><br><span class="line">            <span class="keyword">return</span> midIndex</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果数组中存在重复项，而我们需要找出第一个制定的值，实现则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BinarySearchFirst</span>(<span class="params">arr, target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment">// 低位下标</span></span><br><span class="line">    <span class="keyword">let</span> lowIndex = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 高位下标</span></span><br><span class="line">    <span class="keyword">let</span> highIndex = arr.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lowIndex &lt;= highIndex) &#123;</span><br><span class="line">        <span class="comment">// 中间下标</span></span><br><span class="line">        <span class="keyword">const</span> midIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((lowIndex + highIndex) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (target &lt; arr[midIndex]) &#123;</span><br><span class="line">            highIndex = midIndex - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[midIndex]) &#123;</span><br><span class="line">            lowIndex = midIndex + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当 target 与 arr[midIndex] 相等的时候，如果 midIndex 为0或者前一个数比 target 小那么就找到了第一个等于给定值的元素，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (midIndex === <span class="number">0</span> || arr[midIndex - <span class="number">1</span>] &lt; target) <span class="keyword">return</span> midIndex</span><br><span class="line">            <span class="comment">// 否则高位下标为中间下标减1，继续查找</span></span><br><span class="line">            highIndex = midIndex - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，除了有序的数组可以使用，还有一种特殊的数组可以应用，那就是轮转后的有序数组</p><p>有序数组即一个有序数字以某一个数为轴，将其之前的所有数都轮转到数组的末尾所得</p><p>例如，[4, 5, 6, 7, 0, 1, 2]就是一个轮转后的有序数组</p><p>该数组的特性是存在一个分界点用来分界两个有序数组，如下：</p><p> <img src="https://static.vue-js.com/eeee2130-2987-11ec-8e64-91fdec0f05a1.png"></p><p>分界点有如下特性：</p><ul><li>分界点元素 &gt;&#x3D; 第一个元素</li><li>分界点元素 &lt; 第一个元素</li></ul><p>代码实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">search</span> (nums, target) &#123;</span><br><span class="line">  <span class="comment">// 如果为空或者是空数组的情况</span></span><br><span class="line">  <span class="keyword">if</span> (nums == <span class="literal">null</span> || !nums.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 搜索区间是前闭后闭</span></span><br><span class="line">  <span class="keyword">let</span> begin = <span class="number">0</span>,</span><br><span class="line">    end = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">    <span class="comment">// 下面这样写是考虑大数情况下避免溢出</span></span><br><span class="line">    <span class="keyword">let</span> mid = begin + ((end - begin) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左边是有序的</span></span><br><span class="line">    <span class="keyword">if</span> (nums[begin] &lt;= nums[mid]) &#123;</span><br><span class="line">      <span class="comment">//同时target在[ nums[begin],nums[mid] ]中，那么就在这段有序区间查找</span></span><br><span class="line">      <span class="keyword">if</span> (nums[begin] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;</span><br><span class="line">        end = mid - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则去反方向查找</span></span><br><span class="line">        begin = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果右侧是有序的</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//同时target在[ nums[mid],nums[end] ]中，那么就在这段有序区间查找</span></span><br><span class="line">      <span class="keyword">if</span> (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[end]) &#123;</span><br><span class="line">        begin = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        end = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对比普通的二分查找法，为了确定目标数会落在二分后的哪个部分，我们需要更多的判定条件</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>二分查找法的<code>O(logn)</code>让它成为十分高效的算法。不过它的缺陷却也是比较明显，就在它的限定之上：</p><ul><li>有序：我们很难保证我们的数组都是有序的</li><li>数组：数组读取效率是O(1)，可是它的插入和删除某个元素的效率却是O(n)，并且数组的存储是需要连续的内存空间，不适合大数据的情况</li></ul><p>关于二分查找的应用场景，主要如下：</p><ul><li>不适合数据量太小的数列；数列太小，直接顺序遍历说不定更快，也更简单</li><li>每次元素与元素的比较是比较耗时的，这个比较操作耗时占整个遍历算法时间的大部分，那么使用二分查找就能有效减少元素比较的次数</li><li>不适合数据量太大的数列，二分查找作用的数据结构是顺序表，也就是数组，数组是需要连续的内存空间的，系统并不一定有这么大的连续内存空间可以使用</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95#javascript_%E7%89%88%E6%9C%AC">https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95#javascript_%E7%89%88%E6%9C%AC</a></li><li><a href="https://www.cnblogs.com/ider/archive/2012/04/01/binary_search.html">https://www.cnblogs.com/ider/archive/2012/04/01/binary_search.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_binarySearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你对算法的理解？应用场景？</title>
      <link href="/2023/02/01/algorithm-Algotithm/"/>
      <url>/2023/02/01/algorithm-Algotithm/</url>
      
        <content type="html"><![CDATA[<h1 id="你对算法的理解？应用场景？"><a href="#你对算法的理解？应用场景？" class="headerlink" title="你对算法的理解？应用场景？"></a>你对算法的理解？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制</p><p>也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出</p><p>如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题</p><p>一个程序&#x3D;算法+数据结构，数据结构是算法实现的基础，算法总是要依赖于某种数据结构来实现的，两者不可分割</p><p>因此，算法的设计和选择要同时结合数据结构，简单地说数据结构的设计就是选择存储方式，如确定问题中的信息是用数组存储还是用普通的变量存储或其他更加复杂的数据结构</p><p>针对上述，可以得出一个总结：不同的算法可能用不同的时间、空间或效率来完成同样的任务</p><h2 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h2><p>关于算法的五大特性，有如下：</p><ul><li>有限性（Finiteness）：一个算法必须保证执行有限步之后结束</li><li>确切性（Definiteness）： 一个算法的每一步骤必须有确切的定义</li><li>输入（Input）：一个算法有零个或多个输入，以刻画运算对象的初始情况，所谓零个输入是指算法本身给定了初始条件</li><li>输出（Output）：一个算法有一个或多个输出。没有输出的算法毫无意义</li><li>可行性（Effectiveness）：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）</li></ul><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>在前端领域中，数据结构与算法无法不在，例如现在的<code>vue</code>或者<code>react</code>项目，实现虚拟<code>DOM</code>或者<code>Fiber</code>结构，本质就是一种数据结构，如下一个简单的虚拟<code>DOM</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;lucifer&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">      <span class="attr">children</span>: [&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">children</span>: []</span><br><span class="line">      &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vue</code>与<code>react</code>都能基于基于对应的数据结构实现<code>diff</code>算法，提高了整个框架的性能以及拓展性</p><p>包括在前端<code>javascript</code>编译的时候，都会生成对应的抽象语法树<code>AST</code>，其本身不涉及到任何语法，因此你只要编写相应的转义规则，就可以将任何语法转义到任何语法，也是<code>babel</code>， <code>PostCSS</code>, <code>prettier</code>， <code>typescript</code> </p><p>除了这些框架或者工具底层用到算法与数据结构之外，日常业务也无处不在，例如实现一个输入框携带联想功能，如下：</p><p> <img src="https://static.vue-js.com/682d16c0-1621-11ec-8e64-91fdec0f05a1.png"></p><p>如果我们要实现这个功能， 则可以使用前缀树，如下：</p><p> <img src="https://static.vue-js.com/55a1ed50-1621-11ec-8e64-91fdec0f05a1.png"></p><p>包括前端可能会做一些对字符串进行相似度检测，例如”每日一题”和”js每日一题”两个字符串进行相似度对比，这种情况可以通过“最小编辑距离”算法，如果<code>a</code>和<code>b</code>的编辑距离越小，我们认为越相似</p><p>日常在编写任何代码的都需要一个良好的算法思维，选择好的算法或者数据结构，能让整个程序效率更高</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025">https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025</a></li><li><a href="https://lucifer.ren/blog/2019/09/18/algorthimn-fe-1/">https://lucifer.ren/blog/2019/09/18/algorthimn-fe-1/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm_Algotithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node 中的 Stream 的理解？应用场景？</title>
      <link href="/2023/01/29/nodejs-stream/"/>
      <url>/2023/01/29/nodejs-stream/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-中的-Stream-的理解？应用场景？"><a href="#Node-中的-Stream-的理解？应用场景？" class="headerlink" title="Node 中的 Stream 的理解？应用场景？"></a>Node 中的 Stream 的理解？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>流（Stream），是一个数据传输手段，是端到端信息交换的一种方式，而且是有顺序的,是逐块读取数据、处理内容，用于顺序读取输入或写入输出</p><p><code>Node.js</code>中很多对象都实现了流，总之它是会冒数据（以 <code>Buffer</code> 为单位）</p><p>它的独特之处在于，它不像传统的程序那样一次将一个文件读入内存，而是逐块读取数据、处理其内容，而不是将其全部保存在内存中</p><p>流可以分成三部分：<code>source</code>、<code>dest</code>、<code>pipe</code></p><p>在<code>source</code>和<code>dest</code>之间有一个连接的管道<code>pipe</code>,它的基本语法是<code>source.pipe(dest)</code>，<code>source</code>和<code>dest</code>就是通过pipe连接，让数据从<code>source</code>流向了<code>dest</code>，如下图所示：</p><p> <img src="https://static.vue-js.com/aec05670-c76f-11eb-ab90-d9ae814b240d.png"></p><h2 id="二、种类"><a href="#二、种类" class="headerlink" title="二、种类"></a>二、种类</h2><p>在<code>NodeJS</code>，几乎所有的地方都使用到了流的概念，分成四个种类：</p><ul><li><p>可写流：可写入数据的流。例如 fs.createWriteStream()  可以使用流将数据写入文件</p></li><li><p>可读流： 可读取数据的流。例如fs.createReadStream() 可以从文件读取内容</p></li><li><p>双工流： 既可读又可写的流。例如 net.Socket</p></li><li><p>转换流： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据</p></li></ul><p>在<code>NodeJS</code>中<code>HTTP</code>服务器模块中，<code>request</code> 是可读流，<code>response</code> 是可写流。还有<code>fs</code> 模块，能同时处理可读和可写文件流</p><p>可读流和可写流都是单向的，比较容易理解，而另外两个是双向的</p><h3 id="双工流"><a href="#双工流" class="headerlink" title="双工流"></a>双工流</h3><p>之前了解过<code>websocket</code>通信，是一个全双工通信，发送方和接受方都是各自独立的方法，发送和接收都没有任何关系</p><p>如下图所示：</p><p> <img src="https://static.vue-js.com/b7ac6d00-c76f-11eb-ab90-d9ae814b240d.png"></p><p>基本代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Duplex</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myDuplex = <span class="keyword">new</span> <span class="title class_">Duplex</span>(&#123;</span><br><span class="line">  <span class="title function_">read</span>(<span class="params">size</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">write</span>(<span class="params">chunk, encoding, callback</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="双工流-1"><a href="#双工流-1" class="headerlink" title="双工流"></a>双工流</h3><p>双工流的演示图如下所示：</p><p> <img src="https://static.vue-js.com/c02883b0-c76f-11eb-ab90-d9ae814b240d.png"></p><p>除了上述压缩包的例子，还比如一个 <code>babel</code>，把<code>es6</code>转换为，我们在左边写入 <code>es6</code>，从右边读取 <code>es5</code></p><p>基本代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Transform</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myTransform = <span class="keyword">new</span> <span class="title class_">Transform</span>(&#123;</span><br><span class="line">  <span class="title function_">transform</span>(<span class="params">chunk, encoding, callback</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p><code>stream</code>的应用场景主要就是处理<code>IO</code>操作，而<code>http</code>请求和文件操作都属于<code>IO</code>操作</p><p>试想一下，如果一次<code>IO</code>操作过大，硬件的开销就过大，而将此次大的<code>IO</code>操作进行分段操作，让数据像水管一样流动，直到流动完成</p><p>常见的场景有：</p><ul><li>get请求返回文件给客户端</li><li>文件操作</li><li>一些打包工具的底层操作</li></ul><h3 id="get请求返回文件给客户端"><a href="#get请求返回文件给客户端" class="headerlink" title="get请求返回文件给客户端"></a>get请求返回文件给客户端</h3><p>使用<code>stream</code>流返回文件，<code>res</code>也是一个<code>stream</code>对象，通过<code>pipe</code>管道将文件数据返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> method = req.<span class="property">method</span>; <span class="comment">// 获取请求方法</span></span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">&#x27;GET&#x27;</span>) &#123; <span class="comment">// get 请求</span></span><br><span class="line">        <span class="keyword">const</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data.txt&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> stream = fs.<span class="title function_">createReadStream</span>(fileName);</span><br><span class="line">        stream.<span class="title function_">pipe</span>(res); <span class="comment">// 将 res 作为 stream 的 dest</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>创建一个可读数据流<code>readStream</code>，一个可写数据流<code>writeStream</code>，通过<code>pipe</code>管道把数据流转过去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个文件名</span></span><br><span class="line"><span class="keyword">const</span> fileName1 = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fileName2 = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data-bak.txt&#x27;</span>)</span><br><span class="line"><span class="comment">// 读取文件的 stream 对象</span></span><br><span class="line"><span class="keyword">const</span> readStream = fs.<span class="title function_">createReadStream</span>(fileName1)</span><br><span class="line"><span class="comment">// 写入文件的 stream 对象</span></span><br><span class="line"><span class="keyword">const</span> writeStream = fs.<span class="title function_">createWriteStream</span>(fileName2)</span><br><span class="line"><span class="comment">// 通过 pipe执行拷贝，数据流转</span></span><br><span class="line">readStream.<span class="title function_">pipe</span>(writeStream)</span><br><span class="line"><span class="comment">// 数据读取完成监听，即拷贝完成</span></span><br><span class="line">readStream.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拷贝完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="一些打包工具的底层操作"><a href="#一些打包工具的底层操作" class="headerlink" title="一些打包工具的底层操作"></a>一些打包工具的底层操作</h3><p>目前一些比较火的前端打包构建工具，都是通过<code>node.js</code>编写的，打包和构建的过程肯定是文件频繁操作的过程，离不来<code>stream</code>，如<code>gulp</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://xie.infoq.cn/article/1a9695020828460eb3c4ff1fa">https://xie.infoq.cn/article/1a9695020828460eb3c4ff1fa</a></li><li><a href="https://juejin.cn/post/6844903891083984910">https://juejin.cn/post/6844903891083984910</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node性能如何进行监控以及优化？</title>
      <link href="/2023/01/25/nodejs-performance/"/>
      <url>/2023/01/25/nodejs-performance/</url>
      
        <content type="html"><![CDATA[<h1 id="Node性能如何进行监控以及优化？"><a href="#Node性能如何进行监控以及优化？" class="headerlink" title="Node性能如何进行监控以及优化？"></a>Node性能如何进行监控以及优化？</h1><h2 id="一、-是什么"><a href="#一、-是什么" class="headerlink" title="一、 是什么"></a>一、 是什么</h2><p><code>Node</code>作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下：</p><ul><li>CPU</li><li>内存</li><li>I&#x2F;O</li><li>网络</li></ul><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>主要分成了两部分：</p><ul><li>CPU负载：在某个时间段内，占用以及等待CPU的进程总数</li><li>CPU使用率：CPU时间占用状况，等于 1 - 空闲CPU时间(idle time) &#x2F; CPU总时间</li></ul><p>这两个指标都是用来评估系统当前CPU的繁忙程度的量化指标</p><p><code>Node</code>应用一般不会消耗很多的<code>CPU</code>，如果<code>CPU</code>占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞</p><h3 id="内存指标"><a href="#内存指标" class="headerlink" title="内存指标"></a>内存指标</h3><p>内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于Node来说，内部内存堆栈的使用状态也是一个可以量化的指标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /app/lib/memory.js</span></span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>);</span><br><span class="line"><span class="comment">// 获取当前Node内存堆栈情况</span></span><br><span class="line"><span class="keyword">const</span> &#123; rss, heapUsed, heapTotal &#125; = process.<span class="title function_">memoryUsage</span>();</span><br><span class="line"><span class="comment">// 获取系统空闲内存</span></span><br><span class="line"><span class="keyword">const</span> sysFree = os.<span class="title function_">freemem</span>();</span><br><span class="line"><span class="comment">// 获取系统总内存</span></span><br><span class="line"><span class="keyword">const</span> sysTotal = os.<span class="title function_">totalmem</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">memory</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">sys</span>: <span class="number">1</span> - sysFree / sysTotal,  <span class="comment">// 系统内存占用率</span></span><br><span class="line">      <span class="attr">heap</span>: heapUsed / headTotal,   <span class="comment">// Node堆内存占用率</span></span><br><span class="line">      <span class="attr">node</span>: rss / sysTotal,         <span class="comment">// Node占用系统内存的比例</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>rss：表示node进程占用的内存总量。</li><li>heapTotal：表示堆内存的总量。</li><li>heapUsed：实际堆内存的使用量。</li><li>external ：外部程序的内存使用量，包含Node核心的C++程序的内存使用量</li></ul><p>在<code>Node</code>中，一个进程的最大内存容量为1.5GB。因此我们需要减少内存泄露</p><h3 id="磁盘-I-O"><a href="#磁盘-I-O" class="headerlink" title="磁盘 I&#x2F;O"></a>磁盘 I&#x2F;O</h3><p>硬盘的<code> IO</code> 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍</p><p>内存 <code>IO </code>比磁盘<code> IO</code> 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 <code>redis</code>、<code>memcached </code>等</p><p>并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决</p><h2 id="二、如何监控"><a href="#二、如何监控" class="headerlink" title="二、如何监控"></a>二、如何监控</h2><p>关于性能方面的监控，一般情况都需要借助工具来实现</p><p>这里采用<code>Easy-Monitor 2.0</code>，其是轻量级的 <code>Node.js</code> 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 <code>require</code> 一次，无需改动任何业务代码即可开启内核级别的性能监控分析</p><p>使用方法如下：</p><p>在你的项目入口文件中按照如下方式引入，当然请传入你的项目名称：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> easyMonitor = <span class="built_in">require</span>(<span class="string">&#x27;easy-monitor&#x27;</span>);</span><br><span class="line"><span class="title function_">easyMonitor</span>(<span class="string">&#x27;你的项目名称&#x27;</span>);</span><br></pre></td></tr></table></figure><p>打开你的浏览器，访问 <code>http://localhost:12333</code> ，即可看到进程界面</p><p>关于定制化开发、通用配置项以及如何动态更新配置项详见官方文档</p><h2 id="三、如何优化"><a href="#三、如何优化" class="headerlink" title="三、如何优化"></a>三、如何优化</h2><p>关于<code>Node</code>的性能优化的方式有：</p><ul><li>使用最新版本Node.js</li><li>正确使用流 Stream</li><li>代码层面优化</li><li>内存管理优化</li></ul><h3 id="使用最新版本Node-js"><a href="#使用最新版本Node-js" class="headerlink" title="使用最新版本Node.js"></a>使用最新版本Node.js</h3><p>每个版本的性能提升主要来自于两个方面：</p><ul><li>V8 的版本更新</li><li>Node.js 内部代码的更新优化</li></ul><h3 id="正确使用流-Stream"><a href="#正确使用流-Stream" class="headerlink" title="正确使用流 Stream"></a>正确使用流 Stream</h3><p>在<code>Node</code>中，很多对象都实现了流，对于一个大文件可以通过流的形式发送，不需要将其完全读入内存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(__dirname + <span class="string">&#x27;/data.txt&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">        res.<span class="title function_">end</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stream = fs.<span class="title function_">createReadStream</span>(__dirname + <span class="string">&#x27;/data.txt&#x27;</span>);</span><br><span class="line">    stream.<span class="title function_">pipe</span>(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="代码层面优化"><a href="#代码层面优化" class="headerlink" title="代码层面优化"></a>代码层面优化</h3><p>合并查询，将多次查询合并一次，减少数据库的查询次数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">for</span> user_id <span class="keyword">in</span> userIds </span><br><span class="line">     <span class="keyword">let</span> account = user_account.<span class="title function_">findOne</span>(user_id)</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> user_account_map = &#123;&#125;   <span class="comment">// 注意这个对象将会消耗大量内存。</span></span><br><span class="line">user_account.<span class="title function_">find</span>(user_id <span class="keyword">in</span> user_ids).<span class="title function_">forEach</span>(<span class="params">account</span>)&#123;</span><br><span class="line">    user_account_map[account.<span class="property">user_id</span>] =  account</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> user_id <span class="keyword">in</span> userIds </span><br><span class="line">    <span class="keyword">var</span> account = user_account_map[user_id]</span><br></pre></td></tr></table></figure><h3 id="内存管理优化"><a href="#内存管理优化" class="headerlink" title="内存管理优化"></a>内存管理优化</h3><p>在 V8 中，主要将内存分为新生代和老生代两代：</p><ul><li>新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象</li><li>老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象</li></ul><p>若新生代内存空间不够，直接分配到老生代</p><p>通过减少内存占用，可以提高服务器的性能。如果有内存泄露，也会导致大量的对象存储到老生代中，服务器性能会大大降低</p><p>如下面情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = fs.<span class="title function_">readFileSync</span>(__dirname + <span class="string">&#x27;/source/index.htm&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(</span><br><span class="line">    <span class="title function_">mount</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">        ctx.<span class="property">status</span> = <span class="number">200</span>;</span><br><span class="line">        ctx.<span class="property">type</span> = <span class="string">&#x27;html&#x27;</span>;</span><br><span class="line">        ctx.<span class="property">body</span> = buffer;</span><br><span class="line">        leak.<span class="title function_">push</span>(fs.<span class="title function_">readFileSync</span>(__dirname + <span class="string">&#x27;/source/index.htm&#x27;</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> leak = [];</span><br></pre></td></tr></table></figure><p><code>leak</code>的内存非常大，造成内存泄露，应当避免这样的操作，通过减少内存使用，是提高服务性能的手段之一</p><p>而节省内存最好的方式是使用池，其将频用、可复用对象存储起来，减少创建和销毁操作</p><p>例如有个图片请求接口，每次请求，都需要用到类。若每次都需要重新new这些类，并不是很合适，在大量请求时，频繁创建和销毁这些类，造成内存抖动</p><p>使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中。每次用到该对象时，就取对象池空闲的对象，并对它进行初始化操作，从而提高框架的性能</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000039327565">https://segmentfault.com/a/1190000039327565</a></li><li><a href="https://zhuanlan.zhihu.com/p/50055740">https://zhuanlan.zhihu.com/p/50055740</a></li><li><a href="https://segmentfault.com/a/1190000010231628">https://segmentfault.com/a/1190000010231628</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js 的理解？优缺点？应用场景？</title>
      <link href="/2023/01/21/nodejs-nodejs/"/>
      <url>/2023/01/21/nodejs-nodejs/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js-的理解？优缺点？应用场景？"><a href="#Node-js-的理解？优缺点？应用场景？" class="headerlink" title="Node.js 的理解？优缺点？应用场景？"></a>Node.js 的理解？优缺点？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>Node.js</code> 是一个开源与跨平台的 <code>JavaScript</code> 运行时环境</p><p>在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能</p><p>可以理解为 <code>Node.js</code> 就是一个服务器端的、非阻塞式I&#x2F;O的、事件驱动的<code>JavaScript</code>运行环境</p><h3 id="非阻塞异步"><a href="#非阻塞异步" class="headerlink" title="非阻塞异步"></a>非阻塞异步</h3><p><code>Nodejs</code>采用了非阻塞型<code>I/O</code>机制，在做<code>I/O</code>操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作</p><p>例如在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率</p><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数</p><p>比如读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理</p><p> <img src="https://static.vue-js.com/a7729590-c1e8-11eb-ab90-d9ae814b240d.png"></p><h2 id="二、优缺点"><a href="#二、优缺点" class="headerlink" title="二、优缺点"></a>二、优缺点</h2><p>优点：</p><ul><li>处理高并发场景性能更佳</li><li>适合I&#x2F;O密集型应用，值的是应用在运行极限时，CPU占用率仍然比较低，大部分时间是在做 I&#x2F;O硬盘内存读写操作</li></ul><p>因为<code>Nodejs</code>是单线程，带来的缺点有：</p><ul><li>不适合CPU密集型应用</li><li>只支持单核CPU，不能充分利用CPU</li><li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li></ul><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>借助<code>Nodejs</code>的特点和弊端，其应用场景分类如下：</p><ul><li>善于<code>I/O</code>，不善于计算。因为Nodejs是一个单线程，如果计算（同步）太多，则会阻塞这个线程</li><li>大量并发的I&#x2F;O，应用程序内部并不需要进行非常复杂的处理</li><li>与 websocket 配合，开发长连接的实时交互应用程序</li></ul><p>具体场景可以表现为如下：</p><ul><li>第一大类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的web应用程序</li><li>第二大类：基于web、canvas等多人联网游戏</li><li>第三大类：基于web的多人实时聊天客户端、聊天室、图文直播</li><li>第四大类：单页面浏览器应用程序</li><li>第五大类：操作数据库、为前端和移动端提供基于<code>json</code>的API</li></ul><p>其实，<code>Nodejs</code>能实现几乎一切的应用，只考虑适不适合使用它</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://nodejs.cn/">http://nodejs.cn/</a></li><li><a href="https://segmentfault.com/a/1190000019854308">https://segmentfault.com/a/1190000019854308</a></li><li><a href="https://segmentfault.com/a/1190000005173218">https://segmentfault.com/a/1190000005173218</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?</title>
      <link href="/2023/01/20/nodejs-paging/"/>
      <url>/2023/01/20/nodejs-paging/</url>
      
        <content type="html"><![CDATA[<h1 id="如果让你来设计一个分页功能-你会怎么设计-前后端如何交互"><a href="#如果让你来设计一个分页功能-你会怎么设计-前后端如何交互" class="headerlink" title="如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?"></a>如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>在我们做数据查询的时候，如果数据量很大，比如几万条数据，放在一个页面显示的话显然不友好，这时候就需要采用分页显示的形式，如每次只显示10条数据</p><p><img src="https://static.vue-js.com/6070e8c0-cf14-11eb-85f6-6fac77c0c9b3.png"></p><p>要实现分页功能，实际上就是从结果集中显示第1<del>10条记录作为第1页，显示第11</del>20条记录作为第2页，以此类推</p><p>因此，分页实际上就是从结果集中截取出第M~N条记录</p><h2 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h2><p>前端实现分页功能，需要后端返回必要的数据，如总的页数，总的数据量，当前页，当前的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;totalCount&quot;</span>: <span class="number">1836</span>,   <span class="comment">// 总的条数</span></span><br><span class="line"> <span class="string">&quot;totalPages&quot;</span>: <span class="number">92</span>,  <span class="comment">// 总页数</span></span><br><span class="line"> <span class="string">&quot;currentPage&quot;</span>: <span class="number">1</span>   <span class="comment">// 当前页数</span></span><br><span class="line"> <span class="string">&quot;data&quot;</span>: [     <span class="comment">// 当前页的数据</span></span><br><span class="line">   &#123;</span><br><span class="line"> ...</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>后端采用<code>mysql</code>作为数据的持久性存储</p><p>前端向后端发送目标的页码<code>page</code>以及每页显示数据的数量<code>pageSize</code>，默认情况每次取10条数据，则每一条数据的起始位置<code>start</code>为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = (page - <span class="number">1</span>) * pageSize</span><br></pre></td></tr></table></figure><p>当确定了<code>limit</code>和<code>start</code>的值后，就能够确定<code>SQL</code>语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">`SELECT * FROM record limit <span class="subst">$&#123;pageSize&#125;</span> OFFSET <span class="subst">$&#123;start&#125;</span>;`</span></span><br></pre></td></tr></table></figure><p>上诉<code>SQL</code>语句表达的意思为：截取从<code>start</code>到<code>start</code>+<code>pageSize</code>之间（左闭右开）的数据</p><p>关于查询数据总数的<code>SQL</code>语句为，<code>record</code>为表名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM record</span><br></pre></td></tr></table></figure><p>因此后端的处理逻辑为：</p><ul><li>获取用户参数页码数page和每页显示的数目 pageSize ，其中page 是必须传递的参数，pageSize为可选参数，默认为10</li><li>编写 SQL 语句，利用 limit 和 OFFSET 关键字进行分页查询</li><li>查询数据库，返回总数据量、总页数、当前页、当前页数据给前端</li></ul><p>代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">all</span>(<span class="string">&#x27;/api&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> param = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">method</span> == <span class="string">&quot;POST&quot;</span>) &#123;</span><br><span class="line">    param = req.<span class="property">body</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    param = req.<span class="property">query</span> || req.<span class="property">params</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (param.<span class="property">page</span> == <span class="string">&#x27;&#x27;</span> || param.<span class="property">page</span> == <span class="literal">null</span> || param.<span class="property">page</span> == <span class="literal">undefined</span>) &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">msg</span>: <span class="string">&#x27;请传入参数page&#x27;</span>, <span class="attr">status</span>: <span class="string">&#x27;102&#x27;</span> &#125;));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> pageSize = param.<span class="property">pageSize</span> || <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> start = (param.<span class="property">page</span> - <span class="number">1</span>) * pageSize;</span><br><span class="line">  <span class="keyword">const</span> sql = <span class="string">`SELECT * FROM record limit <span class="subst">$&#123;pageSize&#125;</span> OFFSET <span class="subst">$&#123;start&#125;</span>;`</span></span><br><span class="line">  pool.<span class="title function_">getConnection</span>(<span class="keyword">function</span> (<span class="params">err, connection</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    connection.<span class="title function_">query</span>(sql, <span class="keyword">function</span> (<span class="params">err, results</span>) &#123;</span><br><span class="line">      connection.<span class="title function_">release</span>();</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 计算总页数</span></span><br><span class="line">        <span class="keyword">var</span> allCount = results[<span class="number">0</span>][<span class="number">0</span>][<span class="string">&#x27;COUNT(*)&#x27;</span>];</span><br><span class="line">        <span class="keyword">var</span> allPage = <span class="built_in">parseInt</span>(allCount) / <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">var</span> pageStr = allPage.<span class="title function_">toString</span>();</span><br><span class="line">        <span class="comment">// 不能被整除</span></span><br><span class="line">        <span class="keyword">if</span> (pageStr.<span class="title function_">indexOf</span>(<span class="string">&#x27;.&#x27;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          allPage = <span class="built_in">parseInt</span>(pageStr.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> list = results[<span class="number">1</span>];</span><br><span class="line">        res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">msg</span>: <span class="string">&#x27;操作成功&#x27;</span>, <span class="attr">status</span>: <span class="string">&#x27;200&#x27;</span>, <span class="attr">totalPages</span>: allPage, <span class="attr">currentPage</span>: param.<span class="property">page</span>, <span class="attr">totalCount</span>: allCount, <span class="attr">data</span>: list &#125;));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>通过上面的分析，可以看到分页查询的关键在于，要首先确定每页显示的数量<code>pageSize</code>，然后根据当前页的索引<code>pageIndex</code>（从1开始），确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值：</p><ul><li>LIMIT 总是设定为 pageSize</li><li>OFFSET 计算公式为 pageSize * (pageIndex - 1)</li></ul><p>确定了这两个值，就能查询出第 <code>N</code>页的数据</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1217864791925600">https://www.liaoxuefeng.com/wiki/1177760294764384/1217864791925600</a></li><li><a href="https://vue3js.cn/interview/">https://vue3js.cn/interview/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_paging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node 中的 process 的理解？有哪些常用方法？</title>
      <link href="/2023/01/19/nodejs-process/"/>
      <url>/2023/01/19/nodejs-process/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-中的-process-的理解？有哪些常用方法？"><a href="#Node-中的-process-的理解？有哪些常用方法？" class="headerlink" title="Node 中的 process 的理解？有哪些常用方法？"></a>Node 中的 process 的理解？有哪些常用方法？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>process</code> 对象是一个全局变量，提供了有关当前 <code>Node.js </code>进程的信息并对其进行控制，作为一个全局变量</p><p>我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器</p><p>当我们启动一个<code>js</code>文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享</p><p>由于<code>JavaScript</code>是一个单线程语言，所以通过<code>node xxx</code>启动一个文件后，只有一条主线程</p><h2 id="二、属性与方法"><a href="#二、属性与方法" class="headerlink" title="二、属性与方法"></a>二、属性与方法</h2><p>关于<code>process</code>常见的属性有如下：</p><ul><li>process.env：环境变量，例如通过 &#96;process.env.NODE_ENV 获取不同环境项目配置信息</li><li>process.nextTick：这个在谈及 <code>EventLoop</code> 时经常为会提到</li><li>process.pid：获取当前进程id</li><li>process.ppid：当前进程对应的父进程</li><li>process.cwd()：获取当前进程工作目录，</li><li>process.platform：获取当前进程运行的操作系统平台</li><li>process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值</li><li>进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听</li><li>三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</li><li>process.title 指定进程名称，有的时候需要给进程指定一个名称</li></ul><p>下面再稍微介绍下某些方法的使用：</p><h3 id="process-cwd"><a href="#process-cwd" class="headerlink" title="process.cwd()"></a>process.cwd()</h3><p>返回当前 <code>Node </code>进程执行的目录</p><p>一个<code> Node</code> 模块 <code>A</code> 通过 NPM 发布，项目 <code>B</code> 中使用了模块 <code>A</code>。在 <code>A</code> 中需要操作 <code>B</code> 项目下的文件时，就可以用 <code>process.cwd()</code> 来获取 <code>B</code> 项目的路径</p><h3 id="process-argv"><a href="#process-argv" class="headerlink" title="process.argv"></a>process.argv</h3><p>在终端通过 Node 执行命令的时候，通过 <code>process.argv</code> 可以获取传入的命令行参数，返回值是一个数组：</p><ul><li>0: Node 路径（一般用不到，直接忽略）</li><li>1: 被执行的 JS 文件路径（一般用不到，直接忽略）</li><li>2~n: 真实传入命令的参数</li></ul><p>所以，我们只要从 <code>process.argv[2]</code> 开始获取就好了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> args = process.<span class="property">argv</span>.<span class="title function_">slice</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h3><p>返回一个对象，存储当前环境相关的所有信息，一般很少直接用到。</p><p>一般我们会在 <code>process.env</code> 上挂载一些变量标识当前的环境。比如最常见的用 <code>process.env.NODE_ENV</code> 区分 <code>development</code> 和 <code>production</code></p><p>在 <code>vue-cli</code> 的源码中也经常会看到 <code>process.env.VUE_CLI_DEBUG</code> 标识当前是不是 <code>DEBUG</code> 模式</p><h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h3><p>我们知道<code>NodeJs</code>是基于事件轮询，在这个过程中，同一时间只会处理一件事情</p><p>在这种处理模式下，<code>process.nextTick()</code>就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行</p><p>例如下面例子将一个<code>foo</code>函数在下一个时间点调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br></pre></td></tr></table></figure><p>输出结果为<code>bar</code>、<code>foo</code></p><p>虽然下述方式也能实现同样效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(foo, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br></pre></td></tr></table></figure><p>两者区别在于：</p><ul><li>process.nextTick()会在这一次event loop的call stack清空后（下一次event loop开始前）再调用callback</li><li>setTimeout()是并不知道什么时候call stack清空的，所以何时调用callback函数是不确定的</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="http://nodejs.cn/api/process.html">http://nodejs.cn/api/process.html</a></li><li><a href="https://vue3js.cn/interview/">https://vue3js.cn/interview/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node 文件查找的优先级以及 Require 方法的文件查找策略?</title>
      <link href="/2023/01/18/nodejs-require-order/"/>
      <url>/2023/01/18/nodejs-require-order/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-文件查找的优先级以及-Require-方法的文件查找策略"><a href="#Node-文件查找的优先级以及-Require-方法的文件查找策略" class="headerlink" title="Node 文件查找的优先级以及 Require 方法的文件查找策略?"></a>Node 文件查找的优先级以及 Require 方法的文件查找策略?</h1><h2 id="一、模块规范"><a href="#一、模块规范" class="headerlink" title="一、模块规范"></a>一、模块规范</h2><p><code>NodeJS</code>对<code>CommonJS</code>进行了支持和实现，让我们在开发<code>node</code>的过程中可以方便的进行模块化开发：</p><ul><li>在Node中每一个js文件都是一个单独的模块</li><li>模块中包括CommonJS规范的核心变量：exports、module.exports、require</li><li>通过上述变量进行模块化开发</li></ul><p>而模块化的核心是导出与导入，在<code>Node</code>中通过<code>exports</code>与<code>module.exports</code>负责对模块中的内容进行导出，通过<code>require</code>函数导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</p><h2 id="二、查找策略"><a href="#二、查找策略" class="headerlink" title="二、查找策略"></a>二、查找策略</h2><p><code>require</code>方法接收一下几种参数的传递：</p><ul><li>原生模块：http、fs、path等</li><li>相对路径的文件模块：.&#x2F;mod或..&#x2F;mod</li><li>绝对路径的文件模块：&#x2F;pathtomodule&#x2F;mod</li><li>目录作为模块：.&#x2F;dirname</li><li>非原生模块的文件模块：mod</li></ul><p><code>require</code>参数较为简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同，如下图：</p><p> <img src="https://static.vue-js.com/33ae8ef0-c9ba-11eb-85f6-6fac77c0c9b3.png"></p><p>从上图可以看见，文件模块存在缓存区，寻找模块路径的时候都会优先从缓存中加载已经存在的模块</p><h3 id="原生模块"><a href="#原生模块" class="headerlink" title="原生模块"></a>原生模块</h3><p>而像原生模块这些，通过<code>require </code>方法在解析文件名之后，优先检查模块是否在原生模块列表中，如果在则从原生模块中加载</p><h3 id="绝对路径、相对路径"><a href="#绝对路径、相对路径" class="headerlink" title="绝对路径、相对路径"></a>绝对路径、相对路径</h3><p>如果<code>require</code>绝对路径的文件，则直接查找对应的路径，速度最快</p><p>相对路径的模块则相对于当前调用<code>require</code>的文件去查找</p><p>如果按确切的文件名没有找到模块，则 <code>NodeJs</code> 会尝试带上 <code>.js</code>、<code>.json </code>或 <code>.node </code>拓展名再加载</p><h3 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h3><p>默认情况是根据根目录中<code>package.json</code>文件的<code>main</code>来指定目录模块，如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;some-library&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;main.js&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果这是在<code>./some-library node_modules</code>目录中，则 <code>require(&#39;./some-library&#39;)</code> 会试图加载 <code>./some-library/main.js</code></p><p>如果目录里没有 <code>package.json</code>文件，或者 <code>main</code>入口不存在或无法解析，则会试图加载目录下的 <code>index.js</code> 或 <code>index.node</code> 文件</p><h3 id="非原生模块"><a href="#非原生模块" class="headerlink" title="非原生模块"></a>非原生模块</h3><p>在每个文件中都存在<code>module.paths</code>，表示模块的搜索路径，<code>require</code>就是根据其来寻找文件</p><p>在<code>window</code>下输出如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">&#x27;c:\\nodejs\\node_modules&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;c:\\node_modules&#x27;</span> ]</span><br></pre></td></tr></table></figure><p>可以看出<code>module path</code>的生成规则为：从当前文件目录开始查找<code>node_modules</code>目录；然后依次进入父目录，查找父目录下的<code>node_modules</code>目录，依次迭代，直到根目录下的<code>node_modules</code>目录</p><p>当都找不到的时候，则会从系统<code>NODE_PATH</code>环境变量查找</p><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>如果在<code>/home/ry/projects/foo.js</code>文件里调用了 <code>require(&#39;bar.js&#39;)</code>，则 Node.js 会按以下顺序查找：</p><ul><li>&#x2F;home&#x2F;ry&#x2F;projects&#x2F;node_modules&#x2F;bar.js</li><li>&#x2F;home&#x2F;ry&#x2F;node_modules&#x2F;bar.js</li><li>&#x2F;home&#x2F;node_modules&#x2F;bar.js</li><li>&#x2F;node_modules&#x2F;bar.js</li></ul><p>这使得程序本地化它们的依赖，避免它们产生冲突</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>通过上面模块的文件查找策略之后，总结下文件查找的优先级：</p><ul><li><p>缓存的模块优先级最高</p></li><li><p>如果是内置模块，则直接返回，优先级仅次缓存的模块</p></li><li><p>如果是绝对路径 &#x2F; 开头，则从根目录找</p></li><li><p>如果是相对路径 .&#x2F;开头，则从当前require文件相对位置找</p></li><li><p>如果文件没有携带后缀，先从js、json、node按顺序查找</p></li><li><p>如果是目录，则根据 package.json的main属性值决定目录下入口文件，默认情况为 index.js</p></li><li><p>如果文件为第三方模块，则会引入 node_modules 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://nodejs.cn/api/modules.html#modules_file_modules">http://nodejs.cn/api/modules.html#modules_file_modules</a></li><li><a href="https://blog.csdn.net/qq_36801250/article/details/106352686">https://blog.csdn.net/qq_36801250/article/details/106352686</a></li><li><a href="https://www.cnblogs.com/samve/p/10805908.html">https://www.cnblogs.com/samve/p/10805908.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_require_order </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说对中间件概念的理解，如何封装 node 中间件？</title>
      <link href="/2023/01/17/nodejs-middleware/"/>
      <url>/2023/01/17/nodejs-middleware/</url>
      
        <content type="html"><![CDATA[<h1 id="说说对中间件概念的理解，如何封装-node-中间件？"><a href="#说说对中间件概念的理解，如何封装-node-中间件？" class="headerlink" title="说说对中间件概念的理解，如何封装 node 中间件？"></a>说说对中间件概念的理解，如何封装 node 中间件？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的</p><p>在<code>NodeJS</code>中，中间件主要是指封装<code>http</code>请求细节处理的方法</p><p>例如在<code>express</code>、<code>koa</code>等<code>web</code>框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数</p><p> <img src="https://static.vue-js.com/6a6ed3f0-cce4-11eb-85f6-6fac77c0c9b3.png"></p><p>在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作</p><h2 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h2><p><code>koa</code>是基于<code>NodeJS</code>当前比较流行的<code>web</code>框架，本身支持的功能并不多，功能都可以通过中间件拓展实现。通过添加不同的中间件，实现不同的需求，从而构建一个 <code>Koa</code> 应用</p><p><code>Koa</code> 中间件采用的是洋葱圈模型，每次执行下一个中间件传入两个参数：</p><ul><li>ctx ：封装了request 和  response 的变量</li><li>next ：进入下一个要执行的中间件的函数</li></ul><p> <img src="https://static.vue-js.com/7507b020-cce4-11eb-ab90-d9ae814b240d.png"></p><p>下面就针对<code>koa</code>进行中间件的封装：</p><p><code>Koa </code>的中间件就是函数，可以是<code> async</code> 函数，或是普通函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async 函数</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">next</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ms = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面则通过中间件封装<code>http</code>请求过程中几个常用的功能：</p><h3 id="token校验"><a href="#token校验" class="headerlink" title="token校验"></a>token校验</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">options</span>) =&gt;</span> <span class="keyword">async</span> (ctx, next) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 token</span></span><br><span class="line">    <span class="keyword">const</span> token = ctx.<span class="property">header</span>.<span class="property">authorization</span></span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// verify 函数验证 token，并获取用户相关信息</span></span><br><span class="line">          <span class="keyword">await</span> <span class="title function_">verify</span>(token)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入下一个中间件</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">options</span>) =&gt;</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">  <span class="keyword">const</span> requestTime = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="title class_">Date</span>.<span class="title function_">now</span>() - startTime;</span><br><span class="line">  <span class="keyword">let</span> logout = <span class="string">`<span class="subst">$&#123;ctx.request.ip&#125;</span> -- <span class="subst">$&#123;requestTime&#125;</span> -- <span class="subst">$&#123;ctx.method&#125;</span> -- <span class="subst">$&#123;ctx.url&#125;</span> -- <span class="subst">$&#123;ms&#125;</span>ms`</span>;</span><br><span class="line">  <span class="comment">// 输出日志文件</span></span><br><span class="line">  fs.<span class="title function_">appendFileSync</span>(<span class="string">&#x27;./log.txt&#x27;</span>, logout + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Koa</code>存在很多第三方的中间件，如<code>koa-bodyparser</code>、<code>koa-static</code>等</p><p>下面再来看看它们的大体的简单实现：</p><h3 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a>koa-bodyparser</h3><p><code>koa-bodyparser</code> 中间件是将我们的 <code>post</code> 请求和表单提交的查询字符串转换成对象，并挂在 <code>ctx.request.body</code> 上，方便我们在其他中间件或接口处取值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：my-koa-bodyparser.js</span></span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">&quot;querystring&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">bodyParser</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 存储数据的数组</span></span><br><span class="line">            <span class="keyword">let</span> dataArr = [];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收数据</span></span><br><span class="line">            ctx.<span class="property">req</span>.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">data</span> =&gt;</span> dataArr.<span class="title function_">push</span>(data));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 整合数据并使用 Promise 成功</span></span><br><span class="line">            ctx.<span class="property">req</span>.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求数据的类型 json 或表单</span></span><br><span class="line">                <span class="keyword">let</span> contentType = ctx.<span class="title function_">get</span>(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取数据 Buffer 格式</span></span><br><span class="line">                <span class="keyword">let</span> data = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(dataArr).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (contentType === <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body</span></span><br><span class="line">                    ctx.<span class="property">request</span>.<span class="property">body</span> = querystring.<span class="title function_">parse</span>(data);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contentType === <span class="string">&quot;applaction/json&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body</span></span><br><span class="line">                    ctx.<span class="property">request</span>.<span class="property">body</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行成功的回调</span></span><br><span class="line">                <span class="title function_">resolve</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续向下执行</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="koa-static"><a href="#koa-static" class="headerlink" title="koa-static"></a>koa-static</h3><p> <code>koa-static</code> 中间件的作用是在服务器接到请求时，帮我们处理静态文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">&quot;mime&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">&quot;util&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 stat 和 access 转换成 Promise</span></span><br><span class="line"><span class="keyword">const</span> stat = <span class="title function_">promisify</span>(fs.<span class="property">stat</span>);</span><br><span class="line"><span class="keyword">const</span> access = <span class="title function_">promisify</span>(fs.<span class="property">access</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">dir</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 /</span></span><br><span class="line">        <span class="keyword">let</span> realPath = path.<span class="title function_">join</span>(dir, ctx.<span class="property">path</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 stat 对象</span></span><br><span class="line">            <span class="keyword">let</span> statObj = <span class="keyword">await</span> <span class="title function_">stat</span>(realPath);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html</span></span><br><span class="line">            <span class="keyword">if</span> (statObj.<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">                ctx.<span class="title function_">set</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">`<span class="subst">$&#123;mime.getType()&#125;</span>;charset=utf8`</span>);</span><br><span class="line">                ctx.<span class="property">body</span> = fs.<span class="title function_">createReadStream</span>(realPath);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> filename = path.<span class="title function_">join</span>(realPath, <span class="string">&quot;index.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理</span></span><br><span class="line">                <span class="keyword">await</span> <span class="title function_">access</span>(filename);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 存在设置文件类型并响应内容</span></span><br><span class="line">                ctx.<span class="title function_">set</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=utf8&quot;</span>);</span><br><span class="line">                ctx.<span class="property">body</span> = fs.<span class="title function_">createReadStream</span>(filename);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据</p><p><code>koa</code>本身比较简洁，但是通过中间件的机制能够实现各种所需要的功能，使得<code>web</code>应用具备良好的可拓展性和组合性</p><p>通过将公共逻辑的处理编写在中间件中，可以不用在每一个接口回调中做相同的代码编写，减少了冗杂代码，过程就如装饰者模式</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000017897279">https://segmentfault.com/a/1190000017897279</a></li><li><a href="https://www.jianshu.com/p/81b6ebc0dd85">https://www.jianshu.com/p/81b6ebc0dd85</a></li><li><a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6">https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_middleware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现jwt鉴权机制？</title>
      <link href="/2023/01/13/nodejs-jwt/"/>
      <url>/2023/01/13/nodejs-jwt/</url>
      
        <content type="html"><![CDATA[<h1 id="如何实现jwt鉴权机制？"><a href="#如何实现jwt鉴权机制？" class="headerlink" title="如何实现jwt鉴权机制？"></a>如何实现jwt鉴权机制？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>JWT（JSON Web Token），本质就是一个字符串书写规范，如下图，作用是用来在用户和服务器之间传递安全可靠的信息</p><p><img src="https://static.vue-js.com/052904c0-cd89-11eb-ab90-d9ae814b240d.png"></p><p>在目前前后端分离的开发过程中，使用<code>token</code>鉴权机制用于身份验证是最常见的方案，流程如下：</p><ul><li>服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证</li><li>后续访问会根据这个令牌判断用户时候有权限进行访问</li></ul><p><code>Token</code>，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以<code>.</code>进行拼接。其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码</p><p> <img src="https://static.vue-js.com/1175f990-cd89-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>每个JWT都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为<code>alg</code>，同时还有一个<code>typ</code>的字段，默认<code>JWT</code>即可。以下示例中算法为HS256</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span> <span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>因为JWT是字符串，所以我们还需要对以上内容进行Base64编码，编码后字符串如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9        </span><br></pre></td></tr></table></figure><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>载荷即消息体，这里会存放实际的内容，也就是<code>Token</code>的数据声明，例如用户的<code>id</code>和<code>name</code>，默认情况下也会携带令牌的签发时间<code>iat</code>，通过还可以设置过期时间，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1516239022</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>同样进行Base64编码后，字符串如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ</span><br></pre></td></tr></table></figure><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>签名是对头部和载荷内容进行签名，一般情况，设置一个<code>secretKey</code>，对前两个的结果进行<code>HMACSHA25</code>算法，公式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Signature</span> = <span class="title class_">HMACSHA256</span>(<span class="title function_">base64Url</span>(header)+.+<span class="title function_">base64Url</span>(payload),secretKey)</span><br></pre></td></tr></table></figure><p>一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致</p><h2 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h2><p><code>Token</code>的使用分成了两部分：</p><ul><li>生成token：登录成功的时候，颁发token</li><li>验证token：访问某些资源或者接口时，验证token</li></ul><h3 id="生成-token"><a href="#生成-token" class="headerlink" title="生成 token"></a>生成 token</h3><p>借助第三方库<code>jsonwebtoken</code>，通过<code>jsonwebtoken</code> 的 <code>sign</code> 方法生成一个 <code>token</code>：</p><ul><li><p>第一个参数指的是 Payload</p></li><li><p>第二个是秘钥，服务端特有</p></li><li><p>第三个参数是 option，可以定义 token 过期时间</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>),</span><br><span class="line">  jwt = <span class="built_in">require</span>(<span class="string">&quot;jsonwebtoken&quot;</span>);</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span>使用数据库</span></span><br><span class="line"><span class="comment">// 这里应该是用数据库存储，这里只是演示用</span></span><br><span class="line"><span class="keyword">let</span> userList = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="comment">// 用户登录</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">login</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">    <span class="keyword">if</span> (!data.<span class="property">name</span> || !data.<span class="property">password</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ctx.<span class="property">body</span> = &#123;</span><br><span class="line">        <span class="attr">code</span>: <span class="string">&quot;000002&quot;</span>, </span><br><span class="line">        <span class="attr">message</span>: <span class="string">&quot;参数不合法&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = userList.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">name</span> === data.<span class="property">name</span> &amp;&amp; item.<span class="property">password</span> === crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;md5&#x27;</span>).<span class="title function_">update</span>(data.<span class="property">password</span>).<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      <span class="comment">// 生成token</span></span><br><span class="line">      <span class="keyword">const</span> token = jwt.<span class="title function_">sign</span>(  </span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">name</span>: result.<span class="property">name</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;test_token&quot;</span>, <span class="comment">// secret</span></span><br><span class="line">        &#123; <span class="attr">expiresIn</span>: <span class="number">60</span> * <span class="number">60</span> &#125; <span class="comment">// 过期时间：60 * 60 s</span></span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> ctx.<span class="property">body</span> = &#123;</span><br><span class="line">        <span class="attr">code</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&quot;登录成功&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">          token</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ctx.<span class="property">body</span> = &#123;</span><br><span class="line">        <span class="attr">code</span>: <span class="string">&quot;000002&quot;</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&quot;用户名或密码错误&quot;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">UserController</span>;</span><br></pre></td></tr></table></figure><p>在前端接收到<code>token</code>后，一般情况会通过<code>localStorage</code>进行缓存，然后将<code>token</code>放到<code>HTTP </code>请求头<code>Authorization</code> 中，关于<code>Authorization</code> 的设置，前面要加上 Bearer ，注意后面带有空格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">  config.<span class="property">headers</span>.<span class="property">common</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;Bearer &#x27;</span> + token; <span class="comment">// 留意这里的 Authorization</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="校验token"><a href="#校验token" class="headerlink" title="校验token"></a>校验token</h3><p>使用 <code>koa-jwt</code> 中间件进行验证，方式比较简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ 注意：放在路由前面</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">koajwt</span>(&#123;</span><br><span class="line">  <span class="attr">secret</span>: <span class="string">&#x27;test_token&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">unless</span>(&#123; <span class="comment">// 配置白名单</span></span><br><span class="line">  <span class="attr">path</span>: [<span class="regexp">/\/api\/register/</span>, <span class="regexp">/\/api\/login/</span>]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ul><li>secret 必须和 sign 时候保持一致</li><li>可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆&#x2F;注册都可以不用校验</li><li>校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验</li></ul><p>获取<code>token</code>用户的信息方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/api/userInfo&#x27;</span>,<span class="keyword">async</span> (ctx,next) =&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> authorization =  ctx.<span class="property">header</span>.<span class="property">authorization</span> <span class="comment">// 获取jwt</span></span><br><span class="line">    <span class="keyword">const</span> token = authorization.<span class="title function_">replace</span>(<span class="string">&#x27;Beraer &#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> result = jwt.<span class="title function_">verify</span>(token,<span class="string">&#x27;test_token&#x27;</span>)</span><br><span class="line">    ctx.<span class="property">body</span> = result</span><br></pre></td></tr></table></figure><p>注意：上述的<code>HMA256</code>加密算法为单秘钥的形式，一旦泄露后果非常的危险</p><p>在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌</p><p>这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择<code>RS256</code></p><h2 id="三、优缺点"><a href="#三、优缺点" class="headerlink" title="三、优缺点"></a>三、优缺点</h2><p>优点：</p><ul><li>json具有通用性，所以可以跨语言</li><li>组成简单，字节占用小，便于传输</li><li>服务端无需保存会话信息，很容易进行水平扩展</li><li>一处生成，多处使用，可以在分布式系统中，解决单点登录问题</li><li>可防护CSRF攻击</li></ul><p>缺点：</p><ul><li>payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息</li><li>需要保护好加密密钥，一旦泄露后果不堪设想</li><li>为避免token被劫持，最好使用https协议</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></li><li><a href="https://blog.wangjunfeng.com/post/golang-jwt/">https://blog.wangjunfeng.com/post/golang-jwt/</a></li><li><a href="https://vue3js.cn/interview/">https://vue3js.cn/interview/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node. js 有哪些全局对象？</title>
      <link href="/2023/01/11/nodejs-global/"/>
      <url>/2023/01/11/nodejs-global/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js-有哪些全局对象？"><a href="#Node-js-有哪些全局对象？" class="headerlink" title="Node. js 有哪些全局对象？"></a>Node. js 有哪些全局对象？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>在浏览器 <code>JavaScript</code> 中，通常<code> window</code> 是全局对象， 而 <code>Nodejs </code>中的全局对象是 <code>global</code></p><p>在<code>NodeJS</code>里，是不可能在最外层定义一个变量，因为所有的用户代码都是当前模块的，只在当前模块里可用，但可以通过<code>exports</code>对象的使用将其传递给模块外部</p><p>所以，在<code>NodeJS</code>中，用<code>var</code>声明的变量并不属于全局的变量，只在当前模块生效</p><p>像上述的<code>global</code>全局对象则在全局作用域中，任何全局变量、函数、对象都是该对象的一个属性值</p><h2 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h2><p>将全局对象分成两类：</p><ul><li><p>真正的全局对象</p></li><li><p>模块级别的全局变量</p></li></ul><h3 id="真正的全局对象"><a href="#真正的全局对象" class="headerlink" title="真正的全局对象"></a>真正的全局对象</h3><p>下面给出一些常见的全局对象：</p><ul><li><p>Class:Buffer</p></li><li><p>process</p></li><li><p>console</p></li><li><p>clearInterval、setInterval</p></li><li><p>clearTimeout、setTimeout</p></li><li><p>global</p></li></ul><h4 id="Class-Buffer"><a href="#Class-Buffer" class="headerlink" title="Class:Buffer"></a>Class:Buffer</h4><p>可以处理二进制以及非<code>Unicode</code>编码的数据</p><p>在<code>Buffer</code>类实例化中存储了原始数据。<code>Buffer</code>类似于一个整数数组，在V8堆原始存储空间给它分配了内存</p><p>一旦创建了<code>Buffer</code>实例，则无法改变大小</p><h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>进程对象，提供有关当前进程的信息和控制</p><p>包括在执行<code>node</code>程序进程时，如果需要传递参数，我们想要获取这个参数需要在<code>process</code>内置对象中</p><p>启动进程：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js 参数<span class="number">1</span> 参数<span class="number">2</span> 参数<span class="number">3</span></span><br></pre></td></tr></table></figure><p>index.js文件如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="property">argv</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;index&#125;</span>: <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/node</span><br><span class="line">/<span class="title class_">Users</span>/mjr/work/node/process-args.<span class="property">js</span></span><br><span class="line">参数<span class="number">1</span></span><br><span class="line">参数<span class="number">2</span></span><br><span class="line">参数<span class="number">3</span></span><br></pre></td></tr></table></figure><p>除此之外，还包括一些其他信息如版本、操作系统等</p><p><img src="https://static.vue-js.com/85f473a0-c2a3-11eb-ab90-d9ae814b240d.png"></p><h4 id="console"><a href="#console" class="headerlink" title="console"></a>console</h4><p>用来打印<code>stdout</code>和<code>stderr</code></p><p>最常用的输入内容的方式：console.log</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>清空控制台：console.clear</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="property">clear</span></span><br></pre></td></tr></table></figure><p>打印函数的调用栈：console.trace</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">trace</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure><p> <img src="https://static.vue-js.com/91b6dbb0-c2a3-11eb-85f6-6fac77c0c9b3.png"></p><h4 id="clearInterval、setInterval"><a href="#clearInterval、setInterval" class="headerlink" title="clearInterval、setInterval"></a>clearInterval、setInterval</h4><p>设置定时器与清除定时器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(callback, delay[, ...args])</span><br></pre></td></tr></table></figure><p><code>callback</code>每<code>delay</code>毫秒重复执行一次</p><p><code>clearInterval</code>则为对应发取消定时器的方法</p><h4 id="clearTimeout、setTimeout"><a href="#clearTimeout、setTimeout" class="headerlink" title="clearTimeout、setTimeout"></a>clearTimeout、setTimeout</h4><p>设置延时器与清除延时器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(callback,delay[,...args])</span><br></pre></td></tr></table></figure><p><code>callback</code>在<code>delay</code>毫秒后执行一次</p><p><code>clearTimeout</code>则为对应取消延时器的方法</p><h4 id="global"><a href="#global" class="headerlink" title="global"></a>global</h4><p>全局命名空间对象，墙面讲到的<code>process</code>、<code>console</code>、<code>setTimeout</code>等都有放到<code>global</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(process === <span class="variable language_">global</span>.<span class="property">process</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="模块级别的全局对象"><a href="#模块级别的全局对象" class="headerlink" title="模块级别的全局对象"></a>模块级别的全局对象</h3><p>这些全局对象是模块中的变量，只是每个模块都有，看起来就像全局变量，像在命令交互中是不可以使用，包括：</p><ul><li>__dirname</li><li>__filename</li><li>exports</li><li>module</li><li>require</li></ul><h4 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h4><p>获取当前文件所在的路径，不包括后面的文件名</p><p>从 <code>/Users/mjr</code> 运行 <code>node example.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(__dirname);</span><br><span class="line"><span class="comment">// 打印: /Users/mjr</span></span><br></pre></td></tr></table></figure><h4 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h4><p>获取当前文件所在的路径和文件名称，包括后面的文件名称</p><p>从 <code>/Users/mjr</code> 运行 <code>node example.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(__filename);</span><br><span class="line"><span class="comment">// 打印: /Users/mjr/example.js</span></span><br></pre></td></tr></table></figure><h4 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h4><p><code>module.exports</code> 用于指定一个模块所导出的内容，即可以通过 <code>require()</code> 访问的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">name</span> = name;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">age</span> = age;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">sayHello</span> = sayHello;</span><br></pre></td></tr></table></figure><h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>对当前模块的引用，通过<code>module.exports</code> 用于指定一个模块所导出的内容，即可以通过 <code>require()</code> 访问的内容</p><h4 id="require"><a href="#require" class="headerlink" title="require"></a>require</h4><p>用于引入模块、 <code>JSON</code>、或本地文件。 可以从 <code>node_modules</code> 引入模块。</p><p>可以使用相对路径引入本地模块或<code>JSON</code>文件，路径会根据<code>__dirname</code>定义的目录名或当前工作目录进行处理</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://nodejs.cn/api/globals.html">http://nodejs.cn/api/globals.html</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_global </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node 中的 fs模块的理解? 有哪些常用方法</title>
      <link href="/2023/01/06/nodejs-fs/"/>
      <url>/2023/01/06/nodejs-fs/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-中的-fs模块的理解-有哪些常用方法"><a href="#Node-中的-fs模块的理解-有哪些常用方法" class="headerlink" title="Node 中的 fs模块的理解? 有哪些常用方法"></a>Node 中的 fs模块的理解? 有哪些常用方法</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>fs（filesystem），该模块提供本地文件的读写能力，基本上是<code>POSIX</code>文件操作命令的简单包装</p><p>可以说，所有与文件的操作都是通过<code>fs</code>核心模块实现</p><p>导入模块如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这个模块对所有文件系统操作提供异步（不具有<code>sync</code> 后缀）和同步（具有 <code>sync</code> 后缀）两种操作方式，而供开发者选择</p><h3 id="二、文件知识"><a href="#二、文件知识" class="headerlink" title="二、文件知识"></a>二、文件知识</h3><p>在计算机中有关于文件的知识：</p><ul><li>权限位 mode</li><li>标识位 flag</li><li>文件描述为 fd</li></ul><h3 id="权限位-mode"><a href="#权限位-mode" class="headerlink" title="权限位 mode"></a>权限位 mode</h3><p> <img src="https://static.vue-js.com/4f4d41a0-c46b-11eb-ab90-d9ae814b240d.png"></p><p>针对文件所有者、文件所属组、其他用户进行权限分配，其中类型又分成读、写和执行，具备权限位4、2、1，不具备权限为0</p><p>如在<code>linux</code>查看文件权限位：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x <span class="number">1</span> <span class="title class_">PandaShen</span> <span class="number">197121</span> <span class="number">0</span> <span class="title class_">Jun</span> <span class="number">28</span> <span class="number">14</span>:<span class="number">41</span> core</span><br><span class="line">-rw-r--r-- <span class="number">1</span> <span class="title class_">PandaShen</span> <span class="number">197121</span> <span class="number">293</span> <span class="title class_">Jun</span> <span class="number">23</span> <span class="number">17</span>:<span class="number">44</span> index.<span class="property">md</span></span><br></pre></td></tr></table></figure><p>在开头前十位中，<code>d</code>为文件夹，<code>-</code>为文件，后九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限</p><h3 id="标识位"><a href="#标识位" class="headerlink" title="标识位"></a>标识位</h3><p>标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，如下表所示：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>读取文件，如果文件不存在则抛出异常。</td></tr><tr><td>r+</td><td>读取并写入文件，如果文件不存在则抛出异常。</td></tr><tr><td>rs</td><td>读取并写入文件，指示操作系统绕开本地文件系统缓存。</td></tr><tr><td>w</td><td>写入文件，文件不存在会被创建，存在则清空后写入。</td></tr><tr><td>wx</td><td>写入文件，排它方式打开。</td></tr><tr><td>w+</td><td>读取并写入文件，文件不存在则创建文件，存在则清空后写入。</td></tr><tr><td>wx+</td><td>和 w+ 类似，排他方式打开。</td></tr><tr><td>a</td><td>追加写入，文件不存在则创建文件。</td></tr><tr><td>ax</td><td>与 a 类似，排他方式打开。</td></tr><tr><td>a+</td><td>读取并追加写入，不存在则创建。</td></tr><tr><td>ax+</td><td>与 a+ 类似，排他方式打开。</td></tr></tbody></table><h3 id="文件描述为-fd"><a href="#文件描述为-fd" class="headerlink" title="文件描述为 fd"></a>文件描述为 fd</h3><p>操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件</p><p><code>Window </code>系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，<code>NodeJS </code>抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符</p><p>在 <code>NodeJS </code>中，每操作一个文件，文件描述符是递增的，文件描述符一般从 <code>3</code> 开始，因为前面有 <code>0</code>、<code>1</code>、<code>2</code>三个比较特殊的描述符，分别代表 <code>process.stdin</code>（标准输入）、<code>process.stdout</code>（标准输出）和 <code>process.stderr</code>（错误输出）</p><h2 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h2><p>下面针对<code>fs</code>模块常用的方法进行展开：</p><ul><li>文件读取</li><li>文件写入</li><li>文件追加写入</li><li>文件拷贝</li><li>创建目录</li></ul><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><h4 id="fs-readFileSync"><a href="#fs-readFileSync" class="headerlink" title="fs.readFileSync"></a>fs.readFileSync</h4><p>同步读取，参数如下：</p><ul><li>第一个参数为读取文件的路径或文件描述符</li><li>第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding</li></ul><p>结果为返回文件的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf); <span class="comment">// &lt;Buffer 48 65 6c 6c 6f&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><h4 id="fs-readFile"><a href="#fs-readFile" class="headerlink" title="fs.readFile"></a>fs.readFile</h4><p>异步读取方法 <code>readFile</code> 与 <code>readFileSync</code> 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 <code>err</code>（错误）和 <code>data</code>（数据），该方法没有返回值，回调函数在读取文件成功后执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// Hello</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><h4 id="writeFileSync"><a href="#writeFileSync" class="headerlink" title="writeFileSync"></a>writeFileSync</h4><p>同步写入，有三个参数：</p><ul><li><p>第一个参数为写入文件的路径或文件描述符</p></li><li><p>第二个参数为写入的数据，类型为 String 或 Buffer</p></li><li><p>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&quot;2.txt&quot;</span>, <span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;2.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// Hello world</span></span><br></pre></td></tr></table></figure><h4 id="writeFile"><a href="#writeFile" class="headerlink" title="writeFile"></a>writeFile</h4><p>异步写入，<code>writeFile</code> 与 <code>writeFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件写入数据成功后执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&quot;2.txt&quot;</span>, <span class="string">&quot;Hello world&quot;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&quot;2.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// Hello world</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="文件追加写入"><a href="#文件追加写入" class="headerlink" title="文件追加写入"></a>文件追加写入</h3><h4 id="appendFileSync"><a href="#appendFileSync" class="headerlink" title="appendFileSync"></a>appendFileSync</h4><p>参数如下：</p><ul><li>第一个参数为写入文件的路径或文件描述符</li><li>第二个参数为写入的数据，类型为 String 或 Buffer</li><li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">appendFileSync</span>(<span class="string">&quot;3.txt&quot;</span>, <span class="string">&quot; world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;3.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="appendFile"><a href="#appendFile" class="headerlink" title="appendFile"></a>appendFile</h4><p>异步追加写入方法 <code>appendFile</code> 与 <code>appendFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件追加写入数据成功后执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&quot;3.txt&quot;</span>, <span class="string">&quot; world&quot;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&quot;3.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// Hello world</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><h4 id="copyFileSync"><a href="#copyFileSync" class="headerlink" title="copyFileSync"></a>copyFileSync</h4><p>同步拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">copyFileSync</span>(<span class="string">&quot;3.txt&quot;</span>, <span class="string">&quot;4.txt&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;4.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// Hello world</span></span><br></pre></td></tr></table></figure><h4 id="copyFile"><a href="#copyFile" class="headerlink" title="copyFile"></a>copyFile</h4><p>异步拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">copyFile</span>(<span class="string">&quot;3.txt&quot;</span>, <span class="string">&quot;4.txt&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&quot;4.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// Hello world</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><h4 id="mkdirSync"><a href="#mkdirSync" class="headerlink" title="mkdirSync"></a>mkdirSync</h4><p>同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设已经有了 a 文件夹和 a 下的 b 文件夹</span></span><br><span class="line">fs.<span class="title function_">mkdirSync</span>(<span class="string">&quot;a/b/c&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>异步创建，第二个参数为回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&quot;a/b/c&quot;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!err) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p></li><li><p><a href="https://segmentfault.com/a/1190000019913303">https://segmentfault.com/a/1190000019913303</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_fs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现文件上传？说说你的思路</title>
      <link href="/2023/01/05/nodejs-file-upload/"/>
      <url>/2023/01/05/nodejs-file-upload/</url>
      
        <content type="html"><![CDATA[<h1 id="如何实现文件上传？说说你的思路"><a href="#如何实现文件上传？说说你的思路" class="headerlink" title="如何实现文件上传？说说你的思路"></a>如何实现文件上传？说说你的思路</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>文件上传在日常开发中应用很广泛，我们发微博、发微信朋友圈都会用到了图片上传功能</p><p>因为浏览器限制，浏览器不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请求操作，将内存里的文件内容数据上传到服务端，服务端解析前端传来的数据信息后存入文件里</p><p>对于文件上传，我们需要设置请求头为<code>content-type:multipart/form-data</code></p><blockquote><p>multipart互联网上的混合资源，就是资源由多种元素组成，form-data表示可以使用HTML Forms 和 POST 方法上传文件</p></blockquote><p>结构如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/t2/upload.do</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>SOHUWapRebot</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-cn,zh;q=0.5</span><br><span class="line"><span class="attribute">Accept-Charset</span><span class="punctuation">: </span>GBK,utf-8;q=0.7,*;q=0.7</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>60408</span><br><span class="line">Content-Type:multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>w.sohu.com</span><br><span class="line"></span><br><span class="line"><span class="language-fortran">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span></span><br><span class="line"><span class="language-fortran">Content-Disposition: <span class="keyword">form</span>-<span class="keyword">data</span>; <span class="keyword">name</span>=<span class="string">&quot;city&quot;</span></span></span><br><span class="line"><span class="language-fortran"></span></span><br><span class="line"><span class="language-fortran">Santa colo</span></span><br><span class="line"><span class="language-fortran">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span></span><br><span class="line"><span class="language-fortran">Content-Disposition: <span class="keyword">form</span>-<span class="keyword">data</span>;<span class="keyword">name</span>=<span class="string">&quot;desc&quot;</span></span></span><br><span class="line"><span class="language-fortran">Content-<span class="keyword">Type</span>: text/plain; charset=UTF-<span class="number">8</span></span></span><br><span class="line"><span class="language-fortran">Content-<span class="built_in">Transfer</span>-Encoding: <span class="number">8</span>bit</span></span><br><span class="line"><span class="language-fortran"> </span></span><br><span class="line"><span class="language-fortran">...</span></span><br><span class="line"><span class="language-fortran">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span></span><br><span class="line"><span class="language-fortran">Content-Disposition: <span class="keyword">form</span>-<span class="keyword">data</span>;<span class="keyword">name</span>=<span class="string">&quot;pic&quot;</span>; filename=<span class="string">&quot;photo.jpg&quot;</span></span></span><br><span class="line"><span class="language-fortran">Content-<span class="keyword">Type</span>: application/octet-stream</span></span><br><span class="line"><span class="language-fortran">Content-<span class="built_in">Transfer</span>-Encoding: binary</span></span><br><span class="line"><span class="language-fortran"> </span></span><br><span class="line"><span class="language-fortran">... binary <span class="keyword">data</span> of the jpg ...</span></span><br><span class="line"><span class="language-fortran">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC--</span></span><br></pre></td></tr></table></figure><p><code>boundary</code>表示分隔符，如果要上传多个表单项，就要使用<code>boundary</code>分割，每个表单项由<code>———XXX</code>开始，以<code>———XXX</code>结尾</p><p>而<code>xxx</code>是即时生成的字符串，用以确保整个分隔符不会在文件或表单项的内容中出现</p><p>每个表单项必须包含一个 <code>Content-Disposition</code> 头，其他的头信息则为可选项， 比如 <code>Content-Type</code> </p><p><code>Content-Disposition</code> 包含了 <code>type </code>和 一个名字为<code>name</code>的 <code>parameter</code>，<code>type</code> 是 <code>form-data</code>，<code>name </code>参数的值则为表单控件（也即 field）的名字，如果是文件，那么还有一个 <code>filename </code>参数，值就是文件名</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-<span class="keyword">data</span>; name=<span class="string">&quot;user&quot;</span>; filename=<span class="string">&quot;logo.png&quot;</span></span><br></pre></td></tr></table></figure><p>至于使用<code>multipart/form-data</code>，是因为文件是以二进制的形式存在，其作用是专门用于传输大型二进制数据，效率高</p><h3 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h3><p>关于文件的上传的上传，我们可以分成两步骤：</p><ul><li>文件的上传</li><li>文件的解析</li></ul><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>传统前端文件上传的表单结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080/api/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">multiple</span>=<span class="string">&quot;multiple&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>action</code> 就是我们的提交到的接口，<code>enctype=&quot;multipart/form-data&quot;</code> 就是指定上传文件格式，<code>input</code> 的 <code>name</code> 属性一定要等于<code>file</code></p><h3 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h3><p>在服务器中，这里采用<code>koa2</code>中间件的形式解析上传的文件数据，分别有下面两种形式：</p><ul><li>koa-body</li><li>koa-multer</li></ul><h4 id="koa-body"><a href="#koa-body" class="headerlink" title="koa-body"></a>koa-body</h4><p>安装依赖</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa-body</span><br></pre></td></tr></table></figure><p>引入<code>koa-body</code>中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koaBody = <span class="built_in">require</span>(<span class="string">&#x27;koa-body&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">koaBody</span>(&#123;</span><br><span class="line">    <span class="attr">multipart</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">formidable</span>: &#123;</span><br><span class="line">        <span class="attr">maxFileSize</span>: <span class="number">200</span>*<span class="number">1024</span>*<span class="number">1024</span>    <span class="comment">// 设置上传文件大小最大限制，默认2M</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>获取上传的文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> file = ctx.<span class="property">request</span>.<span class="property">files</span>.<span class="property">file</span>; <span class="comment">// 获取上传文件</span></span><br></pre></td></tr></table></figure><p>获取文件数据后，可以通过<code>fs</code>模块将文件保存到指定目录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/uploadfile&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 上传单个文件</span></span><br><span class="line">  <span class="keyword">const</span> file = ctx.<span class="property">request</span>.<span class="property">files</span>.<span class="property">file</span>; <span class="comment">// 获取上传文件</span></span><br><span class="line">  <span class="comment">// 创建可读流</span></span><br><span class="line">  <span class="keyword">const</span> reader = fs.<span class="title function_">createReadStream</span>(file.<span class="property">path</span>);</span><br><span class="line">  <span class="keyword">let</span> filePath = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;public/upload/&#x27;</span>) + <span class="string">`/<span class="subst">$&#123;file.name&#125;</span>`</span>;</span><br><span class="line">  <span class="comment">// 创建可写流</span></span><br><span class="line">  <span class="keyword">const</span> upStream = fs.<span class="title function_">createWriteStream</span>(filePath);</span><br><span class="line">  <span class="comment">// 可读流通过管道写入可写流</span></span><br><span class="line">  reader.<span class="title function_">pipe</span>(upStream);</span><br><span class="line">  <span class="keyword">return</span> ctx.<span class="property">body</span> = <span class="string">&quot;上传成功！&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="koa-multer"><a href="#koa-multer" class="headerlink" title="koa-multer"></a>koa-multer</h4><p>安装依赖：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa-multer</span><br></pre></td></tr></table></figure><p>使用 <code>multer</code> 中间件实现文件上传</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> storage = multer.<span class="title function_">diskStorage</span>(&#123;</span><br><span class="line">  <span class="attr">destination</span>: <span class="function">(<span class="params">req, file, cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">cb</span>(<span class="literal">null</span>, <span class="string">&quot;./upload/&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">filename</span>: <span class="function">(<span class="params">req, file, cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">cb</span>(<span class="literal">null</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>() + path.<span class="title function_">extname</span>(file.<span class="property">originalname</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> upload = <span class="title function_">multer</span>(&#123;</span><br><span class="line">  storage</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fileRouter = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">fileRouter.<span class="title function_">post</span>(<span class="string">&quot;/upload&quot;</span>, upload.<span class="title function_">single</span>(<span class="string">&#x27;file&#x27;</span>), <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(ctx.<span class="property">req</span>.<span class="property">file</span>); <span class="comment">// 获取文件</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(fileRouter.<span class="title function_">routes</span>());</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000037411957">https://segmentfault.com/a/1190000037411957</a></li><li><a href="https://www.jianshu.com/p/29e38bcc8a1d">https://www.jianshu.com/p/29e38bcc8a1d</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_file_upload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node中的EventEmitter? 如何实现一个EventEmitter?</title>
      <link href="/2023/01/03/nodejs-enentEmitter/"/>
      <url>/2023/01/03/nodejs-enentEmitter/</url>
      
        <content type="html"><![CDATA[<h1 id="Node中的EventEmitter-如何实现一个EventEmitter"><a href="#Node中的EventEmitter-如何实现一个EventEmitter" class="headerlink" title="Node中的EventEmitter? 如何实现一个EventEmitter?"></a>Node中的EventEmitter? 如何实现一个EventEmitter?</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>我们了解到，<code>Node </code>采用了事件驱动机制，而<code>EventEmitter </code>就是<code>Node</code>实现事件驱动的基础</p><p>在<code>EventEmitter</code>的基础上，<code>Node </code>几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作</p><p><code>Node.js</code> 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件</p><p>这些产生事件的对象都是 events.EventEmitter 的实例，这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上</p><h2 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h2><p><code>Node </code>的<code>events</code>模块只提供了一个<code>EventEmitter</code>类，这个类实现了<code>Node</code>异步事件驱动架构的基本模式——观察者模式</p><p>在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们</p><p>基本代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEmitter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventEmitter</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> <span class="title class_">MyEmitter</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发了event事件！&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">myEmitter.<span class="title function_">on</span>(<span class="string">&#x27;event&#x27;</span>, callback)</span><br><span class="line">myEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>)</span><br><span class="line">myEmitter.<span class="title function_">removeListener</span>(<span class="string">&#x27;event&#x27;</span>, callback);</span><br></pre></td></tr></table></figure><p>通过实例对象的<code>on</code>方法注册一个名为<code>event</code>的事件，通过<code>emit</code>方法触发该事件，而<code>removeListener</code>用于取消事件的监听</p><p>关于其常见的方法如下：</p><ul><li>emitter.addListener&#x2F;on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部</li><li>emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部  </li><li>emitter.emit(eventName[, …args])：触发类型为 eventName 的监听事件 </li><li>emitter.removeListener&#x2F;off(eventName, listener)：移除类型为 eventName 的监听事件   </li><li>emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除           </li><li>emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件</li></ul><h2 id="三、实现过程"><a href="#三、实现过程" class="headerlink" title="三、实现过程"></a>三、实现过程</h2><p>通过上面的方法了解，<code>EventEmitter</code>是一个构造函数，内部存在一个包含所有事件的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>events</code>存放的监听事件的函数的结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;event1&quot;</span>: [f1,f2,f3]，</span><br><span class="line">  <span class="string">&quot;event2&quot;</span>: [f4,f5]，</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始一步步实现实例方法，首先是<code>emit</code>，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">emit</span>(<span class="params">type, ...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(item, <span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现了<code>emit</code>方法之后，然后实现<code>on</code>、<code>addListener</code>、<code>prependListener</code>这三个实例方法，都是添加事件监听触发函数，实现也是大同小异</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">on</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span>[type] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">push</span>(handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addListener</span>(<span class="params">type,handler</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(type,handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">prependListener</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span>[type] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">unshift</span>(handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着就是实现事件监听的方法<code>removeListener/on</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">removeListener</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[type] = <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item !== handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">off</span>(<span class="params">type,handler</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">removeListener</span>(type,handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再来实现<code>once</code>方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过<code>fired</code>属性值判断事件函数是否执行过</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">once</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(type, <span class="variable language_">this</span>.<span class="title function_">_onceWrap</span>(type, handler, <span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_onceWrap</span>(<span class="params">type, handler, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, handler, type , target&#125;;</span><br><span class="line">    <span class="keyword">const</span> wrapFn = <span class="variable language_">this</span>.<span class="property">_onceWrapper</span>.<span class="title function_">bind</span>(state);</span><br><span class="line">    state.<span class="property">wrapFn</span> = wrapFn;</span><br><span class="line">    <span class="keyword">return</span> wrapFn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_onceWrapper</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">fired</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">fired</span> = <span class="literal">true</span>;</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">handler</span>, <span class="variable language_">this</span>.<span class="property">target</span>, args);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">target</span>.<span class="title function_">off</span>(<span class="variable language_">this</span>.<span class="property">type</span>, <span class="variable language_">this</span>.<span class="property">wrapFn</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">on</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">events</span>[type] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">push</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">addListener</span>(<span class="params">type,handler</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">on</span>(type,handler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">prependListener</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">events</span>[type] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">unshift</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">removeListener</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span>[type] = <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item !== handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">off</span>(<span class="params">type,handler</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">removeListener</span>(type,handler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">emit</span>(<span class="params">type, ...args</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(item, <span class="variable language_">this</span>, args);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">once</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">on</span>(type, <span class="variable language_">this</span>.<span class="title function_">_onceWrap</span>(type, handler, <span class="variable language_">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">_onceWrap</span>(<span class="params">type, handler, target</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> state = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, handler, type , target&#125;;</span><br><span class="line">        <span class="keyword">const</span> wrapFn = <span class="variable language_">this</span>.<span class="property">_onceWrapper</span>.<span class="title function_">bind</span>(state);</span><br><span class="line">        state.<span class="property">wrapFn</span> = wrapFn;</span><br><span class="line">        <span class="keyword">return</span> wrapFn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">_onceWrapper</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">fired</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">fired</span> = <span class="literal">true</span>;</span><br><span class="line">            <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">handler</span>, <span class="variable language_">this</span>.<span class="property">target</span>, args);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">target</span>.<span class="title function_">off</span>(<span class="variable language_">this</span>.<span class="property">type</span>, <span class="variable language_">this</span>.<span class="property">wrapFn</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ee = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册所有事件</span></span><br><span class="line">ee.<span class="title function_">once</span>(<span class="string">&#x27;wakeUp&#x27;</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span> 1`</span>); &#125;);</span><br><span class="line">ee.<span class="title function_">on</span>(<span class="string">&#x27;eat&#x27;</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span> 2`</span>) &#125;);</span><br><span class="line">ee.<span class="title function_">on</span>(<span class="string">&#x27;eat&#x27;</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span> 3`</span>) &#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">meetingFn</span> = (<span class="params">name</span>) =&gt; &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span> 4`</span>) &#125;;</span><br><span class="line">ee.<span class="title function_">on</span>(<span class="string">&#x27;work&#x27;</span>, meetingFn);</span><br><span class="line">ee.<span class="title function_">on</span>(<span class="string">&#x27;work&#x27;</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span> 5`</span>) &#125;);</span><br><span class="line"></span><br><span class="line">ee.<span class="title function_">emit</span>(<span class="string">&#x27;wakeUp&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>);</span><br><span class="line">ee.<span class="title function_">emit</span>(<span class="string">&#x27;wakeUp&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>);         <span class="comment">// 第二次没有触发</span></span><br><span class="line">ee.<span class="title function_">emit</span>(<span class="string">&#x27;eat&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>);</span><br><span class="line">ee.<span class="title function_">emit</span>(<span class="string">&#x27;work&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>);</span><br><span class="line">ee.<span class="title function_">off</span>(<span class="string">&#x27;work&#x27;</span>, meetingFn);        <span class="comment">// 移除事件</span></span><br><span class="line">ee.<span class="title function_">emit</span>(<span class="string">&#x27;work&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>);           <span class="comment">// 再次工作</span></span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://nodejs.cn/api/events.html#events_class_eventemitter">http://nodejs.cn/api/events.html#events_class_eventemitter</a></li><li><a href="https://segmentfault.com/a/1190000015762318">https://segmentfault.com/a/1190000015762318</a></li><li><a href="https://juejin.cn/post/6844903781230968845">https://juejin.cn/post/6844903781230968845</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_enentEmitter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Nodejs中的事件循环机制理解?</title>
      <link href="/2023/01/02/nodejs-event-loop/"/>
      <url>/2023/01/02/nodejs-event-loop/</url>
      
        <content type="html"><![CDATA[<h1 id="对Nodejs中的事件循环机制理解"><a href="#对Nodejs中的事件循环机制理解" class="headerlink" title="对Nodejs中的事件循环机制理解?"></a>对Nodejs中的事件循环机制理解?</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>在<a href="https://github.com/febobo/web-interview/issues/73">浏览器事件循环</a>中，我们了解到<code>javascript</code>在浏览器中的事件循环机制，其是根据<code>HTML5</code>定义的规范来实现</p><p>而在<code>NodeJS</code>中，事件循环是基于<code>libuv</code>实现，<code>libuv</code>是一个多平台的专注于异步IO的库，如下图最右侧所示：</p><p> <img src="https://static.vue-js.com/ea690b90-c90e-11eb-85f6-6fac77c0c9b3.png"></p><p>上图<code>EVENT_QUEUE</code> 给人看起来只有一个队列，但<code>EventLoop</code>存在6个阶段，每个阶段都有对应的一个先进先出的回调队列</p><h2 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h2><p>上节讲到事件循环分成了六个阶段，对应如下：</p><p> <img src="https://static.vue-js.com/f2e34d80-c90e-11eb-ab90-d9ae814b240d.png"></p><ul><li>timers阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li><li>定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数</li><li>I&#x2F;O事件回调阶段(I&#x2F;O callbacks)：执行延迟到下一个循环迭代的 I&#x2F;O 回调，即上一轮循环中未被执行的一些I&#x2F;O回调</li><li>闲置阶段(idle, prepare)：仅系统内部使用</li><li>轮询阶段(poll)：检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞</li><li>检查阶段(check)：setImmediate() 回调函数在这里执行</li><li>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on(‘close’, …)</li></ul><p>每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段</p><p>除了上述6个阶段，还存在<code>process.nextTick</code>，其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束, 进入下一个阶段前, 所要执行的回调，类似插队</p><p>流程图如下所示：</p><p> <img src="https://static.vue-js.com/fbe731d0-c90e-11eb-ab90-d9ae814b240d.png"></p><p>在<code>Node</code>中，同样存在宏任务和微任务，与浏览器中的事件循环相似</p><p>微任务对应有：</p><ul><li>next tick queue：process.nextTick</li><li>other queue：Promise的then回调、queueMicrotask</li></ul><p>宏任务对应有：</p><ul><li>timer queue：setTimeout、setInterval</li><li>poll queue：IO事件</li><li>check queue：setImmediate</li><li>close queue：close事件</li></ul><p>其执行顺序为：</p><ul><li>next tick microtask queue</li><li>other microtask queue</li><li>timer queue</li><li>poll queue</li><li>check queue</li><li>close queue</li></ul><h2 id="三、题目"><a href="#三、题目" class="headerlink" title="三、题目"></a>三、题目</h2><p>通过上面的学习，下面开始看看题目</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout0&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setImmediate&#x27;</span>));</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick1&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick2&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>分析过程：</p><ul><li><p>先找到同步任务，输出script start</p></li><li><p>遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中</p></li><li><p>遇到第二个 setTimeout，300ms后将里面的回调函数放到 timer 队列中</p></li><li><p>遇到第一个setImmediate，将里面的回调函数放到 check 队列中</p></li><li><p>遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</p></li><li><p>执行 async1函数，输出 async1 start</p></li><li><p>执行 async2 函数，输出 async2，async2 后面的输出 async1 end进入微任务，等待下一轮的事件循环</p></li><li><p>遇到第二个，将其里面的回调函数放到本轮同步任务执行完毕后执行</p></li><li><p>遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2</p></li><li><p>then里面的回调函数进入微任务队列</p></li><li><p>遇到同步任务，输出 script end</p></li><li><p>执行下一轮回到函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2</p></li><li><p>然后执行微任务队列，依次输出 async1 end、promise3</p></li><li><p>执行timer 队列，依次输出 setTimeout0</p></li><li><p>接着执行 check  队列，依次输出 setImmediate</p></li><li><p>300ms后，timer 队列存在任务，执行输出 setTimeout2</p></li></ul><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">script end</span><br><span class="line">nextTick1</span><br><span class="line">nextTick2</span><br><span class="line">async1 end</span><br><span class="line">promise3</span><br><span class="line">setTimeout0</span><br><span class="line">setImmediate</span><br><span class="line">setTimeout2</span><br></pre></td></tr></table></figure><p>最后有一道是关于<code>setTimeout</code>与<code>setImmediate</code>的输出顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setImmediate&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出情况如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">情况一：</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line">setImmediate</span><br><span class="line"></span><br><span class="line">情况二：</span><br><span class="line">setImmediate</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure><p>分析下流程：</p><ul><li>外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段</li><li>遇到<code>setTimeout</code>，虽然设置的是0毫秒触发，但实际上会被强制改成1ms，时间到了然后塞入<code>times</code>阶段</li><li>遇到<code>setImmediate</code>塞入<code>check</code>阶段</li><li>同步代码执行完毕，进入Event Loop</li><li>先进入<code>times</code>阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足<code>setTimeout</code>条件，执行回调，如果没过1毫秒，跳过</li><li>跳过空的阶段，进入check阶段，执行<code>setImmediate</code>回调</li></ul><p>这里的关键在于这1ms，如果同步代码执行时间较长，进入<code>Event Loop</code>的时候1毫秒已经过了，<code>setTimeout</code>先执行，如果1毫秒还没到，就先执行了<code>setImmediate</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000012258592">https://segmentfault.com/a/1190000012258592</a></li><li><a href="https://juejin.cn/post/6844904100195205133">https://juejin.cn/post/6844904100195205133</a></li><li><a href="https://vue3js.cn/interview/">https://vue3js.cn/interview/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_enentLoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node 中的 Buffer 的理解？应用场景？</title>
      <link href="/2023/01/01/nodejs-buffer/"/>
      <url>/2023/01/01/nodejs-buffer/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-中的-Buffer-的理解？应用场景？"><a href="#Node-中的-Buffer-的理解？应用场景？" class="headerlink" title="Node 中的 Buffer 的理解？应用场景？"></a>Node 中的 Buffer 的理解？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>在<code>Node</code>应用中，需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，要处理大量二进制数据，而<code>Buffer</code>就是在内存中开辟一片区域（初次初始化为8KB），用来存放二进制数据</p><p>在上述操作中都会存在数据流动，每个数据流动的过程中，都会有一个最小或最大数据量</p><p>如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理</p><p>这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 <code>RAM</code> 中</p><p>简单来讲，<code>Nodejs</code>不能控制数据传输的速度和到达时间，只能决定何时发送数据，如果还没到发送时间，则将数据放在<code>Buffer</code>中，即在<code>RAM</code>中，直至将它们发送完毕</p><p>上面讲到了<code>Buffer</code>是用来存储二进制数据，其的形式可以理解成一个数组，数组中的每一项，都可以保存8位二进制：<code>00000000</code>，也就是一个字节</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&quot;why&quot;</span>)</span><br></pre></td></tr></table></figure><p>其存储过程如下图所示：</p><p> <img src="https://static.vue-js.com/20371250-c69c-11eb-ab90-d9ae814b240d.png"></p><h2 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h2><p><code>Buffer</code> 类在全局作用域中，无须<code>require</code>导入</p><p>创建<code>Buffer</code>的方法有很多种，我们讲讲下面的两种常见的形式：</p><ul><li><p>Buffer.from()</p></li><li><p>Buffer.alloc()</p></li></ul><h3 id="Buffer-from"><a href="#Buffer-from" class="headerlink" title="Buffer.from()"></a>Buffer.from()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b1 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> b2 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> b3 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>([<span class="number">10</span>]);</span><br><span class="line"><span class="keyword">const</span> b4 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(b3);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b1, b2, b3, b4); <span class="comment">// &lt;Buffer 31 30&gt; &lt;Buffer 31 30&gt; &lt;Buffer 0a&gt; &lt;Buffer 0a&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Buffer-alloc"><a href="#Buffer-alloc" class="headerlink" title="Buffer.alloc()"></a>Buffer.alloc()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bAlloc1 = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">10</span>); <span class="comment">// 创建一个大小为 10 个字节的缓冲区</span></span><br><span class="line"><span class="keyword">const</span> bAlloc2 = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">10</span>, <span class="number">1</span>); <span class="comment">// 建一个长度为 10 的 Buffer,其中全部填充了值为 `1` 的字节</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bAlloc1); <span class="comment">// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bAlloc2); <span class="comment">// &lt;Buffer 01 01 01 01 01 01 01 01 01 01&gt;</span></span><br></pre></td></tr></table></figure><p>在上面创建<code>buffer</code>后，则能够<code>toString</code>的形式进行交互，默认情况下采取<code>utf8</code>字符编码形式，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer);</span><br><span class="line"><span class="comment">// &lt;Buffer e4 bd a0 e5 a5 bd&gt;</span></span><br><span class="line"><span class="keyword">const</span> str = buffer.<span class="title function_">toString</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line"><span class="comment">// 你好</span></span><br></pre></td></tr></table></figure><p>如果编码与解码不是相同的格式则会出现乱码的情况，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&quot;你好&quot;</span>,<span class="string">&quot;utf-8 &quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer);</span><br><span class="line"><span class="comment">// &lt;Buffer e4 bd a0 e5 a5 bd&gt;</span></span><br><span class="line"><span class="keyword">const</span> str = buffer.<span class="title function_">toString</span>(<span class="string">&quot;ascii&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); </span><br><span class="line"><span class="comment">// d= e%=</span></span><br></pre></td></tr></table></figure><p>当设定的范围导致字符串被截断的时候，也会存在乱码情况，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;Node.js 技术栈&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf)          <span class="comment">// &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf.<span class="property">length</span>)   <span class="comment">// 17</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf.<span class="title function_">toString</span>(<span class="string">&#x27;UTF-8&#x27;</span>, <span class="number">0</span>, <span class="number">9</span>))  <span class="comment">// Node.js �</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf.<span class="title function_">toString</span>(<span class="string">&#x27;UTF-8&#x27;</span>, <span class="number">0</span>, <span class="number">11</span>)) <span class="comment">// Node.js 技</span></span><br></pre></td></tr></table></figure><p>所支持的字符集有如下：</p><ul><li>ascii：仅支持 7 位 ASCII 数据，如果设置去掉高位的话，这种编码是非常快的</li><li>utf8：多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8</li><li>utf16le：2 或 4 个字节，小字节序编码的 Unicode 字符，支持代理对（U+10000至 U+10FFFF）</li><li>ucs2，utf16le 的别名</li><li>base64：Base64 编码</li><li>latin：一种把 Buffer 编码成一字节编码的字符串的方式</li><li>binary：latin1 的别名，</li><li>hex：将每个字节编码为两个十六进制字符</li></ul><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p><code>Buffer</code>的应用场景常常与流的概念联系在一起，例如有如下：</p><ul><li>I&#x2F;O操作</li><li>加密解密</li><li>zlib.js</li></ul><h3 id="I-O操作"><a href="#I-O操作" class="headerlink" title="I&#x2F;O操作"></a>I&#x2F;O操作</h3><p>通过流的形式，将一个文件的内容读取到另外一个文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputStream = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;input.txt&#x27;</span>); <span class="comment">// 创建可读流</span></span><br><span class="line"><span class="keyword">const</span> outputStream = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;output.txt&#x27;</span>); <span class="comment">// 创建可写流</span></span><br><span class="line"></span><br><span class="line">inputStream.<span class="title function_">pipe</span>(outputStream); <span class="comment">// 管道读写</span></span><br></pre></td></tr></table></figure><h3 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h3><p>在一些加解密算法中会遇到使用 <code>Buffer</code>，例如 <code>crypto.createCipheriv</code> 的第二个参数 <code>key</code> 为 <code>string</code> 或 <code>Buffer</code> 类型</p><h3 id="zlib-js"><a href="#zlib-js" class="headerlink" title="zlib.js"></a>zlib.js</h3><p><code>zlib.js</code> 为 <code>Node.js</code> 的核心库之一，其利用了缓冲区（<code>Buffer</code>）的功能来操作二进制数据流，提供了压缩或解压功能</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://nodejs.cn/api/buffer.html">http://nodejs.cn/api/buffer.html</a> </li><li><a href="https://segmentfault.com/a/1190000019894714">https://segmentfault.com/a/1190000019894714</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs_buffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Vue项目中应用TypeScript？</title>
      <link href="/2022/12/29/ts-vue/"/>
      <url>/2022/12/29/ts-vue/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在Vue项目中应用TypeScript？"><a href="#如何在Vue项目中应用TypeScript？" class="headerlink" title="如何在Vue项目中应用TypeScript？"></a>如何在Vue项目中应用TypeScript？</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>与link类似</p><p>在<code>VUE</code>项目中应用<code>typescript</code>，我们需要引入一个库<code>vue-property-decorator</code>，</p><p>其是基于<code>vue-class-component</code>库而来，这个库<code>vue</code>官方推出的一个支持使用<code>class</code>方式来开发<code>vue</code>单文件组件的库</p><p>主要的功能如下：</p><ul><li>methods 可以直接声明为类的成员方法</li><li>计算属性可以被声明为类的属性访问器</li><li>初始化的 data 可以被声明为类属性</li><li>data、render 以及所有的 Vue 生命周期钩子可以直接作为类的成员方法</li><li>所有其他属性，需要放在装饰器中</li></ul><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p>vue-property-decorator 主要提供了多个装饰器和一个函数:</p><ul><li>@Prop</li><li>@PropSync</li><li>@Model</li><li>@Watch</li><li>@Provide</li><li>@Inject</li><li>@ProvideReactive</li><li>@InjectReactive</li><li>@Emit</li><li>@Ref</li><li>@Component (由 vue-class-component 提供)</li><li>Mixins (由 vue-class-component 提供)</li></ul><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p><code>Component</code>装饰器它注明了此类为一个<code>Vue</code>组件，因此即使没有设置选项也不能省略</p><p>如果需要定义比如 <code>name</code>、<code>components</code>、<code>filters</code>、<code>directives</code>以及自定义属性，就可以在<code>Component</code>装饰器中定义，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Component,Vue&#125; from &#x27;vue-property-decorator&#x27;;</span><br><span class="line">import &#123;componentA,componentB&#125; from &#x27;@/components&#x27;;</span><br><span class="line"></span><br><span class="line"> @Component(&#123;</span><br><span class="line">    components:&#123;</span><br><span class="line">        componentA,</span><br><span class="line">        componentB,</span><br><span class="line">    &#125;,</span><br><span class="line">    directives: &#123;</span><br><span class="line">        focus: &#123;</span><br><span class="line">            // 指令的定义</span><br><span class="line">            inserted: function (el) &#123;</span><br><span class="line">                el.focus()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default class YourCompoent extends Vue&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="computed、data、methods"><a href="#computed、data、methods" class="headerlink" title="computed、data、methods"></a>computed、data、methods</h3><p>这里取消了组件的data和methods属性，以往data返回对象中的属性、methods中的方法需要直接定义在Class中，当做类的属性和方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HelloDecorator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="built_in">number</span> = <span class="number">123</span> <span class="comment">// 类属性相当于以前的 data</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">add</span>(): <span class="built_in">number</span> &#123; <span class="comment">// 类方法就是以前的方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取计算属性</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">total</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置计算属性</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">total</span>(<span class="params">param:<span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> = param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="props"><a href="#props" class="headerlink" title="@props"></a>@props</h3><p>组件接收属性的装饰器，如下使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Component</span>,<span class="title class_">Vue</span>,<span class="title class_">Prop</span>&#125; <span class="keyword">from</span> vue-property-decorator;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">YourComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">    @<span class="title class_">Prop</span>(<span class="title class_">String</span>)</span><br><span class="line">    <span class="attr">propA</span>:string;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Prop</span>([<span class="title class_">String</span>,<span class="title class_">Number</span>])</span><br><span class="line">    <span class="attr">propB</span>:string|number;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Prop</span>(&#123;</span><br><span class="line">     <span class="attr">type</span>: <span class="title class_">String</span>, <span class="comment">// type: [String , Number]</span></span><br><span class="line">     <span class="attr">default</span>: <span class="string">&#x27;default value&#x27;</span>, <span class="comment">// 一般为String或Number</span></span><br><span class="line">      <span class="comment">//如果是对象或数组的话。默认值从一个工厂函数中返回</span></span><br><span class="line">      <span class="comment">// defatult: () =&gt; &#123;</span></span><br><span class="line">      <span class="comment">//     return [&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">     <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">     <span class="attr">validator</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          <span class="string">&#x27;InProcess&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Settled&#x27;</span></span><br><span class="line">        ].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="attr">propC</span>:string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="@watch"></a>@watch</h3><p>实际就是<code>Vue</code>中的监听器，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Vue, Component, Watch &#125; from &#x27;vue-property-decorator&#x27;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">export default class YourComponent extends Vue &#123;</span><br><span class="line">  @Watch(&#x27;child&#x27;)</span><br><span class="line">  onChildChanged(val: string, oldVal: string) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @Watch(&#x27;person&#x27;, &#123; immediate: true, deep: true &#125;)</span><br><span class="line">  onPersonChanged1(val: Person, oldVal: Person) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @Watch(&#x27;person&#x27;)</span><br><span class="line">  onPersonChanged2(val: Person, oldVal: Person) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="emit"><a href="#emit" class="headerlink" title="@emit"></a>@emit</h3><p><code>vue-property-decorator</code> 提供的 <code>@Emit</code> 装饰器就是代替<code>Vue </code>中的事件的触发<code>$emit</code>，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Vue</span>, <span class="title class_">Component</span>, <span class="title class_">Emit</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line">    <span class="meta">@Component</span>(&#123;&#125;)</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Some</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span>&#123;</span><br><span class="line">        <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.$on(<span class="string">&#x27;emit-todo&#x27;</span>, <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">emitTodo</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Emit</span>()</span><br><span class="line">        <span class="title function_">emitTodo</span>(<span class="params">n: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="三-、总结"><a href="#三-、总结" class="headerlink" title="三 、总结"></a>三 、总结</h2><p>可以看到上述<code>typescript</code>版本的<code>vue class</code>的语法与平时<code>javascript</code>版本使用起来还是有很大的不同，多处用到<code>class</code>与装饰器，但实际上本质是一致的，只有不断编写才会得心应手</p>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts_vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 项目中应用 TypeScript？</title>
      <link href="/2022/12/28/ts-react/"/>
      <url>/2022/12/28/ts-react/</url>
      
        <content type="html"><![CDATA[<h1 id="React-项目中应用-TypeScript？"><a href="#React-项目中应用-TypeScript？" class="headerlink" title="React 项目中应用 TypeScript？"></a>React 项目中应用 TypeScript？</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>单独的使用 <code>TypeScript</code> 并不会导致学习成本很高，但是绝大部分前端开发者的项目都是依赖于框架的</p><p>例如与 <code>Vue</code>、<code>React</code> 这些框架结合使用的时候，会有一定的门槛</p><p>使用 <code>TypeScript</code> 编写 <code>React</code> 代码，除了需要 <code>TypeScript</code> 这个库之外，还需要安装 <code>@types/react</code>、<code>@types/react-dom</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i @types/react -s</span><br><span class="line"></span><br><span class="line">npm i @types/react-dom -s</span><br></pre></td></tr></table></figure><p>至于上述使用 <code>@types</code> 的库的原因在于，目前非常多的 <code>JavaScript</code> 库并没有提供自己关于 <code>TypeScript</code> 的声明文件</p><p>所以，<code>ts</code> 并不知道这些库的类型以及对应导出的内容，这里 <code>@types</code> 实际就是社区中的 <code>DefinitelyTyped</code> 库，定义了目前市面上绝大多数的 <code>JavaScript</code> 库的声明</p><p>所以下载相关的 <code>JavaScript</code> 对应的 <code>@types</code> 声明时，就能够使用使用该库对应的类型定义</p><h2 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h2><p>在编写 <code>React</code> 项目的时候，最常见的使用的组件就是：</p><ul><li>无状态组件</li><li>有状态组件</li><li>受控组件</li></ul><h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h3><p>主要作用是用于展示 <code>UI</code>，如果使用 <code>js</code> 声明，则如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;React&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Logo</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; logo, className, alt &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;logo&#125;</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;alt&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但这时候 <code>ts</code> 会出现报错提示，原因在于没有定义 <code>porps</code> 类型，这时候就可以使用 <code>interface</code> 接口去定义 <code>porps</code> 即可，如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;React&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IProps</span> &#123;</span><br><span class="line">  logo?: <span class="built_in">string</span>;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  alt?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Logo</span> = (<span class="params">props: IProps</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; logo, className, alt &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;logo&#125;</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;alt&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是我们都知道 <code>props</code> 里面存在 <code>children</code> 属性，我们不可能每个 <code>porps</code> 接口里面定义多一个 <code>children</code>，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IProps</span> &#123;</span><br><span class="line">  logo?: <span class="built_in">string</span>;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  alt?: <span class="built_in">string</span>;</span><br><span class="line">  children?: <span class="title class_">ReactNode</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更加规范的写法是使用 <code>React</code> 里面定义好的 <code>FC</code> 属性，里面已经定义好 <code>children</code> 类型，如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Logo</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">IProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; logo, className, alt &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;logo&#125;</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;alt&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>React.FC 显式地定义了返回类型，其他方式是隐式推导的</p></li><li><p>React.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全</p></li><li><p>React.FC 为 children 提供了隐式的类型（ReactElement | null）</p></li></ul><h3 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件"></a>有状态组件</h3><p>可以是一个类组件且存在 <code>props</code> 和 <code>state</code> 属性</p><p>如果使用 <code>TypeScript</code> 声明则如下所示：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;React&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IProps</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">  size?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IState</span> &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;<span class="title class_">IProps</span>, <span class="title class_">IState</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述通过泛型对 <code>props</code>、<code>state</code> 进行类型定义，然后在使用的时候就可以在编译器中获取更好的智能提示</p><p>关于 <code>Component</code> 泛型类的定义，可以参考下 React 的类型定义文件 <code>node_modules/@types/React/index.d.ts</code>，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span>&lt;P, S&gt; &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">props</span>: <span class="title class_">Readonly</span>&lt;&#123; children?: <span class="title class_">ReactNode</span> &#125;&gt; &amp; <span class="title class_">Readonly</span>&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="attr">state</span>: <span class="title class_">Readonly</span>&lt;S&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述可以看到，<code>state</code> 属性也定义了可读类型，目的是为了防止直接调用 <code>this.state</code> 更新状态</p><h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>受控组件的特性在于元素的内容通过组件的状态 <code>state</code> 进行控制</p><p>由于组件内部的事件是合成事件，不等同于原生事件，</p><p>例如一个 <code>input</code> 组件修改内部的状态，常见的定义的时候如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">updateValue</span>(<span class="params">e: React.ChangeEvent&lt;HTMLInputElement&gt;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">itemText</span>: e.<span class="property">target</span>.<span class="property">value</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用 <code>Event</code> 事件对象类型：</p><ul><li>ClipboardEvent&lt;T &#x3D; Element&gt; 剪贴板事件对象</li><li>DragEvent&lt;T &#x3D; Element&gt; 拖拽事件对象</li><li>ChangeEvent&lt;T &#x3D; Element&gt; Change 事件对象</li><li>KeyboardEvent&lt;T &#x3D; Element&gt; 键盘事件对象</li><li>MouseEvent&lt;T &#x3D; Element&gt; 鼠标事件对象</li><li>TouchEvent&lt;T &#x3D; Element&gt; 触摸事件对象</li><li>WheelEvent&lt;T &#x3D; Element&gt; 滚轮事件对象</li><li>AnimationEvent&lt;T &#x3D; Element&gt; 动画事件对象</li><li>TransitionEvent&lt;T &#x3D; Element&gt; 过渡事件对象</li></ul><p><code>T</code> 接收一个 <code>DOM</code> 元素类型</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>上述只是简单的在 <code>React</code> 项目使用 <code>TypeScript</code>，但在编写 <code>React</code> 项目的时候，还存在 <code>hooks</code>、默认参数、以及 <code>store</code> 等等……</p><p><code>TypeScript</code> 在框架中使用的学习成本相对会更高，需要不断编写才能熟练</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6952696734078369828">https://juejin.cn/post/6952696734078369828</a></li><li><a href="https://juejin.cn/post/6844903684422254606">https://juejin.cn/post/6844903684422254606</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts_react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 的理解？与 JavaScript 的区别？</title>
      <link href="/2022/12/26/ts-javascript/"/>
      <url>/2022/12/26/ts-javascript/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-的理解？与-JavaScript-的区别？"><a href="#TypeScript-的理解？与-JavaScript-的区别？" class="headerlink" title="TypeScript 的理解？与 JavaScript 的区别？"></a>TypeScript 的理解？与 JavaScript 的区别？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>TypeScript</code> 是 <code>JavaScript</code> 的类型的超集，支持<code>ES6</code>语法，支持面向对象编程的概念，如类、接口、继承、泛型等</p><blockquote><p>超集，不得不说另外一个概念，子集，怎么理解这两个呢，举个例子，如果一个集合 A 里面的的所有元素集合 B 里面都存在，那么我们可以理解集合 B 是集合 A 的超集，集合 A 为集合 B 的子集</p></blockquote><p><img src="https://static.vue-js.com/61c2c1f0-0950-11ec-a752-75723a64e8f5.png"></p><p>其是一种静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误</p><p>同时扩展了<code> JavaScript</code> 的语法，所以任何现有的<code> JavaScript</code> 程序可以不加改变的在 <code>TypeScript</code> 下工作</p><p>为了保证兼容性，<code>TypeScript</code> 在编译阶段需要编译器编译成纯 <code>JavaScript</code> 来运行，是为大型应用之开发而设计的语言，如下：</p><p><code>ts</code> 文件如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hello);</span><br></pre></td></tr></table></figure><p>编译文件后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hello);</span><br></pre></td></tr></table></figure><h2 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h2><p><code>TypeScript</code> 的特性主要有如下：</p><ul><li><strong>类型批注和编译时类型检查</strong> ：在编译时批注变量类型</li><li><strong>类型推断</strong>：ts 中没有批注变量类型会自动推断变量的类型</li><li><strong>类型擦除</strong>：在编译过程中批注的内容和接口会在运行时利用工具擦除</li><li><strong>接口</strong>：ts 中用接口来定义对象类型</li><li><strong>枚举</strong>：用于取值被限定在一定范围内的场景</li><li><strong>Mixin</strong>：可以接受任意类型的值</li><li><strong>泛型编程</strong>：写代码时使用一些以后才指定的类型</li><li><strong>名字空间</strong>：名字只在该区域内有效，其他区域可重复使用该名字而不冲突</li><li><strong>元组</strong>：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组</li><li>…</li></ul><h3 id="类型批注"><a href="#类型批注" class="headerlink" title="类型批注"></a>类型批注</h3><p>通过类型批注提供在编译时启动类型检查的静态类型，这是可选的，而且可以忽略而使用 <code>JavaScript</code> 常规的动态类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Add</span>(<span class="params">left: <span class="built_in">number</span>, right: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于基本类型的批注是 <code>number</code>、<code>bool</code> 和 <code>string</code>，而弱或动态类型的结构则是 <code>any</code> 类型</p><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>当类型没有给出时，TypeScript 编译器利用类型推断来推断类型，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;string&quot;</span>;</span><br></pre></td></tr></table></figure><p>变量 <code>str</code> 被推断为字符串类型，这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时</p><p>如果缺乏声明而不能推断出类型，那么它的类型被视作默认的动态 <code>any</code> 类型</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口简单来说就是用来描述对象的类型 数据的类型有 <code>number</code>、<code>null</code>、<code> string</code> 等数据格式，对象的类型就是用接口来描述的</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><ul><li>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法</li><li>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译</li><li>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</li><li>在编写 TypeScript 的文件的时候就会自动编译成 js 文件</li></ul><p>更多的区别如下图所示：</p><p><img src="https://static.vue-js.com/6b544040-0950-11ec-8e64-91fdec0f05a1.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/140012915">https://zhuanlan.zhihu.com/p/140012915</a></li><li><a href="https://www.jianshu.com/p/c8aaba6e8ce0">https://www.jianshu.com/p/c8aaba6e8ce0</a></li><li><a href="https://www.cnblogs.com/powertoolsteam/p/13500668.html">https://www.cnblogs.com/powertoolsteam/p/13500668.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts_javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 中命名空间与模块的理解？区别？</title>
      <link href="/2022/12/26/ts-namespace-module/"/>
      <url>/2022/12/26/ts-namespace-module/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-中命名空间与模块的理解？区别？"><a href="#TypeScript-中命名空间与模块的理解？区别？" class="headerlink" title="TypeScript 中命名空间与模块的理解？区别？"></a>TypeScript 中命名空间与模块的理解？区别？</h1><h2 id="一、模块"><a href="#一、模块" class="headerlink" title="一、模块"></a>一、模块</h2><p><code>TypeScript</code> 与<code> ECMAScript</code> 2015 一样，任何包含顶级 <code>import</code> 或者 <code>export</code> 的文件都被当成一个模块</p><p>相反地，如果一个文件不带有顶级的<code>import</code>或者<code>export</code>声明，那么它的内容被视为全局可见的</p><p>例如我们在在一个 <code>TypeScript</code> 工程下建立一个文件 <code>1.ts</code>，声明一个变量<code>a</code>，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后在另一个文件同样声明一个变量<code>a</code>，这时候会出现错误信息</p><p> <img src="https://static.vue-js.com/a239d970-137e-11ec-a752-75723a64e8f5.png"></p><p>提示重复声明<code>a</code>变量，但是所处的空间是全局的</p><p>如果需要解决这个问题，则通过<code>import</code>或者<code>export</code>引入模块系统即可，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br></pre></td></tr></table></figure><p>在<code>typescript</code>中，<code>export</code>关键字可以导出变量或者类型，用法与<code>es6</code>模块一致，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>import</code> 引入模块，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a, <span class="title class_">Person</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./export&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="二、命名空间"><a href="#二、命名空间" class="headerlink" title="二、命名空间"></a>二、命名空间</h2><p>命名空间一个最明确的目的就是解决重名问题</p><p>命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的</p><p>这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中</p><p><code>TypeScript</code> 中命名空间使用 <code>namespace</code> 来定义，语法格式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">SomeNameSpaceName</span> &#123;</span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ISomeInterfaceName</span> &#123;      &#125;</span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SomeClassName</span> &#123;      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上定义了一个命名空间 <code>SomeNameSpaceName</code>，如果我们需要在外部可以调用 <code>SomeNameSpaceName</code> 中的类和接口，则需要在类和接口添加 <code>export</code> 关键字</p><p>使用方式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">SomeNameSpaceName</span>.<span class="property">SomeClassName</span></span><br></pre></td></tr></table></figure><p>命名空间本质上是一个对象，作用是将一系列相关的全局变量组织到一个对象的属性，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Letter</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> z = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成<code>js</code>如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Letter</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Letter</span>) &#123;</span><br><span class="line">    <span class="title class_">Letter</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="title class_">Letter</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="title class_">Letter</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title class_">Letter</span>.<span class="property">z</span> = <span class="number">26</span>;</span><br><span class="line">&#125;)(<span class="title class_">Letter</span> || (<span class="title class_">Letter</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><ul><li><p>命名空间是位于全局命名空间下的一个普通的带有名字的  JavaScript  对象，使用起来十分容易。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中</p></li><li><p>像命名空间一样，模块可以包含代码和声明。 不同的是模块可以声明它的依赖</p></li><li><p>在正常的TS项目开发过程中并不建议用命名空间，但通常在通过 d.ts 文件标记 js 库类型的时候使用命名空间，主要作用是给编译器编写代码的时候参考使用</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.tslang.cn/docs/handbook/modules.html">https://www.tslang.cn/docs/handbook/modules.html</a></li><li><a href="https://www.tslang.cn/docs/handbook/namespaces.html">https://www.tslang.cn/docs/handbook/namespaces.html</a></li><li><a href="https://www.tslang.cn/docs/handbook/namespaces-and-modules.html">https://www.tslang.cn/docs/handbook/namespaces-and-modules.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts_namespace_module </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 中接口的理解？应用场景？</title>
      <link href="/2022/12/25/ts-interface/"/>
      <url>/2022/12/25/ts-interface/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-中接口的理解？应用场景？"><a href="#TypeScript-中接口的理解？应用场景？" class="headerlink" title="TypeScript 中接口的理解？应用场景？"></a>TypeScript 中接口的理解？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><strong>接口</strong>是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的<strong>类</strong>去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法</p><p>简单来讲，一个接口所描述的是一个对象相关的属性和方法，但并不提供具体创建此对象实例的方法</p><p><code>typescript</code>的核心功能之一就是对类型做检测，虽然这种检测方式是“鸭式辨型法”，而接口的作用就是为为这些类型命名和为你的代码或第三方代码定义一个约定</p><h2 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h2><p>接口定义如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> interface_name &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如有一个函数，这个函数接受一个 <code>User</code> 对象，然后返回这个 <code>User</code> 对象的 <code>name</code> 属性:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getUserName</span> = (<span class="params">user</span>) =&gt; user.<span class="property">name</span></span><br></pre></td></tr></table></figure><p>可以看到，参数需要有一个<code>user</code>的<code>name</code>属性，可以通过接口描述<code>user</code>参数的结构</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getUserName</span> = (<span class="params">user: User</span>) =&gt; user.<span class="property">name</span></span><br></pre></td></tr></table></figure><p>这些属性并不一定全部实现，上述传入的对象必须拥有<code>name</code>和<code>age</code>属性，否则<code>typescript</code>在编译阶段会报错，如下图：</p><p> <img src="https://static.vue-js.com/25d3a790-0b2b-11ec-a752-75723a64e8f5.png"></p><p>如果不想要<code>age</code>属性的话，这时候可以采用<strong>可选属性</strong>，如下表示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候<code>age</code>属性则可以是<code>number</code>类型或者<code>undefined</code>类型</p><p>有些时候，我们想要一个属性变成只读属性，在<code>typescript</code>只需要使用<code>readonly</code>声明，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">isMale</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们修改属性的时候，就会出现警告，如下所示：</p><p> <img src="https://static.vue-js.com/2f6d3c30-0b2b-11ec-8e64-91fdec0f05a1.png"></p><p>这是属性中有一个函数，可以如下表示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">isMale</span>: <span class="built_in">boolean</span></span><br><span class="line">    <span class="attr">say</span>: <span class="function">(<span class="params">words: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传递的对象不仅仅是上述的属性，这时候可以使用：</p><ul><li>类型推断</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">    name: string</span><br><span class="line">    age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getUserName = (user: User) =&gt; user.name</span><br><span class="line">getUserName(&#123;color: &#x27;yellow&#x27;&#125; as User)</span><br></pre></td></tr></table></figure><ul><li>给接口添加字符串<strong>索引签名</strong></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口还能实现继承，如下图：</p><p> <img src="https://static.vue-js.com/38a41760-0b2b-11ec-8e64-91fdec0f05a1.png"></p><p>也可以继承多个，父类通过逗号隔开，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="title class_">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Mother</span> &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="title class_">Number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>,<span class="title class_">Mother</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="title class_">Number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>例如在<code>javascript</code>中定义一个函数，用来获取用户的姓名和年龄：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getUserInfo = <span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="attr">name</span>: $&#123;user.<span class="property">name</span>&#125;, <span class="attr">age</span>: $&#123;user.<span class="property">age</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果多人开发的都需要用到这个函数的时候，如果没有注释，则可能出现各种运行时的错误，这时候就可以使用接口定义参数变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IUser</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserInfo = (<span class="attr">user</span>: <span class="title class_">IUser</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`name: <span class="subst">$&#123;user.name&#125;</span>, age: <span class="subst">$&#123;user.age&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的调用</span></span><br><span class="line"><span class="title function_">getUserInfo</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;koala&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;);</span><br></pre></td></tr></table></figure><p>包括后面讲到类的时候也会应用到接口</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.tslang.cn/docs/handbook/interfaces.html">https://www.tslang.cn/docs/handbook/interfaces.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts_interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 中高级类型的理解？有哪些？</title>
      <link href="/2022/12/24/ts-high-type/"/>
      <url>/2022/12/24/ts-high-type/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-中高级类型的理解？有哪些？"><a href="#TypeScript-中高级类型的理解？有哪些？" class="headerlink" title="TypeScript 中高级类型的理解？有哪些？"></a>TypeScript 中高级类型的理解？有哪些？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>除了<code>string</code>、<code>number</code>、<code>boolean</code> 这种基础类型外，在 <code>typescript</code> 类型声明中还存在一些高级的类型应用</p><p>这些高级类型，是<code>typescript</code>为了保证语言的灵活性，所使用的一些语言特性。这些特性有助于我们应对复杂多变的开发场景</p><h2 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h2><p>常见的高级类型有如下：</p><ul><li>交叉类型</li><li>联合类型</li><li>类型别名</li><li>类型索引</li><li>类型约束</li><li>映射类型</li><li>条件类型</li></ul><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>通过 <code>&amp;</code> 将多个类型合并为一个类型，包含了所需的所有类型的特性，本质上是一种并的操作</p><p>语法如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T &amp; U</span><br></pre></td></tr></table></figure><p>适用于对象合并场景，如下将声明一个函数，将两个对象合并成一个对象并返回：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> extend&lt;T , U&gt;(<span class="attr">first</span>: T, <span class="attr">second</span>: U) : T &amp; U &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">result</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">T</span> &amp; <span class="attr">U</span>&gt;</span> = &#123;&#125;</span></span><br><span class="line"><span class="language-xml">    for (let key in first) &#123;</span></span><br><span class="line"><span class="language-xml">        result[key] = first[key]</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">    for (let key in second) &#123;</span></span><br><span class="line"><span class="language-xml">        if(!result.hasOwnProperty(key)) &#123;</span></span><br><span class="line"><span class="language-xml">            result[key] = second[key]</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">    return result</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型的语法规则和逻辑 “或” 的符号一致，表示其类型为连接的多个类型中的任意一个，本质上是一个交的关系</p><p>语法如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T | U</span><br></pre></td></tr></table></figure><p>例如 <code>number</code> | <code>string</code> | <code>boolean</code> 的类型只能是这三个的一种，不能共存</p><p>如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatCommandline</span>(<span class="params">command: <span class="built_in">string</span>[] | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> line = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> command === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    line = command.<span class="title function_">trim</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    line = command.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">trim</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名会给一个类型起个新名字，类型别名有时和接口很像，但是可以作用于原始值、联合类型、元组以及其它任何你需要手写的类型</p><p>可以使用 <code>type SomeName = someValidTypeAnnotation</code>的语法来创建类型别名：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> some = <span class="built_in">boolean</span> | <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: some = <span class="literal">true</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>: some = <span class="string">&#x27;hello&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">d</span>: some = <span class="number">123</span> <span class="comment">// 不能将类型“123”分配给类型“some”</span></span><br></pre></td></tr></table></figure><p>此外类型别名可以是泛型:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Container</span>&lt;T&gt; = &#123; <span class="attr">value</span>: T &#125;;</span><br></pre></td></tr></table></figure><p>也可以使用类型别名来在属性里引用自己：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tree</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="attr">value</span>: T;</span><br><span class="line">    <span class="attr">left</span>: <span class="title class_">Tree</span>&lt;T&gt;;</span><br><span class="line">    <span class="attr">right</span>: <span class="title class_">Tree</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，类型别名和接口使用十分相似，都可以描述一个对象或者函数</p><p>两者最大的区别在于，<code>interface </code>只能用于定义对象类型，而 <code>type</code> 的声明方式除了对象之外还可以定义交叉、联合、原始类型等，类型声明的方式适用范围显然更加广泛</p><h3 id="类型索引"><a href="#类型索引" class="headerlink" title="类型索引"></a>类型索引</h3><p><code>keyof</code> 类似于 <code>Object.keys</code> ，用于获取一个接口中 Key 的联合类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">text</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ButtonKeys</span> = keyof <span class="title class_">Button</span></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ButtonKeys</span> = <span class="string">&quot;type&quot;</span> | <span class="string">&quot;text&quot;</span></span><br></pre></td></tr></table></figure><h3 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h3><p>通过关键字 <code>extend</code> 进行约束，不同于在 <code>class</code> 后使用 <code>extends</code> 的继承作用，泛型内使用的主要作用是对泛型加以约束</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">BaseType</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里表示 copy 的参数</span></span><br><span class="line"><span class="comment">// 只能是字符串、数字、布尔这几种基础类型</span></span><br><span class="line"><span class="keyword">function</span> copy&lt;T <span class="keyword">extends</span> <span class="title class_">BaseType</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型约束通常和类型索引一起使用，例如我们有一个方法专门用来获取对象的值，但是这个对象并不确定，我们就可以使用 <code>extends</code> 和 <code>keyof</code> 进行约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getValue&lt;T, K <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">key</span>: K) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">getValue</span>(obj, <span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>通过 <code>in</code> 关键字做类型的映射，遍历已有接口的 <code>key</code> 或者是遍历联合类型，如下例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadOnlyObj</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Obj</span>&gt;</span><br></pre></td></tr></table></figure><p>上述的结构，可以分成这些步骤：</p><ul><li>keyof T：通过类型索引 keyof 的得到联合类型 ‘a’ | ‘b’</li><li>P in keyof T 等同于 p in ‘a’ | ‘b’，相当于执行了一次 forEach 的逻辑，遍历 ‘a’ | ‘b’</li></ul><p>所以最终<code>ReadOnlyObj</code>的接口为下述：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadOnlyObj</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h3><p>条件类型的语法规则和三元表达式一致，经常用于一些类型不确定的情况。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure><p>上面的意思就是，如果 T 是 U 的子集，就是类型 X，否则为类型 Y</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>可以看到，如果只是掌握了 <code>typeScript</code> 的一些基础类型，可能很难游刃有余的去使用 <code>typeScript</code>，需要了解一些<code>typescript</code>的高阶用法</p><p>并且<code>typescript</code>在版本的迭代中新增了很多功能，需要不断学习与掌握</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.tslang.cn/docs/handbook/advanced-types.html">https://www.tslang.cn/docs/handbook/advanced-types.html</a></li><li><a href="https://juejin.cn/post/6844904003604578312">https://juejin.cn/post/6844904003604578312</a></li><li><a href="https://zhuanlan.zhihu.com/p/103846208">https://zhuanlan.zhihu.com/p/103846208</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts_high_type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对 TypeScript 中泛型的理解？应用场景？</title>
      <link href="/2022/12/23/ts-generic/"/>
      <url>/2022/12/23/ts-generic/</url>
      
        <content type="html"><![CDATA[<h1 id="对-TypeScript-中泛型的理解？应用场景？"><a href="#对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="对 TypeScript 中泛型的理解？应用场景？"></a>对 TypeScript 中泛型的理解？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式</p><p>泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型<br>在<code>typescript</code>中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性</p><p>假设我们用一个函数，它可接受一个 <code>number</code> 参数并返回一个<code> number</code> 参数，如下写法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnItem</span> (<span class="attr">para</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们打算接受一个 <code>string</code> 类型，然后再返回 <code>string</code>类型，则如下写法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnItem</span> (<span class="attr">para</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两种编写方式，存在一个最明显的问题在于，代码重复度比较高</p><p>虽然可以使用 <code>any</code>类型去替代，但这也并不是很好的方案，因为我们的目的是接收什么类型的参数返回什么类型的参数，即在运行时传入参数我们才能确定类型</p><p>这种情况就可以使用泛型，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> returnItem&lt;T&gt;(<span class="attr">para</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，泛型给予开发者创造灵活、可重用代码的能力</p><h2 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h2><p>泛型通过<code>&lt;&gt;</code>的形式进行表述，可以声明：</p><ul><li><p>函数</p></li><li><p>接口</p></li><li><p>类</p></li></ul><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>声明函数的形式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> returnItem&lt;T&gt;(<span class="attr">para</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义泛型的时候，可以一次定义<strong>多个类型参数</strong>，比如我们可以同时定义泛型 <code>T</code> 和 泛型 <code>U</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> swap&lt;T, U&gt;(<span class="attr">tuple</span>: [T, U]): [U, T] &#123;</span><br><span class="line">    <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">swap</span>([<span class="number">7</span>, <span class="string">&#x27;seven&#x27;</span>]); <span class="comment">// [&#x27;seven&#x27;, 7]</span></span><br></pre></td></tr></table></figure><h3 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h3><p>声明接口的形式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReturnItemFn</span>&lt;T&gt; &#123;</span><br><span class="line">    (<span class="attr">para</span>: T): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当我们想传入一个number作为参数的时候，就可以这样声明函数:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">returnItem</span>: <span class="title class_">ReturnItemFn</span>&lt;<span class="built_in">number</span>&gt; = <span class="function"><span class="params">para</span> =&gt;</span> para</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><p>使用泛型声明类的时候，既可以作用于类本身，也可以作用与类的成员函数</p><p>下面简单实现一个元素同类型的栈结构，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">arr</span>: T[] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">push</span>(<span class="params">item: T</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">pop</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stacn</span>&lt;<span class="built_in">number</span>&gt;()</span><br></pre></td></tr></table></figure><p>如果上述只能传递 <code>string</code> 和 <code>number</code> 类型，这时候就可以使用 <code>&lt;T extends xx&gt;</code> 的方式猜实现<strong>约束泛型</strong>，如下所示：</p><p> <img src="https://static.vue-js.com/67d212a0-0e17-11ec-8e64-91fdec0f05a1.png"></p><p>除了上述的形式，泛型更高级的使用如下：</p><p>例如要设计一个函数，这个函数接受两个参数，一个参数为对象，另一个参数为对象上的属性，我们通过这两个参数返回这个属性的值</p><p>这时候就设计到泛型的索引类型和约束类型共同实现</p><h3 id="索引类型、约束类型"><a href="#索引类型、约束类型" class="headerlink" title="索引类型、约束类型"></a>索引类型、约束类型</h3><p>索引类型 <code>keyof T</code> 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getValue&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, U <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">key</span>: U) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key] <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述为什么需要使用泛型约束，而不是直接定义第一个参数为 <code>object</code>类型，是因为默认情况 <code>object</code> 指的是<code>&#123;&#125;</code>，而我们接收的对象是各种各样的，一个泛型来表示传入的对象类型，比如 <code>T extends object</code></p><p>使用如下图所示：</p><p> <img src="https://static.vue-js.com/74fcbd40-0e17-11ec-a752-75723a64e8f5.png"></p><h3 id="多类型约束"><a href="#多类型约束" class="headerlink" title="多类型约束"></a>多类型约束</h3><p>例如如下需要实现两个接口的类型约束：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FirstInterface</span> &#123;</span><br><span class="line">  <span class="title function_">doSomething</span>(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SecondInterface</span> &#123;</span><br><span class="line">  <span class="title function_">doSomethingElse</span>(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以创建一个接口继承上述两个接口，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ChildInterface</span> <span class="keyword">extends</span> <span class="title class_">FirstInterface</span>, <span class="title class_">SecondInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确使用如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&lt;T <span class="keyword">extends</span> <span class="title class_">ChildInterface</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">genericProperty</span>: T</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">genericProperty: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">genericProperty</span> = genericProperty</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">useT</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">genericProperty</span>.<span class="title function_">doSomething</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">genericProperty</span>.<span class="title function_">doSomethingElse</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过泛型约束就可以达到多类型约束的目的</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>通过上面初步的了解，后述在编写 <code>typescript</code> 的时候，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性的时候，这种情况下就可以使用泛型</p><p>灵活的使用泛型定义类型，是掌握<code>typescript</code> 必经之路</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.tslang.cn/docs/handbook/generics.html">https://www.tslang.cn/docs/handbook/generics.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts_generic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 中函数的理解？与 JavaScript 函数的区别？</title>
      <link href="/2022/12/22/ts-function/"/>
      <url>/2022/12/22/ts-function/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-中函数的理解？与-JavaScript-函数的区别？"><a href="#TypeScript-中函数的理解？与-JavaScript-函数的区别？" class="headerlink" title="TypeScript 中函数的理解？与 JavaScript 函数的区别？"></a>TypeScript 中函数的理解？与 JavaScript 函数的区别？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>函数是<code> JavaScript</code> 应用程序的基础，帮助我们实现抽象层、模拟类、信息隐藏和模块</p><p>在<code> TypeScript</code> 里，虽然已经支持类、命名空间和模块，但函数仍然是主要定义行为的方式，<code>TypeScript</code> 为 <code>JavaScript</code> 函数添加了额外的功能，丰富了更多的应用场景</p><p>函数类型在 <code>TypeScript</code> 类型系统中扮演着非常重要的角色，它们是可组合系统的核心构建块</p><h2 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h2><p>跟<code>javascript</code> 定义函数十分相似，可以通过<code>funciton</code> 关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt; a + b</span><br></pre></td></tr></table></figure><p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上<code> TypeScript</code> 编译器是能够通过类型推断到这个函数的类型，如下图所示：</p><p> <img src="https://static.vue-js.com/4b3415b0-0d42-11ec-8e64-91fdec0f05a1.png"></p><p>当鼠标放置在第三行<code>add</code>函数名的时候，会出现完整的函数定义类型，通过<code>:</code> 的形式来定于参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p><p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LongHand</span> = &#123;</span><br><span class="line">  (<span class="attr">a</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ShortHand</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><p>当存在函数重载时，只能使用方式一的形式</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>) =&gt; a + (b ? b : <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这时候参数<code>b</code>可以是<code>number</code>类型或者<code>undefined</code>类型，即可以传一个<code>number</code>类型或者不传都可以</p><h3 id="剩余类型"><a href="#剩余类型" class="headerlink" title="剩余类型"></a>剩余类型</h3><p>剩余参数与<code>JavaScript</code>的语法类似，需要用 <code>...</code> 来表示剩余参数</p><p>如果剩余参数 <code>rest</code> 是一个由<code>number</code>类型组成的数组，则如下表示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a: <span class="built_in">number</span>, ...rest: <span class="built_in">number</span>[]</span>) =&gt; rest.<span class="title function_">reduce</span>((<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b), a)</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p><p>关于<code>typescript</code>函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|</code>操作符或者<code>?</code>操作符，把所有可能的输入类型全部包含进去，用于具体实现</p><p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，<code>typescript</code>并不会真的将你的多个重名 <code>function </code>的函数体进行合并</p><p>例如我们有一个add函数，它可以接收 <code>string</code>类型的参数进行拼接，也可以接收 <code>number</code> 类型的参数进行相加，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上边是声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (<span class="attr">arg1</span>: <span class="built_in">string</span>, <span class="attr">arg2</span>: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (<span class="attr">arg1</span>: <span class="built_in">number</span>, <span class="attr">arg2</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line"><span class="comment">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下边是实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (<span class="attr">arg1</span>: <span class="built_in">string</span> | <span class="built_in">number</span>, <span class="attr">arg2</span>: <span class="built_in">string</span> | <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="comment">// 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> arg1 === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> arg2 === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> arg1 === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> arg2 === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>从上面可以看到：</p><ul><li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li><li>typescript 在参数中，添加可选参数供使用者选择</li><li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.tslang.cn/docs/handbook/functions.html">https://www.tslang.cn/docs/handbook/functions.html</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD</a></li><li><a href="https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD">https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts_function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序的实现原理？</title>
      <link href="/2022/12/21/wxapp-webview-jscore/"/>
      <url>/2022/12/21/wxapp-webview-jscore/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="微信小程序的实现原理？"><a href="#微信小程序的实现原理？" class="headerlink" title="微信小程序的实现原理？"></a>微信小程序的实现原理？</h1></li></ul><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>  网页开发，渲染线程和脚本是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应的原因，本质就是我们常说的 <code>JS</code> 是单线程的</p><p>  而在小程序中，选择了 <code>Hybrid</code> 的渲染方式，将视图层和逻辑层是分开的，双线程同时运行，视图层的界面使用 <code>WebView</code> 进行渲染，逻辑层运行在 <code>JSCore</code> 中</p><p>   <img src="https://static.vue-js.com/4e322e50-3722-11ec-8e64-91fdec0f05a1.png"></p><ul><li>渲染层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程</li><li>逻辑层：采用 JsCore 线程运行 JS 脚本，在这个环境下执行的都是有关小程序业务逻辑的代码</li></ul><h2 id="二、通信"><a href="#二、通信" class="headerlink" title="二、通信"></a>二、通信</h2><p>  小程序在渲染层，宿主环境会把<code>wxml</code>转化成对应的<code>JS</code>对象</p><p>  在逻辑层发生数据变更的时候，通过宿主环境提供的<code>setData</code>方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的<code>Dom</code>树上，渲染出正确的视图</p><p>   <img src="https://static.vue-js.com/5948ed10-3722-11ec-a752-75723a64e8f5.png"></p><p>  当视图存在交互的时候，例如用户点击你界面上某个按钮，这类反馈应该通知给开发者的逻辑层，需要将对应的处理状态呈现给用户</p><p>  对于事件的分发处理，微信进行了特殊的处理，将所有的事件拦截后，丢到逻辑层交给<code>JavaScript</code>进行处理</p><p>   <img src="https://static.vue-js.com/61f9f670-3722-11ec-a752-75723a64e8f5.png"></p><p>  由于小程序是基于双线程的，也就是任何在视图层和逻辑层之间的数据传递都是线程间的通信，会有一定的延时，因此在小程序中，页面更新成了异步操作</p><p>  异步会使得各部分的运行时序变得复杂一些，比如在渲染首屏的时候，逻辑层与渲染层会同时开始初始化工作，但是渲染层需要有逻辑层的数据才能把界面渲染出来</p><p>  如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作</p><p>  因此逻辑层与渲染层需要有一定的机制保证时序正确，在每个小程序页面的生命周期中，存在着若干次页面数据通信</p><p>   <img src="https://static.vue-js.com/6cb798b0-3722-11ec-a752-75723a64e8f5.png"></p><h2 id="三、运行机制"><a href="#三、运行机制" class="headerlink" title="三、运行机制"></a>三、运行机制</h2><p>  小程序启动运行两种情况：</p><ul><li>冷启动（重新开始）：用户首次打开或者小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即为冷启动</li><li>热启动：用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将后台态的小程序切换到前台，这个过程就是热启动</li></ul><h4 id="需要注意："><a href="#需要注意：" class="headerlink" title="需要注意："></a>需要注意：</h4><blockquote><p> 1.小程序没有重启的概念<br> 2.当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后会被微信主动销毁<br> 3.短时间内收到系统两次以上内存警告，也会对小程序进行销毁，这也就为什么一旦页面内存溢出，页面会奔溃的本质原因了</p></blockquote><p>   <img src="https://static.vue-js.com/968c8510-3722-11ec-a752-75723a64e8f5.png"></p><p>  开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户</p><p>  每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/0008a4c4f28f30fe3eb863b2750813">https://developers.weixin.qq.com/community/develop/article/doc/0008a4c4f28f30fe3eb863b2750813</a></li><li><a href="https://juejin.cn/post/6976805521407868958#heading-5">https://juejin.cn/post/6976805521407868958#heading-5</a></li><li><a href="https://juejin.cn/post/6844903805675388942">https://juejin.cn/post/6844903805675388942</a></li><li><a href="https://juejin.cn/post/6844903999863259144#heading-1">https://juejin.cn/post/6844903999863259144#heading-1</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wxapp_webview_jscore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对 TypeScript 中枚举类型的理解？应用场景？</title>
      <link href="/2022/12/20/ts-enum/"/>
      <url>/2022/12/20/ts-enum/</url>
      
        <content type="html"><![CDATA[<h1 id="对-TypeScript-中枚举类型的理解？应用场景？"><a href="#对-TypeScript-中枚举类型的理解？应用场景？" class="headerlink" title="对 TypeScript 中枚举类型的理解？应用场景？"></a>对 TypeScript 中枚举类型的理解？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>枚举是一个被命名的整型常数的集合，用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型</p><p>通俗来说，枚举就是一个对象的所有可能取值的集合</p><p>在日常生活中也很常见，例如表示星期的SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY、SATURDAY就可以看成是一个枚举</p><p>枚举的说明与结构和联合相似，其形式为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum 枚举名&#123;</span><br><span class="line">    标识符①[=整型常数],</span><br><span class="line">    标识符②[=整型常数],</span><br><span class="line">    ...</span><br><span class="line">    标识符N[=整型常数],</span><br><span class="line">&#125;枚举变量;</span><br></pre></td></tr></table></figure><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p>枚举的使用是通过<code>enum</code>关键字进行定义，形式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> xxx &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>声明关键字为枚举类型的方式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明d为枚举类型Direction</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: <span class="title class_">Direction</span>;</span><br></pre></td></tr></table></figure><p>类型可以分成：</p><ul><li><p>数字枚举</p></li><li><p>字符串枚举</p></li><li><p>异构枚举</p></li></ul><h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><p>当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从0开始依次累加:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,   <span class="comment">// 值默认为 0</span></span><br><span class="line">    <span class="title class_">Down</span>, <span class="comment">// 值默认为 1</span></span><br><span class="line">    <span class="title class_">Left</span>, <span class="comment">// 值默认为 2</span></span><br><span class="line">    <span class="title class_">Right</span> <span class="comment">// 值默认为 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Up</span> === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Down</span> === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Left</span> === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Right</span> === <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果我们将第一个值进行赋值后，后面的值也会根据前一个值进行累加1：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="number">10</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Up</span>, <span class="title class_">Direction</span>.<span class="property">Down</span>, <span class="title class_">Direction</span>.<span class="property">Left</span>, <span class="title class_">Direction</span>.<span class="property">Right</span>); <span class="comment">// 10 11 12 13</span></span><br></pre></td></tr></table></figure><h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">枚举类型的值其实也可以是字符串类型：</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="string">&#x27;Up&#x27;</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="string">&#x27;Down&#x27;</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="string">&#x27;Left&#x27;</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="string">&#x27;Right&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>[<span class="string">&#x27;Right&#x27;</span>], <span class="title class_">Direction</span>.<span class="property">Up</span>); <span class="comment">// Right Up</span></span><br></pre></td></tr></table></figure><p>如果设定了一个变量为字符串之后，后续的字段也需要赋值字符串，否则报错：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line"> <span class="title class_">Up</span> = <span class="string">&#x27;UP&#x27;</span>,</span><br><span class="line"> <span class="title class_">Down</span>, <span class="comment">// error TS1061: Enum member must have initializer</span></span><br><span class="line"> <span class="title class_">Left</span>, <span class="comment">// error TS1061: Enum member must have initializer</span></span><br><span class="line"> <span class="title class_">Right</span> <span class="comment">// error TS1061: Enum member must have initializer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h3><p>即将数字枚举和字符串枚举结合起来混合起来使用，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">BooleanLikeHeterogeneousEnum</span> &#123;</span><br><span class="line">    <span class="title class_">No</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="title class_">Yes</span> = <span class="string">&quot;YES&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下我们很少会使用异构枚举</p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>现在一个枚举的案例如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过编译后，<code>javascript</code>如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Up&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;Up&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Down&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Down&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Left&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Left&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Right&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>上述代码可以看到， <code>Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;</code>可以分成</p><ul><li>Direction[“Up”] &#x3D; 0</li><li>Direction[0] &#x3D; “Up”</li></ul><p>所以定义枚举类型后，可以通过正反映射拿到对应的值，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Up</span> === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>[<span class="number">0</span>]); <span class="comment">// Up</span></span><br></pre></td></tr></table></figure><p>并且多处定义的枚举是可以进行合并操作，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="string">&#x27;Up&#x27;</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="string">&#x27;Down&#x27;</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="string">&#x27;Left&#x27;</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="string">&#x27;Right&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Center</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后，<code>js</code>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Up&quot;</span>] = <span class="string">&quot;Up&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Down&quot;</span>] = <span class="string">&quot;Down&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Left&quot;</span>] = <span class="string">&quot;Left&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Right&quot;</span>] = <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;));</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Center&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Center&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>可以看到，<code>Direction</code>对象属性回叠加</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>就拿回生活的例子，后端返回的字段使用 0 - 6 标记对应的日期，这时候就可以使用枚举可提高代码可读性，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span>, <span class="title class_">Mon</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] === <span class="number">6</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>包括后端日常返回0、1 等等状态的时候，我们都可以通过枚举去定义，这样可以提高代码的可读性，便于后续的维护</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%9E%9A%E4%B8%BE">https://zh.wikipedia.org/wiki/%E6%9E%9A%E4%B8%BE</a></li><li><a href="https://www.jianshu.com/p/b9e1caa4dd98">https://www.jianshu.com/p/b9e1caa4dd98</a></li><li><a href="https://juejin.cn/post/6844904112669065224#heading-30">https://juejin.cn/post/6844904112669065224#heading-30</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts_enum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对 TypeScript 装饰器的理解？应用场景？</title>
      <link href="/2022/12/19/ts-decorator/"/>
      <url>/2022/12/19/ts-decorator/</url>
      
        <content type="html"><![CDATA[<h1 id="对-TypeScript-装饰器的理解？应用场景？"><a href="#对-TypeScript-装饰器的理解？应用场景？" class="headerlink" title="对 TypeScript 装饰器的理解？应用场景？"></a>对 TypeScript 装饰器的理解？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上</p><p>是一种在不改变原类和使用继承的情况下，动态地扩展对象功能</p><p>同样的，本质也不是什么高大上的结构，就是一个普通的函数，<code>@expression</code> 的形式其实是<code>Object.defineProperty</code>的语法糖</p><p><code>expression </code>求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入</p><h2 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h2><p>由于<code>typescript</code>是一个实验性特性，若要使用，需要在<code>tsconfig.json</code>文件启动，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ES5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typescript</code>装饰器的使用和<code>javascript</code>基本一致</p><p>类的装饰器可以装饰：</p><ul><li><p>类</p></li><li><p>方法&#x2F;属性</p></li><li><p>参数</p></li><li><p>访问器</p></li></ul><h3 id="类装饰"><a href="#类装饰" class="headerlink" title="类装饰"></a>类装饰</h3><p>例如声明一个函数 <code>addAge</code> 去给 Class 的属性 <code>age</code> 添加年龄.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addAge</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  constructor.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addAge</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age!: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;huihui&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>上述代码，实际等同于以下形式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span> = <span class="title function_">addAge</span>(<span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123; ... &#125;);</span><br></pre></td></tr></table></figure><p>上述可以看到，当装饰器作为修饰类的时候，会把构造器传递进去。 <code>constructor.prototype.age</code> 就是在每一个实例化对象上面添加一个 <code>age</code> 属性</p><h3 id="方法-属性装饰"><a href="#方法-属性装饰" class="headerlink" title="方法&#x2F;属性装饰"></a>方法&#x2F;属性装饰</h3><p>同样，装饰器可以用于修饰类的方法，这时候装饰器函数接收的参数变成了：</p><ul><li>target：对象的原型</li><li>propertyKey：方法的名称</li><li>descriptor：方法的属性描述符</li></ul><p>可以看到，这三个属性实际就是<code>Object.defineProperty</code>的三个参数，如果是类的属性，则没有传递第三个参数</p><p>如下例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明装饰器修饰方法/属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">method</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;prop &quot;</span> + propertyKey);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;desc &quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(descriptor) + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  descriptor.<span class="property">writable</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">property</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;target&quot;</span>, target)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;propertyKey&quot;</span>, propertyKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"> <span class="meta">@property</span></span><br><span class="line"> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;huihui&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@method</span></span><br><span class="line"> <span class="title function_">say</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;instance method&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@method</span></span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">run</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;static method&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xmz = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改实例方法say</span></span><br><span class="line">xmz.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;edit&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下图所示：</p><p> <img src="https://static.vue-js.com/e96bc1b0-114d-11ec-8e64-91fdec0f05a1.png"></p><h3 id="参数装饰"><a href="#参数装饰" class="headerlink" title="参数装饰"></a>参数装饰</h3><p>接收3个参数，分别是：</p><ul><li>target ：当前对象的原型</li><li>propertyKey ：参数的名称</li><li>index：参数数组中的位置</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logParameter</span>(<span class="params">target: <span class="built_in">Object</span>, propertyName: <span class="built_in">string</span>, index: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(propertyName);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="meta">@logParameter</span> <span class="attr">message</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`hello <span class="subst">$&#123;message&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> emp = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">emp.<span class="title function_">greet</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure><p>输入如下图：</p><p> <img src="https://static.vue-js.com/f2f32de0-114d-11ec-a752-75723a64e8f5.png"></p><h3 id="访问器装饰"><a href="#访问器装饰" class="headerlink" title="访问器装饰"></a>访问器装饰</h3><p>使用起来方式与方法装饰一致，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">modification</span>(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;prop &quot;</span> + propertyKey);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;desc &quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(descriptor) + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"> <span class="attr">_name</span>: <span class="built_in">string</span>;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="string">&#x27;huihui&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@modification</span></span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h3><p>如果想要传递参数，使装饰器变成类似工厂函数，只需要在装饰器函数内部再函数一个函数即可，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addAge</span>(<span class="params">age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    constructor.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addAge</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age!: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;huihui&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>当多个装饰器应用于一个声明上，将由上至下依次对装饰器表达式求值，求值的结果会被当作函数，由下至上依次调用，例如如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f(): evaluated&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f(): called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;g(): evaluated&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;g(): called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="meta">@f</span>()</span><br><span class="line">    <span class="meta">@g</span>()</span><br><span class="line">    <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="title function_">f</span>(): evaluated</span><br><span class="line"><span class="title function_">g</span>(): evaluated</span><br><span class="line"><span class="title function_">g</span>(): called</span><br><span class="line"><span class="title function_">f</span>(): called</span><br></pre></td></tr></table></figure><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>可以看到，使用装饰器存在两个显著的优点：</p><ul><li>代码可读性变强了，装饰器命名相当于一个注释</li><li>在不改变原有代码情况下，对原来功能进行扩展</li></ul><p>后面的使用场景中，借助装饰器的特性，除了提高可读性之后，针对已经存在的类，可以通过装饰器的特性，在不改变原有代码情况下，对原来功能进行扩展</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.tslang.cn/docs/handbook/decorators.html">https://www.tslang.cn/docs/handbook/decorators.html</a></li><li><a href="https://juejin.cn/post/6844903876605280269#heading-5">https://juejin.cn/post/6844903876605280269#heading-5</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts_decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript 的数据类型有哪些？</title>
      <link href="/2022/12/19/ts-data-type/"/>
      <url>/2022/12/19/ts-data-type/</url>
      
        <content type="html"><![CDATA[<h1 id="typescript-的数据类型有哪些？"><a href="#typescript-的数据类型有哪些？" class="headerlink" title="typescript 的数据类型有哪些？"></a>typescript 的数据类型有哪些？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>typescript</code> 和 <code>javascript</code>几乎一样，拥有相同的数据类型，另外在<code>javascript</code>基础上提供了更加实用的类型供开发使用</p><p>在开发阶段，可以为明确的变量定义为某种类型，这样<code>typescript</code>就能在编译阶段进行类型检查，当类型不合符预期结果的时候则会出现错误提示</p><h2 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h2><p><code>typescript</code> 的数据类型主要有如下：</p><ul><li>boolean（布尔类型）</li><li>number（数字类型）</li><li>string（字符串类型）</li><li>array（数组类型）</li><li>tuple（元组类型）</li><li>enum（枚举类型）</li><li>any（任意类型）</li><li>null 和 undefined 类型</li><li>void 类型</li><li>never 类型</li><li>object 对象类型</li></ul><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>布尔类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>:<span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// flag = 123; // 错误</span></span><br><span class="line">flag = <span class="literal">false</span>;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>数字类型，和<code>javascript</code>一样，<code>typescript</code>的数值类型都是浮点数，可支持二进制、八进制、十进制和十六进制</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// num = &#x27;456&#x27;; // 错误</span></span><br><span class="line">num = <span class="number">456</span>;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>进制表示：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: <span class="built_in">number</span> = <span class="number">6</span>; <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexLiteral</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span>; <span class="comment">// 十六进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryLiteral</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>; <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">octalLiteral</span>: <span class="built_in">number</span> = <span class="number">0o744</span>; <span class="comment">// 八进制</span></span><br></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>字符串类型，和<code>JavaScript</code>一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>:<span class="built_in">string</span> = <span class="string">&#x27;this is ts&#x27;</span>;</span><br><span class="line">str = <span class="string">&#x27;test&#x27;</span>;</span><br></pre></td></tr></table></figure><p>作为超集，当然也可以使用模版字符串&#96;&#96;进行包裹，通过 ${} 嵌入变量</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>数组类型，跟<code>javascript</code>一致，通过<code>[]</code>进行包裹，有两种写法：</p><p>方式一：元素类型后面接上 <code>[]</code></p> <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">string</span>[] = [<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;23&#x27;</span>];</span><br><span class="line">arr = [<span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;56&#x27;</span>];</span><br></pre></td></tr></table></figure><p>方式二：使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>  <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr = [<span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;56&#x27;</span>];</span><br></pre></td></tr></table></figure><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元祖类型，允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tupleArr</span>:[<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>];</span><br><span class="line">tupleArr = [<span class="number">12</span>, <span class="string">&#x27;34&#x27;</span>, <span class="literal">true</span>]; <span class="comment">//ok</span></span><br><span class="line">typleArr = [<span class="number">12</span>, <span class="string">&#x27;34&#x27;</span>] <span class="comment">// no ok</span></span><br></pre></td></tr></table></figure><p>赋值的类型、位置、个数需要和定义（生明）的类型、位置、个数一致</p><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>可以指定任何类型的值，在编程阶段还不清楚类型的变量指定一个类型，不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，这时候可以使用<code>any</code>类型</p><p>使用<code>any</code>类型允许被赋值为任意类型，甚至可以调用其属性、方法</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">any</span> = <span class="number">123</span>;</span><br><span class="line">num = <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line">num = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>定义存储各种类型数据的数组时，示例代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arrayList</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">false</span>, <span class="string">&#x27;fine&#x27;</span>];</span><br><span class="line">arrayList[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="null-和-和-undefined"><a href="#null-和-和-undefined" class="headerlink" title="null 和 和 undefined"></a>null 和 和 undefined</h3><p>在<code> JavaScript</code> 中 <code>null </code>表示 “什么都没有”，是一个只有一个值的特殊类型，表示一个空对象引用，而<code>undefined</code>表示一个没有设置值的变量</p><p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型， 就是说你可以把 <code>null </code>和 <code>undefined </code>赋值给 <code>number </code>类型的变量</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">number</span> | <span class="literal">undefined</span>; <span class="comment">// 数值类型 或者 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 正确</span></span><br><span class="line">num = <span class="number">123</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>但是<code>ts</code>配置了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自</p><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>用于标识方法返回值的类型，表示该方法没有返回值。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello Runoob&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p><code>never</code>是其他类型 （包括<code>null</code>和 <code>undefined</code>）的子类型，可以赋值给任何类型，代表从不会出现的值</p><p>但是没有类型是 never 的子类型，这意味着声明 <code>never</code> 的变量只能被 <code>never</code> 类型所赋值。</p><p><code>never</code> 类型一般用来指定那些总是会抛出异常、无限循环</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">never</span>;</span><br><span class="line">a = <span class="number">123</span>; <span class="comment">// 错误的写法</span></span><br><span class="line"></span><br><span class="line">a = (<span class="function">() =&gt;</span> &#123; <span class="comment">// 正确的写法</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;错误&#x27;</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>对象类型，非原始类型，常见的形式通过<code>&#123;&#125;</code>进行包裹</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="built_in">object</span>;</span><br><span class="line">obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;Wang&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>和<code>javascript</code>基本一致，也分成：</p><ul><li>基本类型</li><li>引用类型</li></ul><p>在基础类型上，<code>typescript</code>增添了<code>void</code>、<code>any</code>、<code>emum</code>等原始类型</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.tslang.cn/docs/handbook/basic-types.html">https://www.tslang.cn/docs/handbook/basic-types.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts_data_type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对 TypeScript 中类的理解？应用场景？</title>
      <link href="/2022/12/17/ts-class/"/>
      <url>/2022/12/17/ts-class/</url>
      
        <content type="html"><![CDATA[<h1 id="对-TypeScript-中类的理解？应用场景？"><a href="#对-TypeScript-中类的理解？应用场景？" class="headerlink" title="对 TypeScript 中类的理解？应用场景？"></a>对 TypeScript 中类的理解？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p><blockquote><p>类是一种用户定义的引用数据类型，也称类类型</p></blockquote><p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本</p><p>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多</p><p>但是<code> JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类</p><p><code>TypeScript</code> 的 <code>class</code>  支持面向对象的所有特性，比如 类、接口等</p><h2 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h2><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：</p><ul><li><strong>字段</strong> ： 字段是类里面声明的变量。字段表示对象的有关数据。</li><li><strong>构造函数</strong>： 类实例化时调用，可以为类的对象分配内存。</li><li><strong>方法</strong>： 方法为对象要执行的操作</li></ul><p>如下例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// 字段</span></span><br><span class="line">    <span class="attr">engine</span>:<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">engine:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">engine</span> = engine</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="title function_">disp</span>():<span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发动机为 :   &quot;</span>+<span class="variable language_">this</span>.<span class="property">engine</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>类的继承使用过<code>extends</code>的关键字</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Animal moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Woof! Woof!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">dog.<span class="title function_">bark</span>();</span><br><span class="line">dog.<span class="title function_">move</span>(<span class="number">10</span>);</span><br><span class="line">dog.<span class="title function_">bark</span>();</span><br></pre></td></tr></table></figure><p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 超类</p><p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法</p><p>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写，通过<code>super</code>关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrinterClass</span> &#123;</span><br><span class="line">   <span class="title function_">doPrint</span>():<span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;父类的 doPrint() 方法。&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringPrinter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PrinterClass</span> &#123;</span><br><span class="line">   <span class="title function_">doPrint</span>():<span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">doPrint</span>() <span class="comment">// 调用父类的函数</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;子类的 doPrint()方法。&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>可以看到，上述的形式跟<code>ES6</code>十分的相似，<code>typescript</code>在此基础上添加了三种修饰符：</p><ul><li>公共 public：可以自由的访问类程序里定义的成员</li><li>私有 private：只能够在该类的内部进行访问</li><li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li></ul><h3 id="私有修饰符"><a href="#私有修饰符" class="headerlink" title="私有修饰符"></a>私有修饰符</h3><p>只能够在该类的内部进行访问，实例对象并不能够访问</p><p> <img src="https://static.vue-js.com/f57365f0-0cb4-11ec-a752-75723a64e8f5.png"></p><p>并且继承该类的子类并不能访问，如下图所示：</p><p> <img src="https://static.vue-js.com/0072cc20-0cb5-11ec-8e64-91fdec0f05a1.png"></p><h3 id="受保护修饰符"><a href="#受保护修饰符" class="headerlink" title="受保护修饰符"></a>受保护修饰符</h3><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p><p> <img src="https://static.vue-js.com/09e72580-0cb5-11ec-a752-75723a64e8f5.png"></p><p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p><p> <img src="https://static.vue-js.com/137f81a0-0cb5-11ec-8e64-91fdec0f05a1.png"></p><p>除了上述修饰符之外，还有只读<strong>修饰符</strong></p><h4 id="只读修饰符"><a href="#只读修饰符" class="headerlink" title="只读修饰符"></a>只读修饰符</h4><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p><p> <img src="https://static.vue-js.com/1e848d20-0cb5-11ec-8e64-91fdec0f05a1.png"></p><p>除了实例属性之外，同样存在静态属性</p><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> width = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Square</span>.<span class="property">width</span>) <span class="comment">// 100px</span></span><br></pre></td></tr></table></figure><p>上述的类都能发现一个特点就是，都能够被实例化，在 <code>typescript</code>中，还存在一种抽象类</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节</p><p><code>abstract </code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">makeSound</span>(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">move</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;roaming the earch...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">makeSound</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;miao miao&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>()</span><br><span class="line"></span><br><span class="line">cat.<span class="title function_">makeSound</span>() <span class="comment">// miao miao</span></span><br><span class="line">cat.<span class="title function_">move</span>() <span class="comment">// roaming the earch...</span></span><br></pre></td></tr></table></figure><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在 <code>React</code> 工程中是很常用的，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Carousel</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;<span class="title class_">Props</span>, <span class="title class_">State</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>由于组件需要传入 <code>props</code> 的类型 <code>Props</code> ，同时有需要设置默认 <code>props</code> 即 <code>defaultProps</code>，这时候更加适合使用<code>class</code>作为接口</p><p>先声明一个类，这个类包含组件 <code>props</code> 所需的类型和初始值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// props的类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">children</span>: <span class="title class_">Array</span>&lt;<span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt;&gt; | <span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt; | <span class="built_in">never</span>[] = []</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">speed</span>: <span class="built_in">number</span> = <span class="number">500</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">height</span>: <span class="built_in">number</span> = <span class="number">160</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">animation</span>: <span class="built_in">string</span> = <span class="string">&#x27;easeInOutQuad&#x27;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">isAuto</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">autoPlayInterval</span>: <span class="built_in">number</span> = <span class="number">4500</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">afterChange</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">beforeChange</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">selesctedColor</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">showDots</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> defaultProps = <span class="keyword">new</span> <span class="title class_">Props</span>()</span><br></pre></td></tr></table></figure><p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class </code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.tslang.cn/docs/handbook/classes.html">https://www.tslang.cn/docs/handbook/classes.html</a></li><li><a href="https://www.runoob.com/typescript/ts-class.html">https://www.runoob.com/typescript/ts-class.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> typeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts_class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序的支付流程？</title>
      <link href="/2022/11/07/wxapp-requestPayment/"/>
      <url>/2022/11/07/wxapp-requestPayment/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序的支付流程？"><a href="#微信小程序的支付流程？" class="headerlink" title="微信小程序的支付流程？"></a>微信小程序的支付流程？</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>微信小程序为电商类小程序，提供了非常完善、优秀、安全的支付功能</p><p>在小程序内可调用微信的<code>API</code>完成支付功能，方便、快捷</p><p>场景如下图所示：</p><p> <img src="https://static.vue-js.com/6e0cff40-34a0-11ec-a752-75723a64e8f5.png"></p><p> <img src="https://static.vue-js.com/34864830-34a0-11ec-8e64-91fdec0f05a1.png"></p><ul><li>用户通过分享或扫描二维码进入商户小程序，用户选择购买，完成选购流程</li><li>调起微信支付控件，用户开始输入支付密码</li><li>密码验证通过，支付成功。商户后台得到支付成功的通知</li><li>返回商户小程序，显示购买成功</li><li>微信支付公众号下发支付凭证</li></ul><h2 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h2><p>以电商小程序为例</p><p>支付流程图如下所示：</p><p> <img src="https://static.vue-js.com/76b66780-34a0-11ec-8e64-91fdec0f05a1.png"></p><p>具体的做法：</p><ul><li>打开某小程序，点击直接下单</li><li>wx.login获取用户临时登录凭证code，发送到后端服务器换取openId</li><li>在下单时，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器</li><li>服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息</li><li>小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付</li><li>接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付</li><li>鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示</li><li>推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态</li></ul><p>其中后端响应数据必要的信息则是<code>wx.requestPayment</code>方法所需要的参数，大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">requestPayment</span>(&#123;</span><br><span class="line">  <span class="comment">// 时间戳</span></span><br><span class="line">  <span class="attr">timeStamp</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="comment">// 随机字符串</span></span><br><span class="line">  <span class="attr">nonceStr</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="comment">// 统一下单接口返回的 prepay_id 参数值</span></span><br><span class="line">  <span class="attr">package</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="comment">// 签名类型</span></span><br><span class="line">  <span class="attr">signType</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="comment">// 签名</span></span><br><span class="line">  <span class="attr">paySign</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="comment">// 调用成功回调</span></span><br><span class="line">  success () &#123;&#125;,</span><br><span class="line">  <span class="comment">// 失败回调</span></span><br><span class="line">  fail () &#123;&#125;,</span><br><span class="line">  <span class="comment">// 接口调用结束回调</span></span><br><span class="line">  complete () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>参数表如下所示：</p><p><img src="https://files.mdnice.com/user/155/48efed1f-d67f-45a7-ab2c-89a6424fafa0.png"></p><h2 id="三、结束"><a href="#三、结束" class="headerlink" title="三、结束"></a>三、结束</h2><p>小程序支付和以往的网页、APP微信支付大同小异，可以说小程序的支付变得更加简洁，不需要设置支付目录、域名授权等操作</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_8_0.shtml">https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_8_0.shtml</a></li><li><a href="https://juejin.cn/post/6844903895970349064">https://juejin.cn/post/6844903895970349064</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wxapp_requestPayment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说提高微信小程序的应用速度的手段有哪些？</title>
      <link href="/2022/06/27/wxapp-optimization/"/>
      <url>/2022/06/27/wxapp-optimization/</url>
      
        <content type="html"><![CDATA[<h1 id="说说提高微信小程序的应用速度的手段有哪些？"><a href="#说说提高微信小程序的应用速度的手段有哪些？" class="headerlink" title="说说提高微信小程序的应用速度的手段有哪些？"></a>说说提高微信小程序的应用速度的手段有哪些？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>小程序启动会常常遇到如下图场景：</p><p> <img src="https://static.vue-js.com/03941230-3279-11ec-8e64-91fdec0f05a1.png"></p><p>这是因为，小程序首次启动前，微信会在小程序启动前为小程序准备好通用的运行环境，如运行中的线程和一些基础库的初始化</p><p>然后才开始进入启动状态，展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：</p><ul><li>下载小程序代码包</li><li>加载小程序代码包</li><li>初始化小程序首页</li></ul><p>下载到的小程序代码包不是小程序的源代码，而是编译、压缩、打包之后的代码包</p><p>整体流程如下图：</p><p> <img src="https://static.vue-js.com/11c0ea90-3279-11ec-a752-75723a64e8f5.png"></p><h2 id="二、手段"><a href="#二、手段" class="headerlink" title="二、手段"></a>二、手段</h2><p>围绕上图小程序的启动流程， 我们可以从加载、渲染两个纬度进行切入：</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>提升体验最直接的方法是控制小程序包的大小，常见手段有如下：</p><ul><li><p>代码包的体积压缩可以通过勾选开发者工具中“上传代码时，压缩代码”选项</p></li><li><p>及时清理无用的代码和资源文件</p></li><li><p>减少资源包中的图片等资源的数量和大小（理论上除了小icon，其他图片资源从网络下载），图片资源压缩率有限</p></li></ul><p>并且可以采取分包加载的操作，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载</p><p>当用户点击到子包的目录时，还是有一个代码包下载的过程，这会感觉到明显的卡顿，所以子包也不建议拆的太大，当然我们可以采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包</p><p> <img src="https://static.vue-js.com/2034de10-3279-11ec-8e64-91fdec0f05a1.png"></p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>关于微信小程序首屏渲染优化的手段如下：</p><ul><li>请求可以在页面onLoad就加载，不需要等页面ready后在异步请求数据</li><li>尽量减少不必要的https请求，可使用 getStorageSync() 及 setStorageSync() 方法将数据存储在本地</li><li>可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据–&gt; 详情页），没有数据的模块可以进行骨架屏的占位</li></ul><p>在微信小程序中，提高页面的多次渲染效率主要在于正确使用<code>setData</code>：</p><ul><li>不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用</li><li>数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用<code>setData</code>来设置这些数据</li><li>与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下</li></ul><p>除此之外，对于一些独立的模块我们尽可能抽离出来，这是因为自定义组件的更新并不会影响页面上其他元素的更新</p><p>各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、<code>setData</code>调用</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><strong>小程序启动加载性能</strong>：</p><ul><li>控制代码包的大小</li><li>分包加载</li><li>首屏体验（预请求，利用缓存，避免白屏，及时反馈</li></ul><p><strong>小程序渲染性能</strong>：</p><ul><li>避免不当的使用setData</li><li>使用自定义组件</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://juejin.cn/post/6969779451177484296">https://juejin.cn/post/6969779451177484296</a></li><li><a href="https://segmentfault.com/a/1190000008925450">https://segmentfault.com/a/1190000008925450</a></li><li><a href="https://juejin.cn/post/6844903638226173965">https://juejin.cn/post/6844903638226173965</a></li><li><a href="https://juejin.cn/post/6844903726939897869">https://juejin.cn/post/6844903726939897869</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wxapp_optimization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说微信小程序的发布流程？</title>
      <link href="/2022/04/23/wxapp-publish/"/>
      <url>/2022/04/23/wxapp-publish/</url>
      
        <content type="html"><![CDATA[<h1 id="说说微信小程序的发布流程？"><a href="#说说微信小程序的发布流程？" class="headerlink" title="说说微信小程序的发布流程？"></a>说说微信小程序的发布流程？</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>在中大型的公司里，人员的分工非常仔细，一般会有不同岗位角色的员工同时参与同一个小程序项目。为此，小程序平台设计了不同的权限管理使得项目管理者可以更加高效管理整个团队的协同工作</p><p> <img src="https://static.vue-js.com/e76aff50-3652-11ec-8e64-91fdec0f05a1.png"></p><p>以往我们在开发完网页之后，需要把网页的代码和资源放在服务器上，让用户通过互联网来访问</p><p>在小程序的平台里，开发者完成开发之后，需要在开发者工具提交小程序的代码包，然后在小程序后台发布小程序</p><p> <img src="https://static.vue-js.com/fe5da190-3652-11ec-8e64-91fdec0f05a1.png"></p><h2 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h2><p>关于发布的流程，主要分成了三个部分：</p><ul><li>上传代码</li><li>提交审核</li><li>发布版本</li></ul><h3 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h3><p>在开发者工具中，可以点击代码上传功能：</p><p> <img src="https://static.vue-js.com/08f19bc0-3653-11ec-a752-75723a64e8f5.png"></p><p>然后就可以填写版本信息：</p><p> <img src="https://static.vue-js.com/1d02c8f0-3653-11ec-a752-75723a64e8f5.png"></p><p>然后点击上传，编译器则会提示上传代码成功</p><h3 id="提交审核"><a href="#提交审核" class="headerlink" title="提交审核"></a>提交审核</h3><p>代码上传完毕，就可以登陆微信公众号的官网首页，点击【开发管理】，查看应用详情：</p><p> <img src="https://static.vue-js.com/281038e0-3653-11ec-8e64-91fdec0f05a1.png"></p><p>提交审核过程需要填写审核信息，如下图：</p><p> <img src="https://static.vue-js.com/33d97ec0-3653-11ec-a752-75723a64e8f5.png"></p><p>提交审核成功之后如下图：</p><p> <img src="https://static.vue-js.com/3e4c3550-3653-11ec-a752-75723a64e8f5.png"></p><h3 id="发布版本"><a href="#发布版本" class="headerlink" title="发布版本"></a>发布版本</h3><p>当审核通过之后，即可提交发布</p><p> <img src="https://static.vue-js.com/495140d0-3653-11ec-8e64-91fdec0f05a1.png"></p><p>发布成功之后则如下：</p><p> <img src="https://static.vue-js.com/5293b4c0-3653-11ec-8e64-91fdec0f05a1.png"></p><h2 id="三、扩展"><a href="#三、扩展" class="headerlink" title="三、扩展"></a>三、扩展</h2><p>上述是最简单的小程序代码发布的流程，通常的流程如下：</p><ul><li>代码管理服务器上新建分支</li><li>开发测试新需求</li><li>测试完成后，将本地分支合并到 master 分支</li><li>拉取 master 分支最新代码，执行 build 命令生成小程序可执行文件</li><li>开发者工具点击“上传”</li><li>提审</li><li>发布</li></ul><p>但是面对多人协调开发的时候，有可能出现已经上线的代码还没合并到<code>master</code>的情况</p><p>因此可以考虑自动化构建部署，就是将从开发到部署的一系列流程变成自动化，衔接连贯，在构建失败时能够告知开发者，构建成功后能够告知测试和实施人员，可参考如下流程图：</p><p> <img src="https://static.vue-js.com/602d9bf0-3653-11ec-a752-75723a64e8f5.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6994414162700927012">https://juejin.cn/post/6994414162700927012</a></li><li><a href="https://www.leapcloud.cn/website/docs/doc_config/xiaochengxu/xiaochengxu.html">https://www.leapcloud.cn/website/docs/doc_config/xiaochengxu/xiaochengxu.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wxapp_publish </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说微信小程序中路由跳转的方式有哪些？区别？</title>
      <link href="/2022/04/17/wxapp-navigate/"/>
      <url>/2022/04/17/wxapp-navigate/</url>
      
        <content type="html"><![CDATA[<h1 id="说说微信小程序中路由跳转的方式有哪些？区别？"><a href="#说说微信小程序中路由跳转的方式有哪些？区别？" class="headerlink" title="说说微信小程序中路由跳转的方式有哪些？区别？"></a>说说微信小程序中路由跳转的方式有哪些？区别？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>微信小程序拥有<code>web</code>网页和<code>Application</code>共同的特征，我们的页面都不是孤立存在的，而是通过和其他页面进行交互，来共同完成系统的功能</p><p>在微信小程序中，每个页面可以看成是一个<code> pageModel</code>，<code>pageModel </code>全部以栈的形式进行管理</p><h2 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h2><p>常见的微信小程序页面跳转方式有如下：</p><ul><li>wx.navigateTo(Object)</li><li>wx.redirectTo(Object)</li><li>wx.switchTab(Object)</li><li>wx.navigateBack(Object)</li><li>wx.reLaunch(Object)</li></ul><h3 id="wx-navigateTo-Object"><a href="#wx-navigateTo-Object" class="headerlink" title="wx.navigateTo(Object)"></a>wx.navigateTo(Object)</h3><p><code>wx.navigateTo()</code>用于保留当前页面、跳转到应用内的某个页面，使用 <code>wx.navigateBack</code>可以返回到原页面</p><p>对于页面不是特别多的小程序，通常推荐使用 <code>wx.navigateTo</code>进行跳转， 以便返回原页面，以提高加载速度。当页面特别多时，则不推荐使用</p><p>参数表如下所示：</p><p> <img src="https://static.vue-js.com/5e524ea0-31a5-11ec-8e64-91fdec0f05a1.png"></p><p>流程图如下：</p><p> <img src="https://static.vue-js.com/68f033e0-31a5-11ec-8e64-91fdec0f05a1.png"></p><h3 id="wx-redirectTo-Object"><a href="#wx-redirectTo-Object" class="headerlink" title="wx.redirectTo(Object)"></a>wx.redirectTo(Object)</h3><p>重定向，当页面过多时，被保留页面会挤占微信分配给小程序的内存，或是达到微信所限制的 10 层页面栈的情况下，我们应该考虑选择 <code>wx.redirectTo</code></p><p><code>wx.redirectTo()</code>用于关闭当前页面，跳转到应用内的某个页面</p><p>这样的跳转，可以避免跳转前页面占据运行内存，但返回时页面需要重新加载，增加了返回页面的显示时间</p><p>参数表如下所示：</p><p> <img src="https://static.vue-js.com/76066c20-31a5-11ec-8e64-91fdec0f05a1.png"></p><p>流程图如下所示：</p><p> <img src="https://static.vue-js.com/828c4b40-31a5-11ec-a752-75723a64e8f5.png"></p><h3 id="wx-switchTab-Object"><a href="#wx-switchTab-Object" class="headerlink" title="wx.switchTab(Object)"></a>wx.switchTab(Object)</h3><p>跳转到 <code>tabBar </code>页面，并关闭其他所有非 <code>tabBar</code> 页面</p><p>参数表如下所示：</p><p> <img src="https://static.vue-js.com/968869d0-31a5-11ec-a752-75723a64e8f5.png"></p><h3 id="wx-navigateBack-Object"><a href="#wx-navigateBack-Object" class="headerlink" title="wx.navigateBack(Object)"></a>wx.navigateBack(Object)</h3><p><code>wx.navigateBack()</code> 用于关闭当前页面，并返回上一页面或多级页面，开发者可通过 <code>getCurrentPages()</code> 获取当前的页面栈，决定需要返回几层则设置对象的<code>delta</code>属性即可</p><p>参数表如下：</p><p> <img src="https://static.vue-js.com/a28d8030-31a5-11ec-a752-75723a64e8f5.png"></p><h3 id="wx-reLaunch-Object"><a href="#wx-reLaunch-Object" class="headerlink" title="wx.reLaunch(Object)"></a>wx.reLaunch(Object)</h3><p>关闭所有页面，打开到应用内的某个页面，返回的时候跳到首页</p><p>流程图如下所示：</p><p> <img src="https://static.vue-js.com/accca3a0-31a5-11ec-8e64-91fdec0f05a1.png"></p><p>参数表如下所示：</p><p> <img src="https://static.vue-js.com/b98c7e80-31a5-11ec-8e64-91fdec0f05a1.png"></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>关于上述五种跳转方式，做下总结：</p><ul><li>navigateTo 保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页</li><li>redirectTo 关闭当前页面，跳转到应用内的某个页面</li><li>switchTab 跳转到 tabBar 页面，同时关闭其他非 tabBar 页面</li><li>navigateBack 返回上一页面</li><li>reLanch 关闭所有页面，打开到应用内的某个页面</li></ul><p>其中关于它们的页面栈的关系如下：</p><ul><li><p>avigateTo 新页面入栈</p></li><li><p>redirectTo 当前页面出栈，新页面入栈</p></li><li><p>navigateBack 页面不断出栈，直到目标返回页，新页面入栈</p></li><li><p>switchTab 页面全部出栈，只留下新的 Tab 页面</p></li><li><p>reLanch 页面全部出栈，只留下新的页面</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html">https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wxapp_navigate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说微信小程序的登录流程？</title>
      <link href="/2022/03/03/wxapp-login/"/>
      <url>/2022/03/03/wxapp-login/</url>
      
        <content type="html"><![CDATA[<h1 id="说说微信小程序的登录流程？"><a href="#说说微信小程序的登录流程？" class="headerlink" title="说说微信小程序的登录流程？"></a>说说微信小程序的登录流程？</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>传统的<code>web</code>开发实现登陆功能，一般的做法是输入账号密码、或者输入手机号及短信验证码进行登录</p><p>服务端校验用户信息通过之后，下发一个代表登录态的 <code>token</code> 给客户端，以便进行后续的交互,每当<code>token</code>过期，用户都需要重新登录</p><p>而在微信小程序中，可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系，从而实现登陆功能</p><p>实现小程序用户体系主要涉及到<code>openid</code>和<code>code</code>的概念：</p><ul><li>调用<code>wx.login()</code>方法会生成<code>code</code>，将<code>code</code>作为参数传递给微信服务器指定接口，就可以获取用户的<code>openid</code></li></ul><p>对于每个小程序，微信都会将用户的微信<code>ID</code>映射出一个小程序 <code>openid</code>，作为这个用户在这个小程序的唯一标识</p><h2 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h2><p>微信小程序登陆具体实现的逻辑如下图所示：</p><p> <img src="https://static.vue-js.com/b60638c0-3428-11ec-a752-75723a64e8f5.png"></p><ul><li>通过  wx.login()  获取到用户的code判断用户是否授权读取用户信息，调用wx.getUserInfo 读取用户数据</li><li>由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息</li><li>通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret  和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到</li><li>微信服务器返回了 openid 及本次登录的会话密钥 session_key</li><li>后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走</li><li>session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输</li><li>然后生成 session并返回给小程序</li><li>小程序把 session 存到  storage 里面</li><li>下次请求时，先从 storage 里面读取，然后带给服务端</li><li>服务端对比 session 对应的记录，然后校验有效期</li></ul><p>更加详细的功能图如下所示：</p><p> <img src="https://static.vue-js.com/c3cfbb70-3428-11ec-8e64-91fdec0f05a1.png"></p><h2 id="三、扩展"><a href="#三、扩展" class="headerlink" title="三、扩展"></a>三、扩展</h2><p>实际业务中，我们还需要登录态是否过期，通常的做法是在登录态（临时令牌）中保存有效期数据，该有效期数据应该在服务端校验登录态时和约定的时间（如服务端本地的系统时间或时间服务器上的标准时间）做对比</p><p>这种方法需要将本地存储的登录态发送到小程序的服务端，服务端判断为无效登录态时再返回需重新执行登录过程的消息给小程</p><p>另一种方式可以通过调用<code>wx.checkSession</code>检查微信登陆态是否过期：</p><ul><li>如果过期，则发起完整的登录流程</li><li>如果不过期，则继续使用本地保存的自定义登录态</li></ul><p>这种方式的好处是不需要小程序服务端来参与校验，而是在小程序端调用AP，流程如下所示：</p><p> <img src="https://static.vue-js.com/8b446d30-349d-11ec-a752-75723a64e8f5.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000016750340">https://segmentfault.com/a/1190000016750340</a></li><li><a href="https://juejin.cn/post/6955754095860776973">https://juejin.cn/post/6955754095860776973</a></li><li><a href="https://www.cnblogs.com/zwh0910/p/13977278.html">https://www.cnblogs.com/zwh0910/p/13977278.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wxapp_login </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说微信小程序的生命周期函数有哪些？</title>
      <link href="/2022/01/04/wxapp-lifecycle/"/>
      <url>/2022/01/04/wxapp-lifecycle/</url>
      
        <content type="html"><![CDATA[<h1 id="说说微信小程序的生命周期函数有哪些？"><a href="#说说微信小程序的生命周期函数有哪些？" class="headerlink" title="说说微信小程序的生命周期函数有哪些？"></a>说说微信小程序的生命周期函数有哪些？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>跟<code>vue</code>、<code>react</code>框架一样，微信小程序框架也存在生命周期，实质也是一堆会在特定时期执行的函数</p><p>小程序中，生命周期主要分成了三部分：</p><ul><li>应用的生命周期</li><li>页面的生命周期</li><li>组件的生命周期</li></ul><h3 id="应用的生命周期"><a href="#应用的生命周期" class="headerlink" title="应用的生命周期"></a>应用的生命周期</h3><p>小程序的生命周期函数是在<code>app.js</code>里面调用的，通过<code>App(Object)</code>函数用来注册一个小程序，指定其小程序的生命周期回调</p><h3 id="页面的生命周期"><a href="#页面的生命周期" class="headerlink" title="页面的生命周期"></a>页面的生命周期</h3><p>页面生命周期函数就是当你每进入&#x2F;切换到一个新的页面的时候，就会调用的生命周期函数，同样通过<code>App(Object)</code>函数用来注册一个页面</p><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p>组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发，通过<code>Component(Object)</code>进行注册组件</p><h2 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h2><h3 id="应用的生命周期-1"><a href="#应用的生命周期-1" class="headerlink" title="应用的生命周期"></a>应用的生命周期</h3><table><thead><tr><th>生命周期</th><th>说明</th></tr></thead><tbody><tr><td>onLaunch</td><td>小程序初始化完成时触发，全局只触发一次</td></tr><tr><td>onShow</td><td>小程序启动，或从后台进入前台显示时触发</td></tr><tr><td>onHide</td><td>小程序从前台进入后台时触发</td></tr><tr><td>onError</td><td>小程序发生脚本错误或 API 调用报错时触发</td></tr><tr><td>onPageNotFound</td><td>小程序要打开的页面不存在时触发</td></tr><tr><td>onUnhandledRejection()</td><td>小程序有未处理的 Promise 拒绝时触发</td></tr><tr><td>onThemeChange</td><td>系统切换主题时触发</td></tr></tbody></table><h3 id="页面的生命周期-1"><a href="#页面的生命周期-1" class="headerlink" title="页面的生命周期"></a>页面的生命周期</h3><table><thead><tr><th>生命周期</th><th>说明</th><th>作用</th></tr></thead><tbody><tr><td>onLoad</td><td>生命周期回调—监听页面加载</td><td>发送请求获取数据</td></tr><tr><td>onShow</td><td>生命周期回调—监听页面显示</td><td>请求数据</td></tr><tr><td>onReady</td><td>生命周期回调—监听页面初次渲染完成</td><td>获取页面元素（少用）</td></tr><tr><td>onHide</td><td>生命周期回调—监听页面隐藏</td><td>终止任务，如定时器或者播放音乐</td></tr><tr><td>onUnload</td><td>生命周期回调—监听页面卸载</td><td>终止任务</td></tr></tbody></table><h3 id="组件的生命周期-1"><a href="#组件的生命周期-1" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><table><thead><tr><th>生命周期</th><th>说明</th></tr></thead><tbody><tr><td>created</td><td>生命周期回调—监听页面加载</td></tr><tr><td>attached</td><td>生命周期回调—监听页面显示</td></tr><tr><td>ready</td><td>生命周期回调—监听页面初次渲染完成</td></tr><tr><td>moved</td><td>生命周期回调—监听页面隐藏</td></tr><tr><td>detached</td><td>生命周期回调—监听页面卸载</td></tr><tr><td>error</td><td>每当组件方法抛出错误时执行</td></tr></tbody></table><p>注意的是：</p><ul><li>组件实例刚刚被创建好时， created 生命周期被触发，此时，组件数据 this.data 就是在 Component  构造器中定义的数据 data ， 此时不能调用 setData</li><li>在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行</li><li>在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则  detached 会被触发</li></ul><p>还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理，这样的生命周期称为“组件所在页面的生命周期”，在 <code>pageLifetimes</code> 定义段中定义，如下：</p><table><thead><tr><th>生命周期</th><th>说明</th></tr></thead><tbody><tr><td>show</td><td>组件所在的页面被展示时执行</td></tr><tr><td>hide</td><td>组件所在的页面被隐藏时执行</td></tr></tbody></table><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">pageLifetimes</span>: &#123;</span><br><span class="line">    <span class="attr">show</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 页面被展示</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">hide</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 页面被隐藏</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="三、执行过程"><a href="#三、执行过程" class="headerlink" title="三、执行过程"></a>三、执行过程</h2><h3 id="应⽤的⽣命周期执行过程："><a href="#应⽤的⽣命周期执行过程：" class="headerlink" title="应⽤的⽣命周期执行过程："></a>应⽤的⽣命周期执行过程：</h3><ul><li><p>⽤户⾸次打开⼩程序，触发 onLaunch（全局只触发⼀次）</p></li><li><p>⼩程序初始化完成后，触发onShow⽅法，监听⼩程序显示</p></li><li><p>⼩程序从前台进⼊后台，触发 onHide⽅法</p></li><li><p>⼩程序从后台进⼊前台显示，触发 onShow⽅法</p></li><li><p>⼩程序后台运⾏⼀定时间，或系统资源占⽤过⾼，会被销毁</p></li></ul><h3 id="⻚⾯⽣命周期的执行过程："><a href="#⻚⾯⽣命周期的执行过程：" class="headerlink" title="⻚⾯⽣命周期的执行过程："></a>⻚⾯⽣命周期的执行过程：</h3><ul><li>⼩程序注册完成后，加载⻚⾯，触发onLoad⽅法</li><li>⻚⾯载⼊后触发onShow⽅法，显示⻚⾯</li><li>⾸次显示⻚⾯，会触发onReady⽅法，渲染⻚⾯元素和样式，⼀个⻚⾯只会调⽤⼀次</li><li>当⼩程序后台运⾏或跳转到其他⻚⾯时，触发onHide⽅法</li><li>当⼩程序有后台进⼊到前台运⾏或重新进⼊⻚⾯时，触发onShow⽅法</li><li>当使⽤重定向⽅法 wx.redirectTo() 或关闭当前⻚返回上⼀⻚wx.navigateBack()，触发onUnload</li></ul><p>当存在也应用生命周期和页面周期的时候，相关的执行顺序如下：</p><ul><li><p>打开小程序：(App)onLaunch –&gt; (App)onShow –&gt; (Pages)onLoad –&gt; (Pages)onShow –&gt; (pages)onRead</p></li><li><p>进入下一个页面：(Pages)onHide –&gt; (Next)onLoad –&gt; (Next)onShow –&gt; (Next)onReady</p></li><li><p>返回上一个页面：(curr)onUnload –&gt; (pre)onShow</p></li><li><p>离开小程序：(App)onHide</p></li><li><p>再次进入：小程序未销毁 –&gt; (App)onShow(执行上面的顺序），小程序被销毁，（App)onLaunch重新开始执行.</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object">https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onLoad-Object-query">https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onLoad-Object-query</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object">https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wxapp_lifecycle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说你对微信小程序的理解？优缺点？</title>
      <link href="/2022/01/01/wxapp-applet/"/>
      <url>/2022/01/01/wxapp-applet/</url>
      
        <content type="html"><![CDATA[<h1 id="说说你对微信小程序的理解？优缺点？"><a href="#说说你对微信小程序的理解？优缺点？" class="headerlink" title="说说你对微信小程序的理解？优缺点？"></a>说说你对微信小程序的理解？优缺点？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>2017年，微信正式推出了小程序，允许外部开发者在微信内部运行自己的代码，开展业务</p><p>截至目前，小程序已经成为国内前端的一个重要业务，跟 <code>Web</code> 和手机 <code>App</code> 有着同等的重要性</p><p> <img src="https://static.vue-js.com/ce751de0-300e-11ec-8e64-91fdec0f05a1.png"></p><p>小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用</p><p>也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载</p><p>注意的是，除了微信小程序，还有百度小程序、微信小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序</p><h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>⼩程序并⾮凭空冒出来的⼀个概念，当微信中的 <code>WebView</code> 逐渐成为移动 <code>Web</code>的⼀个重要⼊⼝时，微信就有相关的 <code>JS-SDK</code></p><p><code>JS-SDK</code> 解决了移动⽹⻚能⼒不⾜的问题，通过暴露微信的接⼝使得 <code>Web</code> 开发者能够拥有更多的能⼒，然⽽在更多的能⼒之外，<code>JS-SDK</code>的模式并没有解决使⽤移动⽹⻚遇到的体验不良的问题</p><p>因此需要设计⼀个⽐较好的系统，使得所有开发者在微信中都能获得⽐较好的体验：</p><ul><li>快速的加载</li><li>更强⼤的能⼒</li><li>原⽣的体验</li><li>易⽤且安全的微信数据开放</li><li>⾼效和简单的开发</li></ul><p>这些是<code>JS-SDK</code>做不到的，需要设计一个全新的小程序系统</p><p>对于小程序的开发，提供一个简单、高效的应用开发框架和丰富的组件及<code>API</code>，帮助开发者开发出具有原生体验的服务</p><p>其中相比<code>H5</code>，小程序与其的区别有如下：</p><ul><li>运⾏环境：⼩程序基于浏览器内核重构的内置解析器</li><li>系统权限：⼩程序能获得更多的系统权限，如⽹络通信状态、数据缓存能⼒等</li><li>渲染机制：⼩程序的逻辑层和渲染层是分开的</li></ul><p>小程序可以视为只能用微信打开和浏览的<code>H5</code>，小程序和网页的技术模型是一样的，用到的 <code>JavaScript</code> 语言和 <code>CSS</code> 样式也是一样的，只是网页的 <code>HTML</code> 标签被稍微修改成了 <code>WXML</code> 标签</p><p>因此可以说，小程序页面本质上就是网页</p><p>其中关于微信小程序的实现原理，我们在后面的文章讲到</p><h2 id="三、优缺点"><a href="#三、优缺点" class="headerlink" title="三、优缺点"></a>三、优缺点</h2><p>优点：</p><ul><li>随搜随用，用完即走：使得小程序可以代替许多APP，或是做APP的整体嫁接，或是作为阉割版功能的承载体</li><li>流量大，易接受：小程序借助自身平台更加容易引入更多的流量</li><li>安全</li><li>开发门槛低</li><li>降低兼容性限制</li></ul><p>缺点：</p><ul><li>用户留存：及相关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%</li><li>体积限制：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序</li><li>受控微信：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></li><li><a href="https://www.zhihu.com/question/263816362">https://www.zhihu.com/question/263816362</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wxapp_applet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说var、let、const之间的区别</title>
      <link href="/2021/12/12/es6-var-let-const/"/>
      <url>/2021/12/12/es6-var-let-const/</url>
      
        <content type="html"><![CDATA[<h1 id="说说var、let、const之间的区别"><a href="#说说var、let、const之间的区别" class="headerlink" title="说说var、let、const之间的区别"></a>说说var、let、const之间的区别</h1><p>s</p><h2 id="一、var"><a href="#一、var" class="headerlink" title="一、var"></a>一、var</h2><p>在ES5中，顶层对象的属性和全局变量是等价的，用<code>var</code>声明的变量既是全局变量，也是顶层变量</p><p>注意：顶层对象，在浏览器环境指的是<code>window</code>对象，在 <code>Node</code> 指的是<code>global</code>对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>使用<code>var</code>声明的变量存在变量提升的情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>在编译阶段，编译器会将其变成以下执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">a = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>使用<code>var</code>，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span> </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>在函数中使用使用<code>var</code>声明变量时候，该变量是局部的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">change</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 20 </span></span><br></pre></td></tr></table></figure><p>而如果在函数内不使用<code>var</code>，该变量是全局的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>)&#123;</span><br><span class="line">   a = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">change</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 30 </span></span><br></pre></td></tr></table></figure><h2 id="二、let"><a href="#二、let" class="headerlink" title="二、let"></a>二、let</h2><p><code>let</code>是<code>ES6</code>新增的命令，用来声明变量</p><p>用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// ReferenceError: a is not defined.</span></span><br></pre></td></tr></table></figure><p>不存在变量提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这表示在声明它之前，变量<code>a</code>是不存在的，这时如果用到它，就会抛出一个错误</p><p>只要块级作用域内存在<code>let</code>命令，这个区域就不再受外部影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    a = <span class="string">&#x27;abc&#x27;</span> <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>let</code>声明变量前，该变量都不可用，也就是大家常说的“暂时性死区”</p><p>最后，<code>let</code>不允许在相同作用域中重复声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">30</span></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><p>注意的是相同作用域，下面这种情况是不会报错的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们不能在函数内部重新声明参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>()</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier &#x27;arg&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><h2 id="三、const"><a href="#三、const" class="headerlink" title="三、const"></a>三、const</h2><p><code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><p>如果之前用<code>var</code>或<code>let</code>声明过变量，再用<code>const</code>声明同样会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">30</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span></span><br><span class="line"><span class="comment">// 都会报错</span></span><br></pre></td></tr></table></figure><p><code>const</code>实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动</p><p>对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量</p><p>对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的，并不能确保改变量的结构不变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.<span class="property">prop</span> = <span class="number">123</span>;</span><br><span class="line">foo.<span class="property">prop</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br></pre></td></tr></table></figure><p>其它情况，<code>const</code>与<code>let</code>一致</p><h2 id="四、区别"><a href="#四、区别" class="headerlink" title="四、区别"></a>四、区别</h2><p><code>var</code>、<code>let</code>、<code>const</code>三者区别可以围绕下面五点展开：</p><ul><li>变量提升</li><li>暂时性死区</li><li>块级作用域</li><li>重复声明</li><li>修改声明的变量</li><li>使用</li></ul><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><code>var </code>声明的变量存在变量提升，即变量可以在声明之前调用，值为<code>undefined</code></p><p><code>let</code>和<code>const</code>不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// Cannot access &#x27;b&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c)  <span class="comment">// Cannot access &#x27;c&#x27; before initialization</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p><code>var</code>不存在暂时性死区</p><p><code>let</code>和<code>const</code>存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// Cannot access &#x27;b&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c)  <span class="comment">// Cannot access &#x27;c&#x27; before initialization</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p><code>var</code>不存在块级作用域</p><p><code>let</code>和<code>const</code>存在块级作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c)  <span class="comment">// Uncaught ReferenceError: c is not defined</span></span><br></pre></td></tr></table></figure><h3 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h3><p><code>var</code>允许重复声明变量</p><p><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span> <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span> <span class="comment">// Identifier &#x27;b&#x27; has already been declared</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">20</span> <span class="comment">// Identifier &#x27;c&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><h3 id="修改声明的变量"><a href="#修改声明的变量" class="headerlink" title="修改声明的变量"></a>修改声明的变量</h3><p><code>var</code>和<code>let</code>可以</p><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//let</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br><span class="line">c = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">// Uncaught TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>能用<code>const</code>的情况尽量使用<code>const</code>，其他情况下大多数使用<code>let</code>，避免使用<code>var</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6_var_let_const </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你是怎么理解ES6新增Set、Map两种数据结构的？</title>
      <link href="/2021/12/01/es6-set-map/"/>
      <url>/2021/12/01/es6-set-map/</url>
      
        <content type="html"><![CDATA[<h1 id="你是怎么理解ES6新增Set、Map两种数据结构的？"><a href="#你是怎么理解ES6新增Set、Map两种数据结构的？" class="headerlink" title="你是怎么理解ES6新增Set、Map两种数据结构的？"></a>你是怎么理解ES6新增Set、Map两种数据结构的？</h1><p>如果要用一句来描述，我们可以说</p><p><code>Set</code>是一种叫做集合的数据结构，<code>Map</code>是一种叫做字典的数据结构</p><p>什么是集合？什么又是字典？</p><ul><li><p>集合<br>是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合</p></li><li><p>字典<br>是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同</p></li></ul><p>区别？</p><ul><li>共同点：集合、字典都可以存储不重复的值</li><li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li></ul><h2 id="一、Set"><a href="#一、Set" class="headerlink" title="一、Set"></a>一、Set</h2><p><code> Set</code>是<code>es6</code>新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合</p><p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br></pre></td></tr></table></figure><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p><code>Set</code>的实例关于增删改查的方法：</p><ul><li><p>add()</p></li><li><p>delete()</p></li><li><p>has()</p></li><li><p>clear()</p></li></ul><h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><p>添加某个值，返回 <code>Set</code> 结构本身</p><p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">2</span>); <span class="comment">// 2只被添加了一次</span></span><br></pre></td></tr></table></figure><h3 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h3><p>删除某个值，返回一个布尔值，表示删除是否成功</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">delete</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p>返回一个布尔值，判断该值是否为<code>Set</code>的成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>清除所有成员，没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><code>Set</code>实例遍历的方法有如下：</p><p>关于遍历的方法，有如下：</p><ul><li>keys()：返回键名的遍历器</li><li>values()：返回键值的遍历器</li><li>entries()：返回键值对的遍历器</li><li>forEach()：使用回调函数遍历每个成员</li></ul><p><code>Set</code>的遍历顺序就是插入顺序</p><p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure><p><code>forEach()</code>用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的<code>forEach</code>方法有第二个参数，用于绑定处理函数的<code>this</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value))</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure><p>扩展运算符和<code> Set</code> 结构相结合实现数组或字符串去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]; <span class="comment">// [3, 5, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;352255&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(str)].<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// &quot;352&quot;</span></span><br></pre></td></tr></table></figure><p>实现并集、交集、和差集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><h2 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h2><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p><p><code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br></pre></td></tr></table></figure><h3 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h3><p><code>Map</code> 结构的实例针对增删改查有以下属性和操作方法：</p><ul><li>size 属性</li><li>set()</li><li>get()</li><li>has()</li><li>delete()</li><li>clear()</li></ul><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p><code>size</code>属性返回 Map 结构的成员总数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构</p><p>如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键</p><p>同时返回的是当前<code>Map</code>对象，可采用链式写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>).<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>) <span class="comment">// 链式操作</span></span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);&#125;;</span><br><span class="line">m.<span class="title function_">set</span>(hello, <span class="string">&#x27;Hello ES6!&#x27;</span>) <span class="comment">// 键是函数</span></span><br><span class="line"></span><br><span class="line">m.<span class="title function_">get</span>(hello)  <span class="comment">// Hello ES6!</span></span><br></pre></td></tr></table></figure><h3 id="has-1"><a href="#has-1" class="headerlink" title="has()"></a>has()</h3><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;edition&#x27;</span>)     <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;years&#x27;</span>)       <span class="comment">// false</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="number">262</span>)           <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="delete-1"><a href="#delete-1" class="headerlink" title="delete()"></a>delete()</h3><p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="literal">undefined</span>)</span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)       <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="clear-1"><a href="#clear-1" class="headerlink" title="clear()"></a>clear()</h3><p><code>clear</code>方法清除所有成员，没有返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">clear</span>()</span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><p><code>Map </code>结构原生提供三个遍历器生成函数和一个遍历方法：</p><ul><li>keys()：返回键名的遍历器</li><li>values()：返回键值的遍历器</li><li>entries()：返回所有成员的遍历器</li><li>forEach()：遍历 Map 的所有成员</li></ul><p>遍历顺序就是插入顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;T&#x27;</span>,  <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="三、WeakSet-和-WeakMap"><a href="#三、WeakSet-和-WeakMap" class="headerlink" title="三、WeakSet 和 WeakMap"></a>三、WeakSet 和 WeakMap</h2><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>创建<code>WeakSet</code>实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br></pre></td></tr></table></figure><p><code>WeakSet </code>可以接受一个具有 <code>Iterable </code>接口的对象作为参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure><p>在<code>API</code>中<code>WeakSet</code>与<code>Set</code>有两个区别：</p><ul><li>没有遍历操作的<code>API</code></li><li>没有<code>size</code>属性</li></ul><p><code>WeakSet</code>只能成员只能是引用类型，而不能是其他类型的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws=<span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员不是引用类型</span></span><br><span class="line"><span class="keyword">let</span> weakSet=<span class="keyword">new</span> <span class="title class_">WeakSet</span>([<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakSet) <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员为引用类型</span></span><br><span class="line"><span class="keyword">let</span> obj1=&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2=&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> ws=<span class="keyword">new</span> <span class="title class_">WeakSet</span>([obj1,obj2]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ws) <span class="comment">//WeakSet &#123;&#123;…&#125;, &#123;…&#125;&#125;</span></span><br></pre></td></tr></table></figure><p><code>WeakSet </code>里面的引用只要在外部消失，它在 <code>WeakSet </code>里面的引用就会自动消失</p><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合</p><p>在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p><ul><li>没有遍历操作的<code>API</code></li><li>没有<code>clear</code>清空方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakMap 可以使用 set 方法添加成员</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line">wm1.<span class="title function_">set</span>(key, <span class="number">2</span>);</span><br><span class="line">wm1.<span class="title function_">get</span>(key) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap 也可以接受一个数组，</span></span><br><span class="line"><span class="comment">// 作为构造函数的参数</span></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([[k1, <span class="string">&#x27;foo&#x27;</span>], [k2, <span class="string">&#x27;bar&#x27;</span>]]);</span><br><span class="line">wm2.<span class="title function_">get</span>(k2) <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p><code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="title class_">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure><p><code>WeakMap</code>的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用</p><p>举个场景例子：</p><p>在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构，当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line"></span><br><span class="line">wm.<span class="title function_">set</span>(element, <span class="string">&#x27;some information&#x27;</span>);</span><br><span class="line">wm.<span class="title function_">get</span>(element) <span class="comment">// &quot;some information&quot;</span></span><br></pre></td></tr></table></figure><p>注意：<code>WeakMap</code> 弱引用的只是键名，而不是键值。键值依然是正常引用</p><p>下面代码中，键值<code>obj</code>会在<code>WeakMap</code>产生新的引用，当你修改<code>obj</code>不会影响到内部</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.<span class="title function_">set</span>(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.<span class="title function_">get</span>(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://es6.ruanyifeng.com/#docs/set-map">https://es6.ruanyifeng.com/#docs/set-map</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6_set_map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你是怎么理解ES6中Proxy的？使用场景?</title>
      <link href="/2021/10/12/es6-proxy/"/>
      <url>/2021/10/12/es6-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="你是怎么理解ES6中Proxy的？使用场景"><a href="#你是怎么理解ES6中Proxy的？使用场景" class="headerlink" title="你是怎么理解ES6中Proxy的？使用场景?"></a>你是怎么理解ES6中Proxy的？使用场景?</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>定义：</strong> 用于定义基本操作的自定义行为</p><p><strong>本质：</strong> 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程<code>(meta programming)</code></p><p>元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作</p><p>一段代码来理解</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># metaprogram</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;#!/bin/bash&#x27;</span> &gt;program</span><br><span class="line"><span class="keyword">for</span> ((I=<span class="number">1</span>; I&lt;=<span class="number">1024</span>; I++)) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;echo <span class="variable">$I</span>&quot;</span> &gt;&gt;program</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">chmod</span> +x program</span><br></pre></td></tr></table></figure><p>这段程序每执行一次能帮我们生成一个名为<code>program</code>的文件，文件内容为1024行<code>echo</code>，如果我们手动来写1024行代码，效率显然低效</p><ul><li>元编程优点：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译</li></ul><p><code>Proxy</code> 亦是如此，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）</p><h2 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h2><p><code>Proxy</code>为 构造函数，用来生成 <code>Proxy </code>实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>target</code>表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））</p><p><code>handler</code>通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code> 的行为</p><h3 id="handler解析"><a href="#handler解析" class="headerlink" title="handler解析"></a>handler解析</h3><p>关于<code>handler</code>拦截属性，有如下：</p><ul><li>get(target,propKey,receiver)：拦截对象属性的读取</li><li>set(target,propKey,value,receiver)：拦截对象属性的设置</li><li>has(target,propKey)：拦截<code>propKey in proxy</code>的操作，返回一个布尔值</li><li>deleteProperty(target,propKey)：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值</li><li>ownKeys(target)：拦截<code>Object.keys(proxy)</code>、<code>for...in</code>等循环，返回一个数组</li><li>getOwnPropertyDescriptor(target, propKey)：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象</li><li>defineProperty(target, propKey, propDesc)：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>，返回一个布尔值</li><li>preventExtensions(target)：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值</li><li>getPrototypeOf(target)：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象</li><li>isExtensible(target)：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值</li><li>setPrototypeOf(target, proto)：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值</li><li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作</li><li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作</li></ul><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>若需要在<code>Proxy</code>内部调用对象的默认行为，建议使用<code>Reflect</code>，其是<code>ES6</code>中操作对象而提供的新 <code>API</code></p><p>基本特点：</p><ul><li>只要<code>Proxy</code>对象具有的代理方法，<code>Reflect</code>对象全部具有，以静态方法的形式存在</li><li>修改某些<code>Object</code>方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回<code>false</code>）</li><li>让<code>Object</code>操作都变成函数行为</li></ul><p>下面我们介绍<code>proxy</code>几种用法：</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get</code>接受三个参数，依次为目标对象、属性名和 <code>proxy</code> 实例本身，最后一个参数可选</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target,propKey)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// &quot;张三&quot;</span></span><br></pre></td></tr></table></figure><p><code>get</code>能够对数组增删改查进行拦截，下面是试下你数组读取负数的索引</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createArray</span>(<span class="params">...elements</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="title class_">Number</span>(propKey);</span><br><span class="line">      <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        propKey = <span class="title class_">String</span>(target.<span class="property">length</span> + index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> target = [];</span><br><span class="line">  target.<span class="title function_">push</span>(...elements);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title function_">createArray</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">arr[-<span class="number">1</span>] <span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span></span><br><span class="line"><span class="comment">// TypeError: Invariant check failed</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 <code>Proxy</code> 实例本身</p><p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The age is not an integer&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;The age seems invalid&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于满足条件的 age 属性以及其他属性，直接保存</span></span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> <span class="comment">// 100</span></span><br><span class="line">person.<span class="property">age</span> = <span class="string">&#x27;young&#x27;</span> <span class="comment">// 报错</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">300</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>如果目标对象自身的某个属性，不可写且不可配置，那么<code>set</code>方法将不起作用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    obj[prop] = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p>注意，严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">    <span class="comment">// 无论有没有下面这一行，都会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="comment">// TypeError: &#x27;set&#x27; on proxy: trap returned falsish for property &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(key, <span class="string">&#x27;delete&#x27;</span>);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target,key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invariant</span> (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`无法删除私有属性`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="keyword">delete</span> proxy.<span class="property">_prop</span></span><br><span class="line"><span class="comment">// Error: 无法删除私有属性</span></span><br></pre></td></tr></table></figure><p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错</p><h3 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy.revocable(target, handler);</span><br></pre></td></tr></table></figure><h2 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h2><p><code>Proxy</code>其功能非常类似于设计模式中的代理模式，常用功能如下：</p><ul><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul><p>使用 <code>Proxy</code> 保障数据类型的准确性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numericDataStore = &#123; <span class="attr">count</span>: <span class="number">0</span>, <span class="attr">amount</span>: <span class="number">1234</span>, <span class="attr">total</span>: <span class="number">14</span> &#125;;</span><br><span class="line">numericDataStore = <span class="keyword">new</span> <span class="title class_">Proxy</span>(numericDataStore, &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, proxy</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&quot;属性只能是number类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">numericDataStore.<span class="property">count</span> = <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="comment">// Error: 属性只能是number类型</span></span><br><span class="line"></span><br><span class="line">numericDataStore.<span class="property">count</span> = <span class="number">333</span></span><br><span class="line"><span class="comment">// 赋值成功</span></span><br></pre></td></tr></table></figure><p>声明了一个私有的 <code>apiKey</code>，便于 <code>api</code> 这个对象内部的方法调用，但不希望从外部也能够访问 <code>api._apiKey</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> api = &#123;</span><br><span class="line">    <span class="attr">_apiKey</span>: <span class="string">&#x27;123abc456def&#x27;</span>,</span><br><span class="line">    <span class="attr">getUsers</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; &#125;,</span><br><span class="line">    <span class="attr">getUser</span>: <span class="keyword">function</span>(<span class="params">userId</span>)&#123; &#125;,</span><br><span class="line">    <span class="attr">setUser</span>: <span class="keyword">function</span>(<span class="params">userId, config</span>)&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RESTRICTED</span> = [<span class="string">&#x27;_apiKey&#x27;</span>];</span><br><span class="line">api = <span class="keyword">new</span> <span class="title class_">Proxy</span>(api, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, proxy</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable constant_">RESTRICTED</span>.<span class="title function_">indexOf</span>(key) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> 不可访问.`</span>);</span><br><span class="line">        &#125; <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, proxy);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, proxy</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable constant_">RESTRICTED</span>.<span class="title function_">indexOf</span>(key) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> 不可修改`</span>);</span><br><span class="line">        &#125; <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, value, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(api.<span class="property">_apiKey</span>)</span><br><span class="line">api.<span class="property">_apiKey</span> = <span class="string">&#x27;987654321&#x27;</span></span><br><span class="line"><span class="comment">// 上述都抛出错误</span></span><br></pre></td></tr></table></figure><p>还能通过使用<code>Proxy</code>实现观察者模式</p><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行</p><p><code>observable</code>函数返回一个原始对象的 <code>Proxy</code> 代理，拦截赋值操作，触发充当观察者的各个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observe</span> = fn =&gt; queuedObservers.<span class="title function_">add</span>(fn);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observable</span> = obj =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;set&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">  queuedObservers.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> <span class="title function_">observer</span>());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者函数都放进<code>Set</code>集合，当修改<code>obj</code>的值，在会<code>set</code>函数中拦截，自动执行<code>Set</code>所有的观察者</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://es6.ruanyifeng.com/#docs/proxy">https://es6.ruanyifeng.com/#docs/proxy</a></li><li><a href="https://vue3js.cn/es6">https://vue3js.cn/es6</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6_proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你是怎么理解ES6中 Promise的？使用场景？</title>
      <link href="/2021/08/09/es6-promise/"/>
      <url>/2021/08/09/es6-promise/</url>
      
        <content type="html"><![CDATA[<h1 id="你是怎么理解ES6中-Promise的？使用场景？"><a href="#你是怎么理解ES6中-Promise的？使用场景？" class="headerlink" title="你是怎么理解ES6中 Promise的？使用场景？"></a>你是怎么理解ES6中 Promise的？使用场景？</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><code>Promise </code>，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</p><p>在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="title function_">doSomethingElse</span>(result, <span class="keyword">function</span>(<span class="params">newResult</span>) &#123;</span><br><span class="line">    <span class="title function_">doThirdThing</span>(newResult, <span class="keyword">function</span>(<span class="params">finalResult</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;得到最终结果: &#x27;</span> + finalResult);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br></pre></td></tr></table></figure><p>阅读上面代码，是不是很难受，上述形成了经典的回调地狱</p><p>现在通过<code>Promise</code>的改写上面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doSomethingElse</span>(result);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">newResult</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doThirdThing</span>(newResult);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">finalResult</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;得到最终结果: &#x27;</span> + finalResult);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(failureCallback);</span><br></pre></td></tr></table></figure><p>瞬间感受到<code>promise</code>解决异步操作的优点：</p><ul><li>链式操作减低了编码难度</li><li>代码可读性明显增强</li></ul><p>下面我们正式来认识<code>promise</code>：</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><code>promise</code>对象仅有三种状态</p><ul><li><code>pending</code>（进行中）</li><li><code>fulfilled</code>（已成功）</li><li><code>rejected</code>（已失败）</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li><li>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>认真阅读下图，我们能够轻松了解<code>promise</code>整个流程</p><p> <img src="https://static.vue-js.com/1b02ae90-58a9-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h2><p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code></p><ul><li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”</li><li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”</li></ul><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>Promise</code>构建出来的实例存在以下方法：</p><ul><li>then()</li><li>catch()</li><li>finally()</li></ul><h4 id="then"><a href="#then" class="headerlink" title="then()"></a>then()</h4><p><code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</p><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例，也就是<code>promise</code>能链式书写的原因</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> json.<span class="property">post</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p><code>catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/posts.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise </code>对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/post/1.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">comments</span>) &#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一般来说，使用<code>catch</code>方法代替<code>then()</code>第二个参数</p><p><code>Promise </code>对象抛出的错误不会传递到外层代码，即不会有任何反应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程</p><p><code>catch()</code>方法之中，还能再抛出错误，通过后面<code>catch</code>方法捕获到</p><h4 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h4><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><h3 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h3><p><code>Promise</code>构造函数存在以下方法：</p><ul><li>all()</li><li>race()</li><li>allSettled()</li><li>resolve()</li><li>reject()</li><li>try()</li></ul><h3 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h3><p><code>Promise.all()</code>方法用于将多个 <code>Promise </code>实例，包装成一个新的 <code>Promise </code>实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>接受一个数组（迭代对象）作为参数，数组成员都应为<code>Promise</code>实例</p><p>实例<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分为两种：</p><ul><li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li><li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</li></ul><p>注意，如果作为参数的 <code>Promise</code> 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// Error: 报错了</span></span><br></pre></td></tr></table></figure><h3 id="race"><a href="#race" class="headerlink" title="race()"></a>race()</h3><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变</p><p>率先改变的 Promise 实例的返回值则传递给<code>p</code>的回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/resource-that-may-take-a-while&#x27;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;request timeout&#x27;</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure><h3 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled()"></a>allSettled()</h3><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p><p>只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-1&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-2&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-3&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"><span class="title function_">removeLoadingIndicator</span>();</span><br></pre></td></tr></table></figure><h4 id="resolve"><a href="#resolve" class="headerlink" title="resolve()"></a>resolve()</h4><p>将现有对象转为 <code>Promise </code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure><p>参数可以分成四种情况，分别如下：</p><ul><li>参数是一个 Promise 实例，<code>promise.resolve</code>将不做任何修改、原封不动地返回这个实例</li><li>参数是一个<code>thenable</code>对象，<code>promise.resolve</code>会将这个对象转为 <code>Promise </code>对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法</li><li>参数不是具有<code>then()</code>方法的对象，或根本就不是对象，<code>Promise.resolve()</code>会返回一个新的 Promise 对象，状态为<code>resolved</code></li><li>没有参数时，直接返回一个<code>resolved</code>状态的 Promise 对象</li></ul><h4 id="reject"><a href="#reject" class="headerlink" title="reject()"></a>reject()</h4><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p><code>Promise.reject()</code>方法的参数，会原封不动地变成后续方法的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e === <span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h2><p>将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="keyword">function</span> (<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">    image.<span class="property">onload</span>  = resolve;</span><br><span class="line">    image.<span class="property">onerror</span> = reject;</span><br><span class="line">    image.<span class="property">src</span> = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过链式操作，将多个渲染数据分别给个<code>then</code>，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 各司其职</span></span><br><span class="line"><span class="title function_">getInfo</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; bannerList &#125; = res</span><br><span class="line">    <span class="comment">//渲染轮播图</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bannerList)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> &#123; storeList &#125; = res</span><br><span class="line">    <span class="comment">//渲染店铺列表</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(storeList)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; categoryList &#125; = res</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(categoryList)</span><br><span class="line">    <span class="comment">//渲染分类列表</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过<code>all()</code>实现多个请求合并在一起，汇总所有请求结果，只需设置一个<code>loading</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initLoad</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// loading.show() //加载loading</span></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getBannerList</span>(),<span class="title function_">getStoreList</span>(),<span class="title function_">getCategoryList</span>()]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        loading.<span class="title function_">hide</span>() <span class="comment">//关闭loading</span></span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        loading.<span class="title function_">hide</span>()<span class="comment">//关闭loading</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据初始化    </span></span><br><span class="line"><span class="title function_">initLoad</span>()</span><br></pre></td></tr></table></figure><p>通过<code>race</code>可以设置图片请求超时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求某个图片资源</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">requestImg</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">        img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="title function_">resolve</span>(img);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg&quot;; 正确的</span></span><br><span class="line">        img.<span class="property">src</span> = <span class="string">&quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时函数，用于给请求计时</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;图片请求超时&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">5000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span></span><br><span class="line">.<span class="title function_">race</span>([<span class="title function_">requestImg</span>(), <span class="title function_">timeout</span>()])</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">results</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://es6.ruanyifeng.com/#docs/promise">https://es6.ruanyifeng.com/#docs/promise</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6_promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象新增了哪些扩展？</title>
      <link href="/2021/07/21/es6-object/"/>
      <url>/2021/07/21/es6-object/</url>
      
        <content type="html"><![CDATA[<h1 id="对象新增了哪些扩展？"><a href="#对象新增了哪些扩展？" class="headerlink" title="对象新增了哪些扩展？"></a>对象新增了哪些扩展？</h1><h2 id="一、属性的简写"><a href="#一、属性的简写" class="headerlink" title="一、属性的简写"></a>一、属性的简写</h2><p>ES6中，当对象键名与对应值名相等的时候，可以进行简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>:foo&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;</span><br></pre></td></tr></table></figure><p>方法也能够进行简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数内作为返回值，也会变得方便很多</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPoint</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getPoint</span>()</span><br><span class="line"><span class="comment">// &#123;x:1, y:10&#125;</span></span><br></pre></td></tr></table></figure><p>注意：简写的对象方法不能用作构造函数，否则会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">f</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h2 id="二、属性名表达式"><a href="#二、属性名表达式" class="headerlink" title="二、属性名表达式"></a>二、属性名表达式</h2><p>ES6 允许字面量定义对象时，将表达式放在括号内</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastWord = <span class="string">&#x27;last word&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="string">&#x27;first word&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  [lastWord]: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;first word&#x27;</span>] <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">a[lastWord] <span class="comment">// &quot;world&quot;</span></span><br><span class="line">a[<span class="string">&#x27;last word&#x27;</span>] <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>表达式还可以用于定义方法名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">&#x27;h&#x27;</span> + <span class="string">&#x27;ello&#x27;</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">hello</span>() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo]: <span class="string">&#x27;abc&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keyA = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> keyB = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  [keyA]: <span class="string">&#x27;valueA&#x27;</span>,</span><br><span class="line">  [keyB]: <span class="string">&#x27;valueB&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject <span class="comment">// Object &#123;[object Object]: &quot;valueB&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="三、super关键字"><a href="#三、super关键字" class="headerlink" title="三、super关键字"></a>三、super关键字</h2><p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">  <span class="title function_">find</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">foo</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto); <span class="comment">// 为obj设置原型对象</span></span><br><span class="line">obj.<span class="title function_">find</span>() <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h2 id="四、扩展运算符的应用"><a href="#四、扩展运算符的应用" class="headerlink" title="四、扩展运算符的应用"></a>四、扩展运算符的应用</h2><p>在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>注意：解构赋值必须是最后一个参数，否则会报错</p><p>解构赋值是浅拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">obj.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>; <span class="comment">// 修改obj里面a属性中键值</span></span><br><span class="line">x.<span class="property">a</span>.<span class="property">b</span> <span class="comment">// 2，影响到了结构出来x的值</span></span><br></pre></td></tr></table></figure><p>对象的扩展运算符等同于使用<code>Object.assign()</code>方法</p><h2 id="五、属性的遍历"><a href="#五、属性的遍历" class="headerlink" title="五、属性的遍历"></a>五、属性的遍历</h2><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><ul><li><p>for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</p></li><li><p>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</p></li><li><p>Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名</p></li><li><p>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名</p></li><li><p>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</p></li></ul><p>上述遍历，都遵守同样的属性遍历的次序规则：</p><ul><li>首先遍历所有数值键，按照数值升序排列</li><li>其次遍历所有字符串键，按照加入时间升序排列</li><li>最后遍历所有 Symbol 键，按照加入时间升序排</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(&#123; [<span class="title class_">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// [&#x27;2&#x27;, &#x27;10&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, Symbol()]</span></span><br></pre></td></tr></table></figure><h2 id="六、对象新增的方法"><a href="#六、对象新增的方法" class="headerlink" title="六、对象新增的方法"></a>六、对象新增的方法</h2><p>关于对象新增的方法，分别有以下：</p><ul><li>Object.is()</li><li>Object.assign()</li><li>Object.getOwnPropertyDescriptors()</li><li>Object.setPrototypeOf()，Object.getPrototypeOf()</li><li>Object.keys()，Object.values()，Object.entries()</li><li>Object.fromEntries()</li></ul><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>严格判断两个值是否相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致，不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p><code>Object.assign()</code>方法用于对象的合并，将源对象<code>source</code>的所有可枚举属性，复制到目标对象<code>target</code></p><p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>注意：<code>Object.assign()</code>方法是浅拷贝，遇到同名属性会进行替换</p><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>返回指定对象所有自身属性（非继承属性）的描述对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法用来设置一个对象的原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>用于读取一个对象的原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br></pre></td></tr></table></figure><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj)</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 42]</span></span><br></pre></td></tr></table></figure><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p>返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)</span><br><span class="line"><span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br></pre></td></tr></table></figure><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p>用于将一个键值对数组转为对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://es6.ruanyifeng.com/#docs/object">https://es6.ruanyifeng.com/#docs/object</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6_object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你是怎么理解ES6中Module的？使用场景？</title>
      <link href="/2021/06/07/es6-module/"/>
      <url>/2021/06/07/es6-module/</url>
      
        <content type="html"><![CDATA[<h1 id="你是怎么理解ES6中Module的？使用场景？"><a href="#你是怎么理解ES6中Module的？使用场景？" class="headerlink" title="你是怎么理解ES6中Module的？使用场景？"></a>你是怎么理解ES6中Module的？使用场景？</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>模块，（Module），是能够单独命名并独立地完成一定功能的程序语句的<strong>集合（即程序代码和数据结构的集合体）</strong>。</p><p>两个基本的特征：外部特征和内部特征</p><ul><li><p>外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能</p></li><li><p>内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）</p></li></ul><h3 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h3><ul><li>代码抽象</li><li>代码封装</li><li>代码复用</li><li>依赖管理</li></ul><p>如果没有模块化，我们代码会怎样？</p><ul><li>变量和方法不容易维护，容易污染全局作用域</li><li>加载资源的方式通过script标签从上到下。</li><li>依赖的环境主观逻辑偏重，代码较多就会比较复杂。</li><li>大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃</li></ul><p>因此，需要一种将<code>JavaScript</code>程序模块化的机制，如</p><ul><li>CommonJs (典型代表：node.js早期)</li><li>AMD (典型代表：require.js)</li><li>CMD (典型代表：sea.js)</li></ul><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p><code>Asynchronous ModuleDefinition</code>（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行</p><p>代表库为<code>require.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.<span class="title function_">config</span>(&#123;</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&quot;js/lib&quot;</span>,</span><br><span class="line">  <span class="attr">paths</span>: &#123;</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery.min&quot;</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">&quot;underscore&quot;</span>: <span class="string">&quot;underscore.min&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;jquery&quot;</span>,<span class="string">&quot;underscore&quot;</span>],<span class="keyword">function</span>(<span class="params">$,_</span>)&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h3><p><code>CommonJS</code> 是一套 <code>Javascript</code> 模块规范，用于服务端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123; foo , bar&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; foo,bar &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其有如下特点：</p><ul><li>所有代码都运行在模块作用域，不会污染全局作用域</li><li>模块是同步加载的，即只有加载完成，才能执行后面的操作</li><li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li><li><code>require</code>返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值</li></ul><p>既然存在了<code>AMD</code>以及<code>CommonJs</code>机制，<code>ES6</code>的<code>Module</code>又有什么不一样？</p><p>ES6 在语言标准的层面上，实现了<code>Module</code>，即模块功能，完全可以取代 <code>CommonJS </code>和 <code>AMD </code>规范，成为浏览器和服务器通用的模块解决方案</p><p><code>CommonJS</code> 和<code> AMD</code> 模块，都只能在运行时确定这些东西。比如，<code>CommonJS </code>模块就是对象，输入时必须查找对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readfile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.<span class="property">stat</span>;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.<span class="property">exists</span>;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.<span class="property">readfile</span>;</span><br></pre></td></tr></table></figure><p><code>ES6</code>设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上述代码，只加载3个方法，其他方法不加载，即 <code>ES6</code> 可以在编译时就完成模块加载</p><p>由于编译加载，使得静态分析成为可能。包括现在流行的<code>typeScript</code>也是依靠静态分析实现功能</p><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p><code>ES6</code>模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是<code>ES5</code>之前就已经规定好</p><p>模块功能主要由两个命令构成：</p><ul><li><code>export</code>：用于规定模块的对外接口</li><li><code>import</code>：用于输入其他模块提供的功能</li></ul><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line">或 </span><br><span class="line"><span class="comment">// 建议使用下面写法，这样能瞬间确定输出了哪些变量</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, lastName, year &#125;;</span><br></pre></td></tr></table></figure><p>输出函数或类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过<code>as</code>可以进行输出变量的重命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">v1</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">v2</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; firstName, lastName, year &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  element.<span class="property">textContent</span> = firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样如果想要输入变量起别名，通过<code>as</code>关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>当加载整个模块的时候，需要用到星号<code>*</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">area</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">circumference</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">&#x27;./circle&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle)   <span class="comment">// &#123;area:area,circumference:circumference&#125;</span></span><br></pre></td></tr></table></figure><p>输入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 合法操作</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// Syntax Error : &#x27;a&#x27; is read-only;</span></span><br></pre></td></tr></table></figure><p>不过建议即使能修改，但我们不建议。因为修改之后，我们很难差错</p><p><code>import</code>后面我们常接着<code>from</code>关键字，<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果只有一个模块名，需要有配置文件，告诉引擎模块的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; myMethod &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在编译阶段，<code>import</code>会提升到整个模块的头部，首先执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure><p>多次重复执行同样的导入，只会执行一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载</p><p>如果不需要知道变量名或函数就完成加载，就要用到<code>export default</code>命令，为模块指定默认输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载该模块的时候，<code>import</code>命令可以为该函数指定任意名字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span>;</span><br><span class="line"><span class="title function_">customName</span>(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势</p><p>这个新功能允许您将<code>import()</code>作为函数调用，将其作为参数传递给模块的路径。 它返回一个 <code>promise</code>，它用一个模块对象来实现，让你可以访问该对象的导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;/modules/myModule.mjs&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params"><span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Do something with the module.</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="复合写法"><a href="#复合写法" class="headerlink" title="复合写法"></a>复合写法</h3><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure><p>同理能够搭配<code>as</code>、<code>*</code>搭配使用</p><h2 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h2><p>如今，<code>ES6</code>模块化已经深入我们日常项目开发中，像<code>vue</code>、<code>react</code>项目搭建项目，组件化开发处处可见，其也是依赖模块化实现</p><p><code>vue</code>组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      组件化开发 ---- 模块化</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">msg</span>: <span class="title class_">String</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>react</code>组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">组件化开发 ---- 模块化</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>包括完成一些复杂应用的时候，我们也可以拆分成各个模块</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://macsalvation.net/the-history-of-js-module/">https://macsalvation.net/the-history-of-js-module/</a></li><li><a href="https://es6.ruanyifeng.com/#docs/module">https://es6.ruanyifeng.com/#docs/module</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6_module </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你是怎么理解ES6中 Generator的？使用场景？</title>
      <link href="/2021/05/19/es6-generator/"/>
      <url>/2021/05/19/es6-generator/</url>
      
        <content type="html"><![CDATA[<h1 id="你是怎么理解ES6中-Generator的？使用场景？"><a href="#你是怎么理解ES6中-Generator的？使用场景？" class="headerlink" title="你是怎么理解ES6中 Generator的？使用场景？"></a>你是怎么理解ES6中 Generator的？使用场景？</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p><p>回顾下上文提到的解决异步的手段：</p><ul><li>回调函数</li><li>promise</li></ul><p>那么，上文我们提到<code>promsie</code>已经是一种比较流行的解决异步方案，那么为什么还出现<code>Generator</code>？甚至<code>async/await</code>呢？</p><p>该问题我们留在后面再进行分析，下面先认识下<code>Generator</code></p><h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><p>执行 <code>Generator</code> 函数会返回一个遍历器对象，可以依次遍历 <code>Generator</code> 函数内部的每一个状态</p><p>形式上，<code>Generator </code>函数是一个普通函数，但是有两个特征：</p><ul><li><code>function</code>关键字与函数名之间有一个星号</li><li>函数体内部使用<code>yield</code>表达式，定义不同的内部状态</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorldGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p><code>Generator</code> 函数会返回一个遍历器对象，即具有<code>Symbol.iterator</code>属性，并且返回给自己</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() === g</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>通过<code>yield</code>关键字可以暂停<code>generator</code>函数返回的遍历器对象的状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorldGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = <span class="title function_">helloWorldGenerator</span>();</span><br></pre></td></tr></table></figure><p>上述存在三个状态：<code>hello</code>、<code>world</code>、<code>return</code></p><p>通过<code>next</code>方法才会遍历到下一个内部状态，其运行逻辑如下：</p><ul><li>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</li><li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式</li><li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li><li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><code>done</code>用来判断是否存在下个状态，<code>value</code>对应状态值</p><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code></p><p>通过调用<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">b.<span class="title function_">next</span>() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure><p>正因为<code>Generator </code>函数返回<code>Iterator</code>对象，因此我们还可以通过<code>for...of</code>进行遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><p>原生对象没有遍历接口，通过<code>Generator </code>函数为它加上这个接口，就能使用<code>for...of</code>进行遍历了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">objectEntries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, obj[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Doe&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">objectEntries</span>(jane)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><h2 id="三、异步解决方案"><a href="#三、异步解决方案" class="headerlink" title="三、异步解决方案"></a>三、异步解决方案</h2><p>回顾之前展开异步解决的方案：</p><ul><li>回调函数</li><li>Promise 对象</li><li>generator 函数</li><li>async&#x2F;await</li></ul><p>这里通过文件读取案例，将几种解决异步的方案进行一个比较：</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，再调用这个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>readFile</code>函数的第三个参数，就是回调函数，等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><code>Promise</code>就是为了解决回调地狱而产生的，将回调函数的嵌套，改成链式调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">error, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种链式操作形式，使异步任务的两段执行更清楚了，但是也存在了很明显的问题，代码变得冗杂了，语义化并不强</p><h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><p><code>yield</code>表达式可以暂停函数执行，<code>next</code>方法用于恢复函数执行，这使得<code>Generator</code>函数非常适合将异步任务同步化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><p>将上面<code>Generator</code>函数改成<code>async/await</code>形式，更为简洁，语义化更强了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>通过上述代码进行分析，将<code>promise</code>、<code>Generator</code>、<code>async/await</code>进行比较：</p><ul><li><p><code>promise</code>和<code>async/await</code>是专门用于处理异步操作的</p></li><li><p><code>Generator</code>并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署<code>Interator</code>接口…）</p></li><li><p><code>promise</code>编写代码相比<code>Generator</code>、<code>async</code>更为复杂化，且可读性也稍差</p></li><li><p><code>Generator</code>、<code>async</code>需要与<code>promise</code>对象搭配处理异步情况</p></li><li><p><code>async</code>实质是<code>Generator</code>的语法糖，相当于会自动执行<code>Generator</code>函数</p></li><li><p><code>async</code>使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案</p></li></ul><h2 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h2><p><code>Generator</code>是异步解决的一种方案，最大特点则是将异步操作同步化表达出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">loadUI</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">showLoadingScreen</span>();</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">loadUIDataAsynchronously</span>();</span><br><span class="line">  <span class="title function_">hideLoadingScreen</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loader = <span class="title function_">loadUI</span>();</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.<span class="title function_">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure><p>包括<code>redux-saga </code>中间件也充分利用了<code>Generator</code>特性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; call, put, takeEvery, takeLatest &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Api</span> <span class="keyword">from</span> <span class="string">&#x27;...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">fetchUser</span>(<span class="params">action</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> user = <span class="keyword">yield</span> <span class="title function_">call</span>(<span class="title class_">Api</span>.<span class="property">fetchUser</span>, action.<span class="property">payload</span>.<span class="property">userId</span>);</span><br><span class="line">      <span class="keyword">yield</span> <span class="title function_">put</span>(&#123;<span class="attr">type</span>: <span class="string">&quot;USER_FETCH_SUCCEEDED&quot;</span>, <span class="attr">user</span>: user&#125;);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="title function_">put</span>(&#123;<span class="attr">type</span>: <span class="string">&quot;USER_FETCH_FAILED&quot;</span>, <span class="attr">message</span>: e.<span class="property">message</span>&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">mySaga</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">takeEvery</span>(<span class="string">&quot;USER_FETCH_REQUESTED&quot;</span>, fetchUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">mySaga</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">takeLatest</span>(<span class="string">&quot;USER_FETCH_REQUESTED&quot;</span>, fetchUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mySaga;</span><br></pre></td></tr></table></figure><p>还能利用<code>Generator</code>函数，在对象上实现<code>Iterator</code>接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">iterEntries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i];</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">bar</span>: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">iterEntries</span>(myObj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 3</span></span><br><span class="line"><span class="comment">// bar 7</span></span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://es6.ruanyifeng.com/#docs/generator-async">https://es6.ruanyifeng.com/#docs/generator-async</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6_generator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象新增了哪些扩展？</title>
      <link href="/2021/03/08/es6-function/"/>
      <url>/2021/03/08/es6-function/</url>
      
        <content type="html"><![CDATA[<h1 id="对象新增了哪些扩展？"><a href="#对象新增了哪些扩展？" class="headerlink" title="对象新增了哪些扩展？"></a>对象新增了哪些扩展？</h1><h2 id="一、参数"><a href="#一、参数" class="headerlink" title="一、参数"></a>一、参数</h2><p><code>ES6</code>允许为函数的参数设置默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>函数的形参是默认声明的，不能使用<code>let</code>或<code>const</code>再次声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = <span class="number">5</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数默认值可以与解构赋值的默认值结合起来使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line"><span class="title function_">foo</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line"><span class="title function_">foo</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>上面的<code>foo</code>函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量<code>x</code>和<code>y</code>就不会生成，从而报错，这里设置默认值避免</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure><p>参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// [1, undefined]</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line"><span class="title function_">f</span>(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br></pre></td></tr></table></figure><h2 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h2><h3 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h3><p><code>length</code>将返回没有指定默认值的参数个数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">a</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 1</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><code>rest</code> 参数也不会计入<code>length</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">...args</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>返回该函数的函数名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.<span class="property">name</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.<span class="property">name</span> <span class="comment">// &quot;f&quot;</span></span><br></pre></td></tr></table></figure><p>如果将一个具名函数赋值给一个变量，则 <code>name</code>属性都返回这个具名函数原本的名字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">bar.<span class="property">name</span> <span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure><p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="title class_">Function</span>).<span class="property">name</span> <span class="comment">// &quot;anonymous&quot;</span></span><br></pre></td></tr></table></figure><p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">foo.<span class="title function_">bind</span>(&#123;&#125;).<span class="property">name</span> <span class="comment">// &quot;bound foo&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;).<span class="title function_">bind</span>(&#123;&#125;).<span class="property">name</span> <span class="comment">// &quot;bound &quot;</span></span><br></pre></td></tr></table></figure><h2 id="三、作用域"><a href="#三、作用域" class="headerlink" title="三、作用域"></a>三、作用域</h2><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域</p><p>等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的</p><p>下面例子中，<code>y=x</code>会形成一个单独作用域，<code>x</code>没有被定义，所以指向全局变量<code>x</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">y = x</span>) &#123; </span><br><span class="line">  <span class="comment">// 等同于 let y = x  </span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="四、严格模式"><a href="#四、严格模式" class="headerlink" title="四、严格模式"></a>四、严格模式</h2><p>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a, b = a</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="keyword">function</span> (<span class="params">&#123;a, b&#125;</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">doSomething</span> = (<span class="params">...a</span>) =&gt; &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="title function_">doSomething</span>(<span class="params">&#123;a, b&#125;</span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h2><p>使用“箭头”（<code>=&gt;</code>）定义函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">f</span> = v =&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure><p>如果返回对象，需要加括号将对象包裹</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">getTempItem</span> = id =&gt; (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li><li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li><li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</li><li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://es6.ruanyifeng.com/#docs/function">https://es6.ruanyifeng.com/#docs/function</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6_function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你是怎么理解ES6中 Decorator 的？使用场景？</title>
      <link href="/2021/02/02/es6-decorator/"/>
      <url>/2021/02/02/es6-decorator/</url>
      
        <content type="html"><![CDATA[<h1 id="你是怎么理解ES6中-Decorator-的？使用场景？"><a href="#你是怎么理解ES6中-Decorator-的？使用场景？" class="headerlink" title="你是怎么理解ES6中 Decorator 的？使用场景？"></a>你是怎么理解ES6中 Decorator 的？使用场景？</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Decorator，即装饰器，从名字上很容易让我们联想到装饰者模式</p><p>简单来讲，装饰者模式就是一种在不改变原类和使用继承的情况下，动态地扩展对象功能的设计理论。</p><p><code>ES6</code>中<code>Decorator</code>功能亦如此，其本质也不是什么高大上的结构，就是一个普通的函数，用于扩展类属性和类方法</p><p>这里定义一个士兵，这时候他什么装备都没有</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">soldier</span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个得到 AK 装备的函数，即装饰器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strong</span>(<span class="params">target</span>)&#123;</span><br><span class="line">    target.<span class="property">AK</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该装饰器对士兵进行增强</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@strong</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">soldier</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候士兵就有武器了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soldier.<span class="property">AK</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上述代码虽然简单，但也能够清晰看到了使用<code>Decorator</code>两大优点：</p><ul><li>代码可读性变强了，装饰器命名相当于一个注释</li><li>在不改变原有代码情况下，对原来功能进行扩展</li></ul><h2 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h2><p><code>Docorator</code>修饰对象为下面两种：</p><ul><li>类的装饰</li><li>类属性的装饰</li></ul><h3 id="类的装饰"><a href="#类的装饰" class="headerlink" title="类的装饰"></a>类的装饰</h3><p>当对类本身进行装饰的时候，能够接受一个参数，即类本身</p><p>将装饰器行为进行分解，大家能够有个更深入的了解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line">A = <span class="title function_">decorator</span>(A) || A;</span><br></pre></td></tr></table></figure><p>下面<code>@testable</code>就是一个装饰器，<code>target</code>就是传入的类，即<code>MyTestableClass</code>，实现了为类添加静态属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTestableClass</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testable</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  target.<span class="property">isTestable</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyTestableClass</span>.<span class="property">isTestable</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果想要传递参数，可以在装饰器外层再封装一层函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testable</span>(<span class="params">isTestable</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    target.<span class="property">isTestable</span> = isTestable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="title function_">testable</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTestableClass</span> &#123;&#125;</span><br><span class="line"><span class="title class_">MyTestableClass</span>.<span class="property">isTestable</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">@<span class="title function_">testable</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">isTestable</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="类属性的装饰"><a href="#类属性的装饰" class="headerlink" title="类属性的装饰"></a>类属性的装饰</h3><p>当对类属性进行装饰的时候，能够接受三个参数：</p><ul><li>类的原型对象</li><li>需要装饰的属性名</li><li>装饰属性名的描述对象</li></ul><p>首先定义一个<code>readonly</code>装饰器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readonly</span>(<span class="params">target, name, descriptor</span>)&#123;</span><br><span class="line">  descriptor.<span class="property">writable</span> = <span class="literal">false</span>; <span class="comment">// 将可写属性设为false</span></span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>readonly</code>装饰类的<code>name</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  @readonly</span><br><span class="line">  <span class="title function_">name</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.last&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于以下调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">readonly</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;name&#x27;</span>, descriptor);</span><br></pre></td></tr></table></figure><p>如果一个方法有多个装饰器，就像洋葱一样，先从外到内进入，再由内到外执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dec</span>(<span class="params">id</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;evaluated&#x27;</span>, id);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">target, property, descriptor</span>) =&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;executed&#x27;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    @<span class="title function_">dec</span>(<span class="number">1</span>)</span><br><span class="line">    @<span class="title function_">dec</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="title function_">method</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// evaluated 1</span></span><br><span class="line"><span class="comment">// evaluated 2</span></span><br><span class="line"><span class="comment">// executed 2</span></span><br><span class="line"><span class="comment">// executed 1</span></span><br></pre></td></tr></table></figure><p>外层装饰器<code>@dec(1)</code>先进入，但是内层装饰器<code>@dec(2)</code>先执行</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>装饰器不能用于修饰函数，因为函数存在变量声明情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译阶段，变成下面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter;</span><br><span class="line"><span class="keyword">var</span> add;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">add = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>意图是执行后<code>counter</code>等于 1，但是实际上结果是<code>counter</code>等于 0</p><h2 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h2><p>基于<code>Decorator</code>强大的作用，我们能够完成各种场景的需求，下面简单列举几种：</p><p>使用<code>react-redux</code>的时候，如果写成下面这种形式，既不雅观也很麻烦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyReactComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="title class_">MyReactComponent</span>);</span><br></pre></td></tr></table></figure><p>通过装饰器就变得简洁多了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyReactComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>将<code>mixins</code>，也可以写成装饰器，让使用更为简洁了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mixins</span>(<span class="params">...list</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(target.<span class="property"><span class="keyword">prototype</span></span>, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@<span class="title function_">mixins</span>(<span class="title class_">Foo</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><p>下面再讲讲<code>core-decorators.js</code>几个常见的装饰器</p><h4 id="antobind"><a href="#antobind" class="headerlink" title="@antobind"></a>@antobind</h4><p><code>autobind</code>装饰器使得方法中的<code>this</code>对象，绑定原始对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; autobind &#125; <span class="keyword">from</span> <span class="string">&#x27;core-decorators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  @autobind</span><br><span class="line">  <span class="title function_">getPerson</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> getPerson = person.<span class="property">getPerson</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getPerson</span>() === person;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="readonly"><a href="#readonly" class="headerlink" title="@readonly"></a>@readonly</h4><p><code>readonly</code>装饰器使得属性或方法不可写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readonly &#125; <span class="keyword">from</span> <span class="string">&#x27;core-decorators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meal</span> &#123;</span><br><span class="line">  @readonly</span><br><span class="line">  entree = <span class="string">&#x27;steak&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dinner = <span class="keyword">new</span> <span class="title class_">Meal</span>();</span><br><span class="line">dinner.<span class="property">entree</span> = <span class="string">&#x27;salmon&#x27;</span>;</span><br><span class="line"><span class="comment">// Cannot assign to read only property &#x27;entree&#x27; of [object Object]</span></span><br></pre></td></tr></table></figure><h4 id="deprecate"><a href="#deprecate" class="headerlink" title="@deprecate"></a>@deprecate</h4><p><code>deprecate</code>或<code>deprecated</code>装饰器在控制台显示一条警告，表示该方法将废除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; deprecate &#125; <span class="keyword">from</span> <span class="string">&#x27;core-decorators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  @deprecate</span><br><span class="line">  <span class="title function_">facepalm</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title function_">deprecate</span>(<span class="string">&#x27;功能废除了&#x27;</span>)</span><br><span class="line">  <span class="title function_">facepalmHard</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">facepalm</span>();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalm: This function will be removed in future versions.</span></span><br><span class="line"></span><br><span class="line">person.<span class="title function_">facepalmHard</span>();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalmHard: 功能废除了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://es6.ruanyifeng.com/#docs/decorator">https://es6.ruanyifeng.com/#docs/decorator</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6_decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6中数组新增了哪些扩展？</title>
      <link href="/2021/01/01/es6-array/"/>
      <url>/2021/01/01/es6-array/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6中数组新增了哪些扩展？"><a href="#ES6中数组新增了哪些扩展？" class="headerlink" title="ES6中数组新增了哪些扩展？"></a>ES6中数组新增了哪些扩展？</h1><h2 id="一、扩展运算符的应用"><a href="#一、扩展运算符的应用" class="headerlink" title="一、扩展运算符的应用"></a>一、扩展运算符的应用</h2><p>ES6通过扩展元素符<code>...</code>，好比 <code>rest</code> 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure><p>主要用于函数调用的时候，将一个数组变为参数序列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">array, ...items</span>) &#123;</span><br><span class="line">  array.<span class="title function_">push</span>(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line"><span class="title function_">add</span>(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>可以将某些数据结构转为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)]</span><br></pre></td></tr></table></figure><p>能够更简单实现数组复制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br><span class="line"><span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure><p>数组的合并也更为简洁了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure><p>注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组</p><p>下面看个例子就清楚多了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,[<span class="number">1</span>,<span class="number">2</span>]];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3  = [...arr1,...arr2]</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">9999</span> <span class="comment">// 修改arr1里面数组成员值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">3</span>]) <span class="comment">// 影响到arr3,[&#x27;a&#x27;,&#x27;b&#x27;,[9999,2],&#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>扩展运算符可以与解构赋值结合起来，用于生成数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">&quot;foo&quot;</span>];</span><br><span class="line">first  <span class="comment">// &quot;foo&quot;</span></span><br><span class="line">rest   <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>可以将字符串转为真正的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure><p>定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.<span class="title function_">keys</span>()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [...obj]; <span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure><h2 id="二、构造函数新增的方法"><a href="#二、构造函数新增的方法" class="headerlink" title="二、构造函数新增的方法"></a>二、构造函数新增的方法</h2><p>关于构造函数，数组新增的方法有如下：</p><ul><li>Array.from()</li><li>Array.of()</li></ul><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p>将两类对象转为真正的数组：类似数组的对象和可遍历<code>（iterable）</code>的对象（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p>用于将一组值，转换为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br></pre></td></tr></table></figure><p>没有参数的时候，返回一个空数组</p><p>当参数只有一个的时候，实际上是指定数组的长度</p><p>参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><h3 id="三、实例对象新增的方法"><a href="#三、实例对象新增的方法" class="headerlink" title="三、实例对象新增的方法"></a>三、实例对象新增的方法</h3><p>关于数组实例对象新增的方法有如下：</p><ul><li>copyWithin()</li><li>find()、findIndex()</li><li>fill()</li><li>entries()，keys()，values()</li><li>includes()</li><li>flat()，flatMap()</li></ul><h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h3><p>将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p><p>参数如下：</p><ul><li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li><li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2</span></span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5] </span></span><br></pre></td></tr></table></figure><h3 id="find-、findIndex"><a href="#find-、findIndex" class="headerlink" title="find()、findIndex()"></a>find()、findIndex()</h3><p><code>find()</code>用于找出第一个符合条件的数组成员</p><p>参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><code>findIndex</code>返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].<span class="title function_">findIndex</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">v</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].<span class="title function_">find</span>(f, person);    <span class="comment">// 26</span></span><br></pre></td></tr></table></figure><h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>使用给定值，填充一个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure><p>还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>注意，如果填充的类型为对象，则是浅拷贝</p><h3 id="entries-，keys-，values"><a href="#entries-，keys-，values" class="headerlink" title="entries()，keys()，values()"></a>entries()，keys()，values()</h3><p><code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">or (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br></pre></td></tr></table></figure><h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><p>用于判断数组是否包含给定的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>方法的第二个参数表示搜索的起始位置，默认为<code>0</code></p><p>参数为负数则表示倒数的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="flat-，flatMap"><a href="#flat-，flatMap" class="headerlink" title="flat()，flatMap()"></a>flat()，flatMap()</h3><p>将数组扁平化处理，返回一个新数组，对原数据没有影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].<span class="title function_">flat</span>()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p><code>flatMap()</code>方法对原数组的每个成员执行一个函数相当于执行<code>Array.prototype.map()</code>，然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">flatMap</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure><p><code>flatMap()</code>方法还可以有第二个参数，用来绑定遍历函数里面的<code>this</code></p><h3 id="四、数组的空位"><a href="#四、数组的空位" class="headerlink" title="四、数组的空位"></a>四、数组的空位</h3><p>数组的空位指，数组的某一个位置没有任何值</p><p>ES6 则是明确将空位转为<code>undefined</code>，包括<code>Array.from</code>、扩展运算符、<code>copyWithin()</code>、<code>fill()</code>、<code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code></p><p>建议大家在日常书写中，避免出现空位</p><h3 id="五、排序稳定性"><a href="#五、排序稳定性" class="headerlink" title="五、排序稳定性"></a>五、排序稳定性</h3><p>将<code>sort()</code>默认设置为稳定的排序算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  <span class="string">&#x27;peach&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;straw&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;spork&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">stableSorting</span> = (<span class="params">s1, s2</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (s1[<span class="number">0</span>] &lt; s2[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">sort</span>(stableSorting)</span><br><span class="line"><span class="comment">// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]</span></span><br></pre></td></tr></table></figure><p>排序结果中，<code>straw</code>在<code>spork</code>的前面，跟原始顺序一致</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://es6.ruanyifeng.com/#docs/array">https://es6.ruanyifeng.com/#docs/array</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6_array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说对WebSocket的理解？应用场景？</title>
      <link href="/2020/12/11/http-websocket/"/>
      <url>/2020/12/11/http-websocket/</url>
      
        <content type="html"><![CDATA[<h1 id="说说对WebSocket的理解？应用场景？"><a href="#说说对WebSocket的理解？应用场景？" class="headerlink" title="说说对WebSocket的理解？应用场景？"></a>说说对WebSocket的理解？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>WebSocket，是一种网络传输协议，位于<code>OSI</code>模型的应用层。可在单个<code>TCP</code>连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅</p><p>客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输</p><p> <img src="https://static.vue-js.com/ad386e20-c0f1-11eb-85f6-6fac77c0c9b3.png"></p><p>从上图可见，<code>websocket</code>服务器与客户端通过握手连接，连接成功后，两者都能主动的向对方发送或接受数据</p><p>而在<code>websocket</code>出现之前，开发实时<code>web</code>应用的方式为轮询</p><p>不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果</p><p>轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 <code>CPU </code>资源</p><h2 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h2><h3 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h3><p>通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合</p><p>例如指 A→B 的同时 B→A ，是瞬时同步的</p><h3 id="二进制帧"><a href="#二进制帧" class="headerlink" title="二进制帧"></a>二进制帧</h3><p>采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比<code>http/2</code>，<code>WebSocket </code>更侧重于“实时通信”，而<code>HTTP/2</code> 更侧重于提高传输效率，所以两者的帧结构也有很大的区别</p><p>不像 <code>HTTP/2</code> 那样定义流，也就不存在多路复用、优先级等特性</p><p>自身就是全双工，也不需要服务器推送</p><h3 id="协议名"><a href="#协议名" class="headerlink" title="协议名"></a>协议名</h3><p>引入<code>ws</code>和<code>wss</code>分别代表明文和密文的<code>websocket</code>协议，且默认端口使用80或443，几乎与<code>http</code>一致</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws://www.chrono.com</span><br><span class="line">ws://www.chrono.com:8080/srv</span><br><span class="line">wss://www.chrono.com:445/im?user_id=xxx</span><br></pre></td></tr></table></figure><h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3><p><code>WebSocket </code>也要有一个握手过程，然后才能正式收发数据</p><p>客户端发送数据格式如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13</span><br></pre></td></tr></table></figure><ul><li>Connection：必须设置Upgrade，表示客户端希望连接升级</li><li>Upgrade：必须设置Websocket，表示希望升级到Websocket协议</li><li>Sec-WebSocket-Key：客户端发送的一个 base64 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept应答，否则客户端会抛出错误，并关闭连接</li><li>Sec-WebSocket-Version ：表示支持的Websocket版本</li></ul><p>服务端返回的数据格式：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><ul><li>HTTP&#x2F;1.1 101 Switching Protocols：表示服务端接受 WebSocket 协议的客户端连接</li><li>Sec-WebSocket-Accep：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里“Sec-WebSocket-Key”的值，加上一个专用的 UUID，再计算摘要</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部</li><li>更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少</li><li>保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证</li><li>更好的二进制支持：定义了二进制帧，更好处理二进制内容</li><li>支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议</li><li>更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li></ul><h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2><p>基于<code>websocket</code>的事实通信的特点，其存在的应用场景大概有：</p><ul><li>弹幕</li><li>媒体聊天</li><li>协同编辑</li><li>基于位置的应用</li><li>体育实况更新</li><li>股票基金报价实时更新</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/WebSocket">https://zh.wikipedia.org/wiki/WebSocket</a></li><li><a href="https://www.oschina.net/translate/9-killer-uses-for-websockets">https://www.oschina.net/translate/9-killer-uses-for-websockets</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http_websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解UDP 和 TCP? 区别? 应用场景?</title>
      <link href="/2020/12/07/http-udp-tcp/"/>
      <url>/2020/12/07/http-udp-tcp/</url>
      
        <content type="html"><![CDATA[<h1 id="如何理解UDP-和-TCP-区别-应用场景"><a href="#如何理解UDP-和-TCP-区别-应用场景" class="headerlink" title="如何理解UDP 和 TCP? 区别? 应用场景?"></a>如何理解UDP 和 TCP? 区别? 应用场景?</h1><h2 id="一、UDP"><a href="#一、UDP" class="headerlink" title="一、UDP"></a>一、UDP</h2><p>UDP（User Datagram Protocol），用户数据包协议，是一个简单的<strong>面向数据报的通信协议</strong>，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层</p><p>也就是说无论应用层交给<code>UDP</code>多长的报文，它统统发送，一次发送一个报文</p><p>而对接收方，接到后直接去除首部，交给上面的应用层就完成任务</p><p><code>UDP</code>报头包括4个字段，每个字段占用2个字节（即16个二进制位），标题短，开销小</p><p> <img src="https://static.vue-js.com/928e5d20-b393-11eb-ab90-d9ae814b240d.png"></p><p>特点如下：</p><ul><li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务</li><li>传输途中出现丢包，UDP 也不负责重发</li><li>当包的到达顺序出现乱序时，UDP没有纠正的功能。</li><li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为</li></ul><h2 id="二、TCP"><a href="#二、TCP" class="headerlink" title="二、TCP"></a>二、TCP</h2><p>TCP（Transmission Control Protocol），传输控制协议，是一种可靠、<strong>面向字节流的通信协议</strong>，把上面应用层交下来的数据看成无结构的字节流来发送</p><p>可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小</p><p><code>TCP</code>报文首部有20个字节，额外开销大</p><p> <img src="https://static.vue-js.com/a0010d40-b393-11eb-ab90-d9ae814b240d.png"></p><p>特点如下：</p><ul><li>TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li><li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li><li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）</li></ul><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p><code>UDP</code>与<code>TCP</code>两者的都位于传输层，如下图所示：</p><p> <img src="https://static.vue-js.com/a92bda80-b393-11eb-ab90-d9ae814b240d.png"></p><p>两者区别如下表所示：</p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>可靠性</td><td>可靠</td><td>不可靠</td></tr><tr><td>连接性</td><td>面向连接</td><td>无连接</td></tr><tr><td>报文</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>效率</td><td>传输效率低</td><td>传输效率高</td></tr><tr><td>双共性</td><td>全双工</td><td>一对一、一对多、多对一、多对多</td></tr><tr><td>流量控制</td><td>滑动窗口</td><td>无</td></tr><tr><td>拥塞控制</td><td>慢开始、拥塞避免、快重传、快恢复</td><td>无</td></tr><tr><td>传输效率</td><td>慢</td><td>快</td></tr></tbody></table><ul><li><p>TCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取</p></li><li><p>TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方</p></li><li><p>TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用</p></li><li><p>TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信</p></li></ul><p>两者应用场景如下图：</p><p> <img src="https://static.vue-js.com/b6cdd800-b393-11eb-ab90-d9ae814b240d.png"></p><p>可以看到，TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/">https://zh.wikipedia.org</a></li><li><a href="https://www.shangmayuan.com/a/a1e3ceb218284cefb95de7fd.html">https://www.shangmayuan.com/a/a1e3ceb218284cefb95de7fd.html</a></li><li><a href="https://segmentfault.com/a/1190000021815671">https://segmentfault.com/a/1190000021815671</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http_udp_tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解TCP/IP协议?</title>
      <link href="/2020/11/11/http-tcp-ip/"/>
      <url>/2020/11/11/http-tcp-ip/</url>
      
        <content type="html"><![CDATA[<h1 id="如何理解TCP-IP协议"><a href="#如何理解TCP-IP协议" class="headerlink" title="如何理解TCP&#x2F;IP协议?"></a>如何理解TCP&#x2F;IP协议?</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>TCP&#x2F;IP，<strong>传输控制协议</strong>&#x2F;<strong>网际协议</strong>，是指能够在多个不同网络间实现信息传输的协议簇</p><ul><li>TCP（传输控制协议）</li></ul><p>一种面向连接的、可靠的、基于字节流的传输层通信协议</p><ul><li>IP（网际协议）</li></ul><p>用于封包交换数据网络的协议</p><p>TCP&#x2F;IP协议不仅仅指的是<code>TCP </code>和<code>IP</code>两个协议，而是指一个由<code>FTP</code>、<code>SMTP</code>、<code>TCP</code>、<code>UDP</code>、<code>IP</code>等协议构成的协议簇，</p><p>只是因为在<code>TCP/IP</code>协议中<code>TCP</code>协议和<code>IP</code>协议最具代表性，所以通称为TCP&#x2F;IP协议族（英语：TCP&#x2F;IP Protocol Suite，或TCP&#x2F;IP Protocols）</p><h2 id="二、划分"><a href="#二、划分" class="headerlink" title="二、划分"></a>二、划分</h2><p>TCP&#x2F;IP协议族按层次分别了五层体系或者四层体系</p><p>五层体系的协议结构是综合了 OSI 和 TCP&#x2F;IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层</p><p>五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层</p><p>如下图所示：</p><p> <img src="https://static.vue-js.com/5bb93610-b647-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="五层体系"><a href="#五层体系" class="headerlink" title="五层体系"></a>五层体系</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p><code>TCP/IP</code> 模型将 <code>OSI </code>参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务</p><p>如：<code>FTP</code>、<code>Telnet</code>、<code>DNS</code>、<code>SMTP</code> 等</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能</p><p>传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）</p><p>其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机</p><p>在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境</p><h3 id="四层体系"><a href="#四层体系" class="headerlink" title="四层体系"></a>四层体系</h3><p>TCP&#x2F;IP 的四层结构则如下表所示：</p><table><thead><tr><th>层次名称</th><th>单位</th><th>功 能</th><th>协 议</th></tr></thead><tbody><tr><td>网络接口层</td><td>帧</td><td>负责实际数据的传输，对应OSI参考模型的下两层</td><td>HDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议）</td></tr><tr><td>网络层</td><td>数据报</td><td>负责网络间的寻址数据传输，对应OSI参考模型的第三层</td><td>IP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）</td></tr><tr><td>传输层</td><td>报文段</td><td>负责提供可靠的传输服务，对应OSI参考模型的第四层</td><td>TCP（控制传输协议） UDP（用户数据报协议）</td></tr><tr><td>应用层</td><td></td><td>负责实现一切与应用程序相关的功能，对应OSI参考模型的上三层</td><td>FTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）</td></tr></tbody></table><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>OSI 参考模型与 TCP&#x2F;IP 参考模型区别如下：</p><p>相同点：</p><ul><li>OSI 参考模型与 TCP&#x2F;IP 参考模型都采用了层次结构</li><li>都能够提供面向连接和无连接两种通信服务机制</li></ul><p>不同点：</p><ul><li><p>OSI 采用的七层模型； TCP&#x2F;IP 是四层或五层结构</p></li><li><p>TCP&#x2F;IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分</p></li><li><p>OSI 参考模型虽然网络划分为七层，但实现起来较困难。TCP&#x2F;IP 参考模型作为一种简化的分层结构是可以的</p></li><li><p>TCP&#x2F;IP协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 <code>OSI</code> 设想中的应用程序维度的分层是无法实现的</p></li></ul><p>三种模型对应关系如下图所示：</p><p><img src="https://static.vue-js.com/3fbff4d0-b647-11eb-ab90-d9ae814b240d.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F">https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F</a></li><li><a href="https://zhuanlan.zhihu.com/p/103162095">https://zhuanlan.zhihu.com/p/103162095</a></li><li><a href="https://segmentfault.com/a/1190000039204681">https://segmentfault.com/a/1190000039204681</a></li><li><a href="https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/">https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http_tcp_ip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说HTTP 常见的状态码有哪些，适用场景？</title>
      <link href="/2020/11/07/http-status/"/>
      <url>/2020/11/07/http-status/</url>
      
        <content type="html"><![CDATA[<h1 id="说说HTTP-常见的状态码有哪些，适用场景？"><a href="#说说HTTP-常见的状态码有哪些，适用场景？" class="headerlink" title="说说HTTP 常见的状态码有哪些，适用场景？"></a>说说HTTP 常见的状态码有哪些，适用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>HTTP状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的3位数字代码</p><p>它由 RFC 2616规范定义的，并得到 <code>RFC 2518</code>、<code>RFC 2817</code>、<code>RFC 2295</code>、<code>RFC 2774</code>与 <code>RFC 4918</code>等规范扩展</p><p>简单来讲，<code>http</code>状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态</p><h2 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h2><p>状态码第一位数字决定了不同的响应状态，有如下：</p><ul><li>1 表示消息</li><li>2 表示成功</li><li>3 表示重定向</li><li>4 表示请求错误</li><li>5 表示服务器错误</li></ul><h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><p>代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束</p><p>常见的有：</p><ul><li>100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</li><li>101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级</li></ul><h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><p>代表请求已成功被服务器接收、理解、并接受</p><p>常见的有：</p><ul><li><p>200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回</p></li><li><p>201（已创建）：请求成功并且服务器创建了新的资源</p></li><li><p>202（已创建）：服务器已经接收请求，但尚未处理</p></li><li><p>203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源</p></li><li><p>204（无内容）：服务器成功处理请求，但没有返回任何内容</p></li><li><p>205（重置内容）：服务器成功处理请求，但没有返回任何内容</p></li><li><p>206（部分内容）：服务器成功处理了部分请求</p></li></ul><h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向</p><p>常见的有：</p><ul><li><p>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择</p></li><li><p>301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</p></li><li><p>302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</p></li><li><p>303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</p></li><li><p>305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理</p></li><li><p>307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</p></li></ul><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>代表了客户端看起来可能发生了错误，妨碍了服务器的处理</p><p>常见的有：</p><ul><li>400（错误请求）： 服务器不理解请求的语法</li><li>401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>403（禁止）： 服务器拒绝请求</li><li>404（未找到）： 服务器找不到请求的网页</li><li>405（方法禁用）： 禁用请求中指定的方法</li><li>406（不接受）： 无法使用请求的内容特性响应请求的网页</li><li>407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理</li><li>408（请求超时）： 服务器等候请求时发生超时</li></ul><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</p><p>常见的有：</p><ul><li>500（服务器内部错误）：服务器遇到错误，无法完成请求</li><li>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码</li><li>502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应</li><li>503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）</li><li>504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li><li>505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本</li></ul><h2 id="三、适用场景"><a href="#三、适用场景" class="headerlink" title="三、适用场景"></a>三、适用场景</h2><p>下面给出一些状态码的适用场景：</p><ul><li><p>100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输</p></li><li><p>206：一般用来做断点续传，或者是视频文件等大文件的加载</p></li><li><p>301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名</p></li><li><p>302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面</p></li><li><p>304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分</p></li><li><p>400：参数有误，请求无法被服务器识别</p></li><li><p>403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回</p></li><li><p>404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时</p></li><li><p>503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503</p></li><li><p>504：网关超时</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">https://zh.wikipedia.org/wiki/HTTP状态码</a></li><li><a href="https://kebingzao.com/2018/10/05/http-status-code/">https://kebingzao.com/2018/10/05/http-status-code/</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http_status </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解OSI七层模型?</title>
      <link href="/2020/10/07/http-osi/"/>
      <url>/2020/10/07/http-osi/</url>
      
        <content type="html"><![CDATA[<h1 id="如何理解OSI七层模型"><a href="#如何理解OSI七层模型" class="headerlink" title="如何理解OSI七层模型?"></a>如何理解OSI七层模型?</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架</p><p><code>OSI </code>将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰</p><h2 id="二、划分"><a href="#二、划分" class="headerlink" title="二、划分"></a>二、划分</h2><p><code>OSI</code>主要划分了七层，如下图所示：</p><p> <img src="https://static.vue-js.com/eb1b2170-b61e-11eb-ab90-d9ae814b240d.png"></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用</p><p>该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 <code>DNS</code>，支持万维网应用的 <code>HTTP</code> 协议，电子邮件系统采用的 <code>SMTP </code>协议等</p><p>在应用层交互的数据单元我们称之为报文</p><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 <code>OSI </code>参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务</p><p>该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异</p><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话</p><p>该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题</p><p>传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层</p><p>其中，主要的传输层协议是<code>TCP</code>和<code>UDP</code></p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网</p><p>网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送</p><p>在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层</p><p>在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议</p><p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 <code>IP </code>数据报组装成帧，在两个相邻节点间的链路上传送帧</p><p>每一帧的数据可以分成：报头<code>head</code>和数据<code>data</code>两部分:</p><ul><li>head 标明数据发送者、接受者、数据类型，如 MAC地址</li><li>data 存储了计算机之间交互的数据</li></ul><p>通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>作为<code> OSI</code> 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送</p><p>该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）</p><p>该层主要是和硬件有关，与软件关系不大</p><h2 id="三、传输过程"><a href="#三、传输过程" class="headerlink" title="三、传输过程"></a>三、传输过程</h2><p>数据在各层之间的传输如下图所示：</p><p> <img src="https://static.vue-js.com/f3a89d40-b61e-11eb-85f6-6fac77c0c9b3.png"></p><ul><li>应用层报文被传送到运输层</li><li>在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用</li><li>应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变</li><li>运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报</li><li>网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧</li><li>在物理层数据帧被封装成比特流，之后通过传输介质传送到对端</li><li>对端再一步步解开封装，获取到传送的数据</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B</a></li><li><a href="https://zhuanlan.zhihu.com/p/32059190">https://zhuanlan.zhihu.com/p/32059190</a></li><li><a href="https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/">https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http_osi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS协议 是什么？说说DNS 完整的查询过程?</title>
      <link href="/2020/08/07/http-dns/"/>
      <url>/2020/08/07/http-dns/</url>
      
        <content type="html"><![CDATA[<h1 id="DNS协议-是什么？说说DNS-完整的查询过程"><a href="#DNS协议-是什么？说说DNS-完整的查询过程" class="headerlink" title="DNS协议 是什么？说说DNS 完整的查询过程?"></a>DNS协议 是什么？说说DNS 完整的查询过程?</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器</p><p>简单来讲，<code>DNS</code>相当于一个翻译官，负责将域名翻译成<code>ip</code>地址</p><ul><li>IP 地址：一长串能够唯一地标记网络上的计算机的数字</li><li>域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识</li></ul><p> <img src="https://static.vue-js.com/965a03a0-b78f-11eb-ab90-d9ae814b240d.png"></p><h2 id="二、域名"><a href="#二、域名" class="headerlink" title="二、域名"></a>二、域名</h2><p>域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名…</p><p> <img src="https://static.vue-js.com/9f112780-b78f-11eb-85f6-6fac77c0c9b3.png"></p><p>例如<code>www.xxx.com</code>，<code>www</code>为三级域名、<code>xxx</code>为二级域名、<code>com</code>为顶级域名，系统为用户做了兼容，域名末尾的根域名<code>.</code>一般不需要输入</p><p>在域名的每一层都会有一个域名服务器，如下图：</p><p> <img src="https://static.vue-js.com/f40e0090-b7a4-11eb-85f6-6fac77c0c9b3.png"></p><p>除此之外，还有电脑默认的本地域名服务器</p><h2 id="三、查询方式"><a href="#三、查询方式" class="headerlink" title="三、查询方式"></a>三、查询方式</h2><p>DNS 查询的方式有两种：</p><ul><li>递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案</li></ul><p> <img src="https://static.vue-js.com/a73be9e0-b78f-11eb-85f6-6fac77c0c9b3.png"></p><ul><li>迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求</li></ul><p> <img src="https://static.vue-js.com/b023e1c0-b78f-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="四、域名缓存"><a href="#四、域名缓存" class="headerlink" title="四、域名缓存"></a>四、域名缓存</h2><p>在域名服务器解析的时候，使用缓存保存域名和<code>IP</code>地址的映射</p><p>计算机中<code>DNS</code>的记录也分成了两种缓存方式：</p><ul><li>浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗</li><li>操作系统缓存：操作系统的缓存其实是用户自己配置的 <code>hosts</code> 文件</li></ul><h2 id="五、查询过程"><a href="#五、查询过程" class="headerlink" title="五、查询过程"></a>五、查询过程</h2><p>解析域名的过程如下：</p><ul><li><p>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</p></li><li><p>若没有命中，则继续搜索操作系统的 DNS 缓存</p></li><li><p>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</p></li><li><p>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询</p><ul><li>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</li><li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li></ul></li><li><p>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p></li><li><p>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</p></li><li><p>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起</p></li></ul><p>流程如下图所示：</p><p> <img src="https://static.vue-js.com/bec3c740-b78f-11eb-ab90-d9ae814b240d.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F</a></li><li><a href="https://www.cnblogs.com/jmilkfan-fanguiju/p/12789677.html">https://www.cnblogs.com/jmilkfan-fanguiju/p/12789677.html</a></li><li><a href="https://segmentfault.com/a/1190000039039275">https://segmentfault.com/a/1190000039039275</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http_dns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是HTTP? HTTP 和 HTTPS 的区别?</title>
      <link href="/2020/08/07/http-https/"/>
      <url>/2020/08/07/http-https/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是HTTP-HTTP-和-HTTPS-的区别"><a href="#什么是HTTP-HTTP-和-HTTPS-的区别" class="headerlink" title="什么是HTTP? HTTP 和 HTTPS 的区别?"></a>什么是HTTP? HTTP 和 HTTPS 的区别?</h1><h2 id="一、HTTP"><a href="#一、HTTP" class="headerlink" title="一、HTTP"></a>一、HTTP</h2><p><code>HTTP</code> (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范</p><p> <img src="https://static.vue-js.com/fda119b0-b20b-11eb-85f6-6fac77c0c9b3.png"></p><p>在计算机和网络世界有，存在不同的协议，如广播协议、寻址协议、路由协议等等……</p><p>而<code>HTTP</code>是一个传输协议，即将数据由A传到B或将B传输到A，并且 A 与 B 之间能够存放很多第三方，如： A&lt;&#x3D;&gt;X&lt;&#x3D;&gt;Y&lt;&#x3D;&gt;Z&lt;&#x3D;&gt;B</p><p>传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别</p><p>在实际应用中，<code>HTTP</code>常被用于在<code>Web</code>浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密</p><p>特点如下：</p><ul><li><p>支持客户&#x2F;服务器模式</p></li><li><p>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快</p></li><li><p>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</p></li><li><p>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间</p></li><li><p>无状态：HTTP协议无法根据之前的状态进行本次的请求处理</p></li></ul><h2 id="二、HTTPS"><a href="#二、HTTPS" class="headerlink" title="二、HTTPS"></a>二、HTTPS</h2><p>在上述介绍<code>HTTP</code>中，了解到<code>HTTP</code>传递信息是以明文的形式发送内容，这并不安全。而<code>HTTPS</code>出现正是为了解决<code>HTTP</code>不安全的特性</p><p>为了保证这些隐私数据能加密传输，让<code>HTTP</code>运行安全的<code>SSL/TLS</code>协议上，即 HTTPS &#x3D; HTTP + SSL&#x2F;TLS，通过 <code>SSL</code>证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密</p><p><code>SSL</code> 协议位于<code> TCP/IP</code> 协议与各种应用层协议之间，浏览器和服务器在使用 <code>SSL</code> 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持</p><p> <img src="https://static.vue-js.com/078c50c0-b20c-11eb-ab90-d9ae814b240d.png"></p><p>流程图如下所示：</p><p> <img src="https://static.vue-js.com/0e409fc0-b20c-11eb-85f6-6fac77c0c9b3.png"></p><ul><li>首先客户端通过URL访问服务器建立SSL连接</li><li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端</li><li>客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li><li>服务器利用自己的私钥解密出会话密钥</li><li>服务器利用会话密钥加密与客户端之间的通信</li></ul><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><ul><li>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL&#x2F;TLS协议进行了加密处理，相对更安全</li><li>HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443</li><li>HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP</li><li>HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/klb561/p/10289199.html">https://www.cnblogs.com/klb561/p/10289199.html</a></li><li><a href="https://www.jianshu.com/p/205c0fc51c97">https://www.jianshu.com/p/205c0fc51c97</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http_https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 常见的请求头有哪些? 作用？</title>
      <link href="/2020/07/07/http-headers/"/>
      <url>/2020/07/07/http-headers/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-常见的请求头有哪些-作用？"><a href="#HTTP-常见的请求头有哪些-作用？" class="headerlink" title="HTTP 常见的请求头有哪些? 作用？"></a>HTTP 常见的请求头有哪些? 作用？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>HTTP头字段（HTTP header fields）,是指在超文本传输协议（HTTP）的请求和响应消息中的消息头部分</p><p>它们定义了一个超文本传输协议事务中的操作参数</p><p>HTTP头部字段可以自己根据需要定义，因此可能在 <code>Web </code>服务器和浏览器上发现非标准的头字段</p><p>下面是一个<code>HTTP</code>请求的请求头：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/home.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>developer.mozilla.org</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>https://developer.mozilla.org/testpage.html</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">If-Modified-Since</span><span class="punctuation">: </span>Mon, 18 Jul 2016 02:36:04 GMT</span><br><span class="line"><span class="attribute">If-None-Match</span><span class="punctuation">: </span>&quot;c561c68d0ba92bbeb8b0fff2a9199f722e3a621a&quot;</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br></pre></td></tr></table></figure><h2 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h2><p>常见的请求字段如下表所示：</p><table><thead><tr><th>字段名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>Accept</td><td>能够接受的回应内容类型（Content-Types）</td><td>Accept: text&#x2F;plain</td></tr><tr><td>Accept-Charset</td><td>能够接受的字符集</td><td>Accept-Charset: utf-8</td></tr><tr><td>Accept-Encoding</td><td>能够接受的编码方式列表</td><td>Accept-Encoding: gzip, deflate</td></tr><tr><td>Accept-Language</td><td>能够接受的回应内容的自然语言列表</td><td>Accept-Language: en-US</td></tr><tr><td>Authorization</td><td>用于超文本传输协议的认证的认证信息</td><td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;</td></tr><tr><td>Cache-Control</td><td>用来指定在这次的请求&#x2F;响应链中的所有缓存机制 都必须 遵守的指令</td><td>Cache-Control: no-cache</td></tr><tr><td>Connection</td><td>该浏览器想要优先使用的连接类型</td><td>Connection: keep-alive Connection: Upgrade</td></tr><tr><td>Cookie</td><td>服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie</td><td>Cookie: $Version&#x3D;1; Skin&#x3D;new;</td></tr><tr><td>Content-Length</td><td>以 八位字节数组 （8位的字节）表示的请求体的长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Type</td><td>请求体的 多媒体类型</td><td>Content-Type: application&#x2F;x-www-form-urlencoded</td></tr><tr><td>Date</td><td>发送该消息的日期和时间</td><td>Date: Tue, 15 Nov 1994 08:12:31 GMT</td></tr><tr><td>Expect</td><td>表明客户端要求服务器做出特定的行为</td><td>Expect: 100-continue</td></tr><tr><td>Host</td><td>服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号</td><td>Host: en.wikipedia.org:80 Host: en.wikipedia.org</td></tr><tr><td>If-Match</td><td>仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源</td><td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Modified-Since</td><td>允许在对应的内容未被修改的情况下返回304未修改</td><td>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td></tr><tr><td>If-None-Match</td><td>允许在对应的内容未被修改的情况下返回304未修改</td><td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Range</td><td>如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体</td><td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>Range</td><td>仅请求某个实体的一部分</td><td>Range: bytes&#x3D;500-999</td></tr><tr><td>User-Agent</td><td>浏览器的浏览器身份标识字符串</td><td>User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:12.0) Gecko&#x2F;20100101 Firefox&#x2F;21.0</td></tr><tr><td>Origin</td><td>发起一个针对 跨来源资源共享 的请求</td><td>Origin: <a href="http://www.example-social-network.com/">http://www.example-social-network.com</a></td></tr></tbody></table><h2 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h2><p>通过配合请求头和响应头，可以满足一些场景的功能实现：</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存是利用的是<code>【Last-Modified，If-Modified-Since】</code>和<code>【ETag、If-None-Match】</code>这两对请求头响应头来管理的</p><p><code>Last-Modified</code> 表示本地文件最后修改日期，浏览器会在request header加上<code>If-Modified-Since</code>（上次返回的<code>Last-Modified</code>的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</p><p><code>Etag</code>就像一个指纹，资源变化都会导致<code>ETag</code>变化，跟最后修改时间没有关系，<code>ETag</code>可以保证每一个资源是唯一的</p><p><code>If-None-Match</code>的header会将上次返回的<code>Etag</code>发送给服务器，询问该资源的<code>Etag</code>是否有更新，有变动就会发送新的资源回来</p><p>而强制缓存不需要发送请求到服务端，根据请求头<code>expires</code>和<code>cache-control</code>判断是否命中强缓存</p><p>强制缓存与协商缓存的流程图如下所示：</p><p> <img src="https://static.vue-js.com/a4065b00-bc69-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="会话状态"><a href="#会话状态" class="headerlink" title="会话状态"></a>会话状态</h3><p><code>cookie</code>，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据，通过响应头<code>set-cookie</code>决定</p><p>作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 <code>Cookie </code>有效期、安全性、使用范围的可选属性组成</p><p><code>Cookie</code> 主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5">https://zh.wikipedia.org/wiki/HTTP头字段</a></li><li><a href="https://github.com/amandakelake/blog/issues/41">https://github.com/amandakelake/blog/issues/41</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http_headers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说TCP为什么需要三次握手和四次挥手？</title>
      <link href="/2020/04/08/http-handshakes-waves/"/>
      <url>/2020/04/08/http-handshakes-waves/</url>
      
        <content type="html"><![CDATA[<h1 id="说说TCP为什么需要三次握手和四次挥手？"><a href="#说说TCP为什么需要三次握手和四次挥手？" class="headerlink" title="说说TCP为什么需要三次握手和四次挥手？"></a>说说TCP为什么需要三次握手和四次挥手？</h1><h2 id="一、三次握手"><a href="#一、三次握手" class="headerlink" title="一、三次握手"></a>一、三次握手</h2><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包</p><p>主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备</p><p>过程如下：</p><ul><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于  SYN_SENT 状态</li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD  的状态</li><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED  状态，此时，双方已建立起了连接</li></ul><p> <img src="https://static.vue-js.com/fb489fc0-beb9-11eb-85f6-6fac77c0c9b3.png"></p><p>上述每一次握手的作用如下：</p><ul><li>第一次握手：客户端发送网络包，服务端收到了<br>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li><li>第二次握手：服务端发包，客户端收到了<br>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常</li><li>第三次握手：客户端发包，服务端收到了。<br>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常</li></ul><p>通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了</p><h3 id="为什么不是两次握手"><a href="#为什么不是两次握手" class="headerlink" title="为什么不是两次握手?"></a>为什么不是两次握手?</h3><p>如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到</p><p>并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源</p><h2 id="二、四次挥手"><a href="#二、四次挥手" class="headerlink" title="二、四次挥手"></a>二、四次挥手</h2><p><code>tcp</code>终止一个连接，需要经过四次挥手</p><p>过程如下：</p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于  FIN_WAIT1 状态，停止发送数据，等待服务端的确认</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态</li></ul><p> <img src="https://static.vue-js.com/0a3ebb90-beba-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="四次挥手原因"><a href="#四次挥手原因" class="headerlink" title="四次挥手原因"></a>四次挥手原因</h3><p>服务端在收到客户端断开连接<code>Fin</code>报文后，并不会立即关闭连接，而是先发送一个<code>ACK</code>包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送<code>FIN</code>报文断开连接，因此需要四次挥手</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>一个完整的三次握手四次挥手如下图所示：</p><p> <img src="https://static.vue-js.com/65941490-beba-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/53374516">https://zhuanlan.zhihu.com/p/53374516</a></li><li><a href="https://segmentfault.com/a/1190000020610336">https://segmentfault.com/a/1190000020610336</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http_handshakes_waves </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说一下 GET 和 POST 的区别？</title>
      <link href="/2020/04/07/http-get-post/"/>
      <url>/2020/04/07/http-get-post/</url>
      
        <content type="html"><![CDATA[<h1 id="说一下-GET-和-POST-的区别？"><a href="#说一下-GET-和-POST-的区别？" class="headerlink" title="说一下 GET 和 POST 的区别？"></a>说一下 GET 和 POST 的区别？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>GET</code>和<code>POST</code>，两者是<code>HTTP</code>协议中发送请求的方法</p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p><code>GET</code>方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p><code>POST</code>方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或<strong>副作用</strong></p><p>本质上都是<code>TCP</code>链接，并无差别</p><p>但是由于<code>HTTP</code>的规定和浏览器&#x2F;服务器的限制，导致他们在应用过程中会体现出一些区别</p><h2 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h2><p>从<code>w3schools</code>得到的标准答案的区别如下：</p><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中</li></ul><h3 id="参数位置"><a href="#参数位置" class="headerlink" title="参数位置"></a>参数位置</h3><p>貌似从上面看到<code>GET</code>与<code>POST</code>请求区别非常大，但两者实质并没有区别</p><p>无论 <code>GET </code>还是 <code>POST</code>，用的都是同一个传输层协议，所以在传输上没有区别</p><p>当不携带参数的时候，两者最大的区别为第一行方法名不同</p><blockquote><p>POST &#x2F;uri HTTP&#x2F;1.1 \r\n</p><p>GET &#x2F;uri HTTP&#x2F;1.1 \r\n</p></blockquote><p>当携带参数的时候，我们都知道<code>GET</code>请求是放在<code>url</code>中，<code>POST</code>则放在<code>body</code>中</p><p><code>GET</code> 方法简约版报文是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html?name=qiming.c&amp;age=22 HTTP/1.1</span><br><span class="line">Host: localhost</span><br></pre></td></tr></table></figure><p><code>POST </code>方法简约版报文是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /index.html HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">name=qiming.c&amp;age=22</span><br></pre></td></tr></table></figure><p>注意：这里只是约定，并不属于<code>HTTP</code>规范，相反的，我们可以在<code>POST</code>请求中<code>url</code>中写入参数，或者<code>GET</code>请求中的<code>body</code>携带参数</p><h3 id="参数长度"><a href="#参数长度" class="headerlink" title="参数长度"></a>参数长度</h3><p><code>HTTP </code>协议没有<code>Body</code>和 <code>URL</code> 的长度限制，对 <code>URL </code>限制的大多是浏览器和服务器的原因</p><p><code>IE</code>对<code>URL</code>长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持</p><p>这里限制的是整个<code>URL</code>长度，而不仅仅是参数值的长度</p><p>服务器处理长<code> URL</code> 要消耗比较多的资源，为了性能和安全考虑，会给 <code>URL</code> 长度加限制</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p><code>POST </code>比<code> GET</code> 安全，因为数据在地址栏上不可见</p><p>然而，从传输的角度来说，他们都是不安全的，因为<code> HTTP</code> 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文</p><p>只有使用<code>HTTPS</code>才能加密安全</p><h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><p>对于<code>GET</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应200（返回数据）</p><p>对于<code>POST</code>，浏览器先发送<code>header</code>，服务器响应100 <code>continue</code>，浏览器再发送<code>data</code>，服务器响应200 ok</p><p>并不是所有浏览器都会在<code>POST</code>中发送两次包，<code>Firefox</code>就只发送一次</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&mid=100000054&idx=1&sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd">https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd</a></li><li><a href="https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/">https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/</a></li><li><a href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp">https://www.w3school.com.cn/tags/html_ref_httpmethods.asp</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http_get_post </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解CDN？说说实现原理？</title>
      <link href="/2020/02/03/http-cdn/"/>
      <url>/2020/02/03/http-cdn/</url>
      
        <content type="html"><![CDATA[<h1 id="如何理解CDN？说说实现原理？"><a href="#如何理解CDN？说说实现原理？" class="headerlink" title="如何理解CDN？说说实现原理？"></a>如何理解CDN？说说实现原理？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>CDN (全称 Content Delivery Network)，即内容分发网络</p><p>构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。<code>CDN</code> 的关键技术主要有内容存储和分发技术</p><p>简单来讲，<code>CDN</code>就是根据用户位置分配最近的资源</p><p>于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫<strong>边缘节点</strong>，其实就是缓存了源站内容的代理服务器。如下图：</p><p> <img src="https://static.vue-js.com/4f0289f0-b86b-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="二、原理分析"><a href="#二、原理分析" class="headerlink" title="二、原理分析"></a>二、原理分析</h2><p>在没有应用<code>CDN</code>时，我们使用域名访问某一个站点时的路径为</p><blockquote><p>用户提交域名→浏览器对域名进行解释→<code>DNS</code> 解析得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复</p></blockquote><p>应用<code>CDN</code>后，<code>DNS</code> 返回的不再是 <code>IP</code> 地址，而是一个<code>CNAME</code>(Canonical Name ) 别名记录，指向<code>CDN</code>的全局负载均衡</p><p><code>CNAME</code>实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是<code>CDN</code>实现的关键</p><h4 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h4><p>由于没有返回<code>IP</code>地址，于是本地<code>DNS</code>会向负载均衡系统再发送请求  ，则进入到<code>CDN</code>的全局负载均衡系统进行智能调度：</p><ul><li><p>看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点</p></li><li><p>看用户所在的运营商网络，找相同网络的边缘节点</p></li><li><p>检查边缘节点的负载情况，找负载较轻的节点</p></li><li><p>其他，比如节点的“健康状况”、服务能力、带宽、响应时间等</p></li></ul><p>结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问<code>CDN</code>的缓存代理</p><p>整体流程如下图：</p><p> <img src="https://static.vue-js.com/588d7890-b86b-11eb-85f6-6fac77c0c9b3.png"></p><h4 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h4><p>缓存系统是 <code>CDN </code>的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源</p><p>其中有两个衡量<code>CDN</code>服务质量的指标：</p><ul><li>命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比</li><li>回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比</li></ul><p>缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户</p><p>回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源</p><p>现在的商业 <code>CDN</code>命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><code>CDN</code> 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度</p><p><code>CDN</code> 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速</p><p>通过<code>CDN</code>的负载均衡系统，智能调度边缘节点提供服务，相当于<code>CDN</code>服务的大脑，而缓存系统相当于<code>CDN</code>的心脏，缓存命中直接返回给用户，否则回源</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF">https://zh.wikipedia.org/wiki/內容傳遞網路</a></li><li><a href="https://juejin.cn/post/6844903890706661389#heading-5">https://juejin.cn/post/6844903890706661389#heading-5</a></li><li><a href="https://blog.csdn.net/lxx309707872/article/details/109078783">https://blog.csdn.net/lxx309707872/article/details/109078783</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http_cdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>地址栏输入 URL 敲下回车后发生了什么?</title>
      <link href="/2020/01/01/http-after-url/"/>
      <url>/2020/01/01/http-after-url/</url>
      
        <content type="html"><![CDATA[<h1 id="地址栏输入-URL-敲下回车后发生了什么"><a href="#地址栏输入-URL-敲下回车后发生了什么" class="headerlink" title="地址栏输入 URL 敲下回车后发生了什么?"></a>地址栏输入 URL 敲下回车后发生了什么?</h1><h2 id="一、简单分析"><a href="#一、简单分析" class="headerlink" title="一、简单分析"></a>一、简单分析</h2><p>简单的分析，从输入 <code>URL</code>到回车后发生的行为如下：</p><ul><li>URL解析</li><li>DNS 查询</li><li>TCP 连接</li><li>HTTP 请求</li><li>响应请求</li><li>页面渲染</li></ul><h2 id="二、详细分析"><a href="#二、详细分析" class="headerlink" title="二、详细分析"></a>二、详细分析</h2><h3 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h3><p>首先判断你输入的是一个合法的<code> URL</code> 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作</p><p><code>URL</code>的解析第过程中的第一步，一个<code>url</code>的结构解析如下：</p><p> <img src="https://static.vue-js.com/27a0c690-bdf4-11eb-ab90-d9ae814b240d.png"></p><h3 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h3><p>在之前文章中讲过<code>DNS</code>的查询，这里就不再讲述了</p><p>整个查询过程如下图所示：</p><p> <img src="https://static.vue-js.com/330fb770-bdf4-11eb-85f6-6fac77c0c9b3.png"></p><p>最终，获取到了域名对应的目标服务器<code>IP</code>地址</p><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>在之前文章中，了解到<code>tcp</code>是一种面向有连接的传输层协议</p><p>在确定目标服务器服务器的<code>IP</code>地址后，则经历三次握手建立<code>TCP</code>连接，流程如下：</p><p> <img src="https://static.vue-js.com/ad750790-bdf4-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="发送-http-请求"><a href="#发送-http-请求" class="headerlink" title="发送 http 请求"></a>发送 http 请求</h3><p>当建立<code>tcp</code>连接之后，就可以在这基础上进行通信，浏览器发送 <code>http</code> 请求到目标服务器</p><p>请求的内容包括：</p><ul><li>请求行</li><li>请求头</li><li>请求主体</li></ul><p> <img src="https://static.vue-js.com/bbcb60f0-bdf4-11eb-ab90-d9ae814b240d.png"></p><h3 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h3><p>当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个<code>HTTP</code>响应消息，包括：</p><ul><li>状态行</li><li>响应头</li><li>响应正文</li></ul><p> <img src="https://static.vue-js.com/c5fe0140-bdf4-11eb-ab90-d9ae814b240d.png"></p><p>在服务器响应之后，由于现在<code>http</code>默认开始长连接<code>keep-alive</code>，当页面关闭之后，<code>tcp</code>链接则会经过四次挥手完成断开</p><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><p>当浏览器接收到服务器响应的资源后，首先会对资源进行解析：</p><ul><li>查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储cookie，解压gzip，缓存资源等等</li><li>查看响应头的 Content-Type的值，根据不同的资源类型采用不同的解析方式</li></ul><p>关于页面的渲染过程如下：</p><ul><li>解析HTML，构建 DOM 树</li><li>解析 CSS ，生成 CSS 规则树</li><li>合并 DOM 树和 CSS 规则，生成 render 树</li><li>布局 render 树（ Layout &#x2F; reflow ），负责各元素尺寸、位置的计算</li><li>绘制 render 树（ paint ），绘制页面像素信息</li><li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</li></ul><p> <img src="https://static.vue-js.com/db7bddd0-bdf4-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://github.com/febobo/web-interview/issues/141">https://github.com/febobo/web-interview/issues/141</a></li><li><a href="https://zhuanlan.zhihu.com/p/80551769">https://zhuanlan.zhihu.com/p/80551769</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http_after_url </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP1.0/1.1/2.0 的区别?</title>
      <link href="/2020/01/01/http-1-0-1-1-2-0/"/>
      <url>/2020/01/01/http-1-0-1-1-2-0/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP1-0-1-1-2-0-的区别"><a href="#HTTP1-0-1-1-2-0-的区别" class="headerlink" title="HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?"></a>HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?</h1><h2 id="一、HTTP1-0"><a href="#一、HTTP1-0" class="headerlink" title="一、HTTP1.0"></a>一、HTTP1.0</h2><p><code>HTTP</code>协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本</p><p><code>HTTP 1.0</code> 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个<code>TCP</code>连接</p><p>服务器完成请求处理后立即断开<code>TCP</code>连接，服务器不跟踪每个客户也不记录过去的请求</p><p>简单来讲，每次与服务器交互，都需要新开一个连接</p><p> <img src="https://static.vue-js.com/efff4da0-b93a-11eb-85f6-6fac77c0c9b3.png"></p><p>例如，解析<code>html</code>文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接</p><p>最终导致，一个<code>html</code>文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接</p><p>这种形式明显造成了性能上的缺陷</p><p>如果需要建立长连接，需要设置一个非标准的Connection字段 <code>Connection: keep-alive</code></p><h2 id="二、HTTP1-1"><a href="#二、HTTP1-1" class="headerlink" title="二、HTTP1.1"></a>二、HTTP1.1</h2><p>在<code>HTTP1.1</code>中，默认支持长连接（<code>Connection: keep-alive</code>），即在一个TCP连接上可以传送多个<code>HTTP</code>请求和响应，减少了建立和关闭连接的消耗和延迟</p><p>建立一次连接，多次请求均由这个连接完成</p><p> <img src="https://static.vue-js.com/22db2b90-b93b-11eb-ab90-d9ae814b240d.png"></p><p>这样，在加载<code>html</code>文件的时候，文件中多个请求和响应就可以在一个连接中传输</p><p>同时，<code>HTTP 1.1</code>还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间</p><p>同时，<code>HTTP1.1</code>在<code>HTTP1.0</code>的基础上，增加更多的请求头和响应头来完善的功能，如下：</p><ul><li>引入了更多的缓存控制策略，如If-Unmodified-Since, If-Match, If-None-Match等缓存头来控制缓存策略</li><li>引入range，允许值请求资源某个部分</li><li>引入host，实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点</li></ul><p>并且还添加了其他的请求方法：<code>put</code>、<code>delete</code>、<code>options</code>…</p><h2 id="三、HTTP2-0"><a href="#三、HTTP2-0" class="headerlink" title="三、HTTP2.0"></a>三、HTTP2.0</h2><p>而<code>HTTP2.0</code>在相比之前版本，性能上有很大的提升，如添加了一个特性：</p><ul><li>多路复用</li><li>二进制分帧</li><li>首部压缩</li><li>服务器推送</li></ul><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p><code>HTTP/2</code> 复用<code>TCP</code>连接，在一个连接里，客户端和浏览器都可以<strong>同时</strong>发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”</p><p> <img src="https://static.vue-js.com/313f1980-b93b-11eb-85f6-6fac77c0c9b3.png"></p><p>上图中，可以看到第四步中<code>css</code>、<code>js</code>资源是同时发送到服务端</p><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>帧是<code>HTTP2</code>通信中最小单位信息</p><p><code>HTTP/2</code> 采用二进制格式传输数据，而非 <code>HTTP 1.x </code>的文本格式，解析起来更高效</p><p>将请求和响应数据分割为更小的帧，并且它们采用二进制编码</p><p><code>HTTP2 </code>中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流</p><p>每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件</p><h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p><code>HTTP/2</code>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送</p><p>首部表在<code>HTTP/2</code>的连接存续期内始终存在，由客户端和服务器共同渐进地更新</p><p>例如：下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销</p><p> <img src="https://static.vue-js.com/3c536740-b93b-11eb-ab90-d9ae814b240d.png"></p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p><code>HTTP2</code>引入服务器推送，允许服务端推送资源给客户端</p><p>服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源</p><p>免得客户端再次创建连接发送请求到服务器端获取</p><p>这种方式非常合适加载静态资源</p><p> <img src="https://static.vue-js.com/47130550-b93b-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>HTTP1.0：</p><ul><li>浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接</li></ul><p>HTTP1.1：</p><ul><li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用</li><li>在同一个TCP连接里面，客户端可以同时发送多个请求</li><li>虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着</li><li>新增了一些请求方法</li><li>新增了一些请求头和响应头</li></ul><p>HTTP2.0：</p><ul><li>采用二进制格式而非文本格式</li><li>完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</li><li>使用报头压缩，降低开销</li><li>服务器推送</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#HTTP/1.0">https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#HTTP/1.0</a></li><li><a href="https://www.jianshu.com/p/52d86558ca57">https://www.jianshu.com/p/52d86558ca57</a></li><li><a href="https://segmentfault.com/a/1190000016496448">https://segmentfault.com/a/1190000016496448</a></li><li><a href="https://zhuanlan.zhihu.com/p/26559480">https://zhuanlan.zhihu.com/p/26559480</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http_1.0_1.1_2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是单点登录？如何实现？</title>
      <link href="/2019/12/31/js-single-sign/"/>
      <url>/2019/12/31/js-single-sign/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是单点登录？如何实现？"><a href="#什么是单点登录？如何实现？" class="headerlink" title="什么是单点登录？如何实现？"></a>什么是单点登录？如何实现？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一</p><p>SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p><p>SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过<code>passport</code>，子系统本身将不参与登录操作</p><p>当一个系统成功登录以后，<code>passport</code>将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被<code>passport</code>授权以后，会建立一个局部会话，在一定时间内可以无需再次向<code>passport</code>发起认证</p><p> <img src="https://static.vue-js.com/2b9b0e70-8c4b-11eb-85f6-6fac77c0c9b3.png"></p><p>上图有四个系统，分别是<code>Application1</code>、<code>Application2</code>、<code>Application3</code>、和<code>SSO</code>，当<code>Application1</code>、<code>Application2</code>、<code>Application3</code>需要登录时，将跳到<code>SSO</code>系统，<code>SSO</code>系统完成登录，其他的应用系统也就随之登录了</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录</p><h2 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h2><h3 id="同域名下的单点登录"><a href="#同域名下的单点登录" class="headerlink" title="同域名下的单点登录"></a>同域名下的单点登录</h3><p><code>cookie</code>的<code>domain</code>属性设置为当前域的父域，并且父域的<code>cookie</code>会被子域所共享。<code>path</code>属性默认为<code>web</code>应用的上下文路径</p><p>利用 <code>Cookie</code> 的这个特点，没错，我们只需要将<code>Cookie</code>的<code> domain</code>属性设置为父域的域名（主域名），同时将 <code>Cookie </code>的<code>path</code>属性设置为根路径，将 <code>Session ID</code>（或 <code>Token</code>）保存到父域中。这样所有的子域应用就都可以访问到这个<code>Cookie</code></p><p>不过这要求应用系统的域名需建立在一个共同的主域名之下，如 <code>tieba.baidu.com</code> 和 <code>map.baidu.com</code>，它们都建立在 <code>baidu.com </code>这个主域名之下，那么它们就可以通过这种方式来实现单点登录</p><h3 id="不同域名下的单点登录-一"><a href="#不同域名下的单点登录-一" class="headerlink" title="不同域名下的单点登录(一)"></a>不同域名下的单点登录(一)</h3><p>如果是不同域的情况下，<code>Cookie</code>是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的 <code>Web </code>服务</p><p>用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 <code>token</code> 写入 <code>Cookie</code>（注意这个 <code>Cookie </code>是认证中心的，应用系统是访问不到的）</p><p>应用系统检查当前请求有没有 <code>Token</code>，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心</p><p>由于这个操作会将认证中心的 <code>Cookie</code> 自动带过去，因此，认证中心能够根据 <code>Cookie</code> 知道用户是否已经登录过了</p><p>如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录</p><p>如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 <code>URL </code>，并在跳转前生成一个 <code>Token</code>，拼接在目标<code> URL</code> 的后面，回传给目标应用系统</p><p>应用系统拿到 <code>Token </code>之后，还需要向认证中心确认下 <code>Token</code> 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 <code>Token </code>写入<code> Cookie</code>，然后给本次访问放行。（注意这个 <code>Cookie</code> 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 <code>Token</code>，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了</p><p>此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法</p><h3 id="不同域名下的单点登录-二"><a href="#不同域名下的单点登录-二" class="headerlink" title="不同域名下的单点登录(二)"></a>不同域名下的单点登录(二)</h3><p>可以选择将 <code>Session ID</code> （或 <code>Token</code> ）保存到浏览器的 <code>LocalStorage</code> 中，让前端在每次向后端发送请求时，主动将<code>LocalStorage</code>的数据传递给服务端</p><p>这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 <code>Session ID </code>（或 <code>Token </code>）放在响应体中传递给前端</p><p>单点登录完全可以在前端实现。前端拿到 <code>Session ID </code>（或 <code>Token</code> ）后，除了将它写入自己的 <code>LocalStorage</code> 中之外，还可以通过特殊手段将它写入多个其他域下的 <code>LocalStorage</code> 中</p><p>关键代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 token</span></span><br><span class="line"><span class="keyword">var</span> token = result.<span class="property">data</span>.<span class="property">token</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML</span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">iframe.<span class="property">src</span> = <span class="string">&quot;http://app1.com/localstorage.html&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(iframe);</span><br><span class="line"><span class="comment">// 使用postMessage()方法将token传递给iframe</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(token, <span class="string">&quot;http://app1.com&quot;</span>);</span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    iframe.<span class="title function_">remove</span>();</span><br><span class="line">&#125;, <span class="number">6000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;token&#x27;</span>, event.<span class="property">data</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>前端通过 <code>iframe</code>+<code>postMessage()</code> 方式，将同一份 <code>Token</code> 写入到了多个域下的 <code>LocalStorage</code> 中，前端每次在向后端发送请求之前，都会主动从 <code>LocalStorage</code> 中读取<code>Token</code>并在请求中携带，这样就实现了同一份<code> Token</code> 被多个域所共享</p><p>此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域</p><h2 id="三、流程"><a href="#三、流程" class="headerlink" title="三、流程"></a>三、流程</h2><p>单点登录的流程图如下所示：</p><p> <img src="https://static.vue-js.com/2422bc40-8c84-11eb-ab90-d9ae814b240d.png"></p><ul><li><p>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</p></li><li><p>sso认证中心发现用户未登录，将用户引导至登录页面</p></li><li><p>用户输入用户名密码提交登录申请</p></li><li><p>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌</p></li><li><p>sso认证中心带着令牌跳转会最初的请求地址（系统1）</p></li><li><p>系统1拿到令牌，去sso认证中心校验令牌是否有效</p></li><li><p>sso认证中心校验令牌，返回有效，注册系统1</p></li><li><p>系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</p></li><li><p>用户访问系统2的受保护资源</p></li><li><p>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</p></li><li><p>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</p></li><li><p>系统2拿到令牌，去sso认证中心校验令牌是否有效</p></li><li><p>sso认证中心校验令牌，返回有效，注册系统2</p></li><li><p>系统2使用该令牌创建与用户的局部会话，返回受保护资源</p></li></ul><p>用户登录成功之后，会与<code>sso</code>认证中心及各个子系统建立会话，用户与<code>sso</code>认证中心建立的会话称为全局会话</p><p>用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过<code>sso</code>认证中心</p><p>全局会话与局部会话有如下约束关系：</p><ul><li>局部会话存在，全局会话一定存在</li><li>全局会话存在，局部会话不一定存在</li><li>全局会话销毁，局部会话必须销毁</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/weixin_36380516/article/details/109006828">https://blog.csdn.net/weixin_36380516/article/details/109006828</a></li><li><a href="https://baike.baidu.com/item/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95">https://baike.baidu.com/item/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95</a></li><li><a href="https://juejin.cn/post/6844903664985866253">https://juejin.cn/post/6844903664985866253</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_single_sign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何判断一个元素是否在可视区域中？</title>
      <link href="/2019/12/14/js-visible/"/>
      <url>/2019/12/14/js-visible/</url>
      
        <content type="html"><![CDATA[<h1 id="如何判断一个元素是否在可视区域中？"><a href="#如何判断一个元素是否在可视区域中？" class="headerlink" title="如何判断一个元素是否在可视区域中？"></a>如何判断一个元素是否在可视区域中？</h1><h2 id="一、用途"><a href="#一、用途" class="headerlink" title="一、用途"></a>一、用途</h2><p>可视区域即我们浏览网页的设备肉眼可见的区域，如下图</p><p> <img src="https://static.vue-js.com/9c5bbb10-8a56-11eb-85f6-6fac77c0c9b3.png"></p><p>在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：</p><ul><li>图片的懒加载</li><li>列表的无限滚动</li><li>计算广告元素的曝光情况</li><li>可点击链接的预加载</li></ul><h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><p>判断一个元素是否在可视区域，我们常用的有三种办法：</p><ul><li><p>offsetTop、scrollTop</p></li><li><p>getBoundingClientRect </p></li><li><p>Intersection Observer</p></li></ul><h3 id="offsetTop、scrollTop"><a href="#offsetTop、scrollTop" class="headerlink" title="offsetTop、scrollTop"></a>offsetTop、scrollTop</h3><p><code>offsetTop</code>，元素的上外边框至包含元素的上内边框之间的像素距离，其他<code>offset</code>属性如下图所示：</p><p> <img src="https://static.vue-js.com/b4b63ca0-8a54-11eb-85f6-6fac77c0c9b3.png"></p><p>下面再来了解下<code>clientWidth</code>、<code>clientHeight</code>：</p><ul><li><code>clientWidth</code>：元素内容区宽度加上左右内边距宽度，即<code>clientWidth = content + padding</code></li><li><code>clientHeight</code>：元素内容区高度加上上下内边距高度，即<code>clientHeight = content + padding</code></li></ul><p>这里可以看到<code>client</code>元素都不包括外边距</p><p>最后，关于<code>scroll</code>系列的属性如下：</p><ul><li><p><code>scrollWidth</code> 和 <code>scrollHeight</code> 主要用于确定元素内容的实际大小</p></li><li><p><code>scrollLeft</code> 和 <code>scrollTop</code> 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置</p></li><li><ul><li>垂直滚动 <code>scrollTop &gt; 0</code></li><li>水平滚动 <code>scrollLeft &gt; 0</code></li></ul></li><li><p>将元素的 <code>scrollLeft</code> 和 <code>scrollTop</code> 设置为 0，可以重置元素的滚动位置</p></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>上述属性都是只读的，每次访问都要重新开始</li></ul><p>下面再看看如何实现判断：</p><p>公式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="property">offsetTop</span> - <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> &lt;= viewPortHeight</span><br></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPortOfOne</span> (el) &#123;</span><br><span class="line">    <span class="comment">// viewPortHeight 兼容所有浏览器写法</span></span><br><span class="line">    <span class="keyword">const</span> viewPortHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span> </span><br><span class="line">    <span class="keyword">const</span> offsetTop = el.<span class="property">offsetTop</span></span><br><span class="line">    <span class="keyword">const</span> scrollTop = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span></span><br><span class="line">    <span class="keyword">const</span> top = offsetTop - scrollTop</span><br><span class="line">    <span class="keyword">return</span> top &lt;= viewPortHeight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h3><p>返回值是一个 <code>DOMRect</code>对象，拥有<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>, <code>x</code>, <code>y</code>, <code>width</code>, 和 <code>height</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.target&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> clientRect = target.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(clientRect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   bottom: 556.21875,</span></span><br><span class="line"><span class="comment">//   height: 393.59375,</span></span><br><span class="line"><span class="comment">//   left: 333,</span></span><br><span class="line"><span class="comment">//   right: 1017,</span></span><br><span class="line"><span class="comment">//   top: 162.625,</span></span><br><span class="line"><span class="comment">//   width: 684</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>属性对应的关系图如下所示：</p><p> <img src="https://static.vue-js.com/e34ac5d0-8a05-11eb-85f6-6fac77c0c9b3.png"></p><p>当页面发生滚动的时候，<code>top</code>与<code>left</code>属性值都会随之改变</p><p>如果一个元素在视窗之内的话，那么它一定满足下面四个条件：</p><ul><li>top 大于等于 0</li><li>left 大于等于 0</li><li>bottom 小于等于视窗高度</li><li>right 小于等于视窗宽度</li></ul><p>实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPort</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> viewWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">  <span class="keyword">const</span> viewHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    top,</span><br><span class="line">    right,</span><br><span class="line">    bottom,</span><br><span class="line">    left,</span><br><span class="line">  &#125; = element.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    top &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    left &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    right &lt;= viewWidth &amp;&amp;</span><br><span class="line">    bottom &lt;= viewHeight</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Intersection-Observer"><a href="#Intersection-Observer" class="headerlink" title="Intersection Observer"></a>Intersection Observer</h3><p><code>Intersection Observer</code> 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比<code>getBoundingClientRect </code>会好很多</p><p>使用步骤主要分为两步：创建观察者和传入被观察者</p><h4 id="创建观察者"><a href="#创建观察者" class="headerlink" title="创建观察者"></a>创建观察者</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="comment">// 表示重叠面积占被观察者的比例，从 0 - 1 取值，</span></span><br><span class="line">  <span class="comment">// 1 表示完全被包含</span></span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">1.0</span>, </span><br><span class="line">  <span class="attr">root</span>:<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#scrollArea&#x27;</span>) <span class="comment">// 必须是目标元素的父级元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params">entries, observer</span>) =&gt; &#123; ....&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback, options);</span><br></pre></td></tr></table></figure><p>通过<code>new IntersectionObserver</code>创建了观察者 <code>observer</code>，传入的参数 <code>callback</code> 在重叠比例超过 <code>threshold</code> 时会被执行&#96;</p><p>关于<code>callback</code>回调函数常用属性如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上段代码中被省略的 callback</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="keyword">function</span>(<span class="params">entries, observer</span>) &#123; </span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">        entry.<span class="property">time</span>;               <span class="comment">// 触发的时间</span></span><br><span class="line">        entry.<span class="property">rootBounds</span>;         <span class="comment">// 根元素的位置矩形，这种情况下为视窗位置</span></span><br><span class="line">        entry.<span class="property">boundingClientRect</span>; <span class="comment">// 被观察者的位置举行</span></span><br><span class="line">        entry.<span class="property">intersectionRect</span>;   <span class="comment">// 重叠区域的位置矩形</span></span><br><span class="line">        entry.<span class="property">intersectionRatio</span>;  <span class="comment">// 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）</span></span><br><span class="line">        entry.<span class="property">target</span>;             <span class="comment">// 被观察者</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="传入被观察者"><a href="#传入被观察者" class="headerlink" title="传入被观察者"></a>传入被观察者</h4><p>通过 <code>observer.observe(target)</code> 这一行代码即可简单的注册被观察者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.target&#x27;</span>);</span><br><span class="line">observer.<span class="title function_">observe</span>(target);</span><br></pre></td></tr></table></figure><h3 id="三、案例分析"><a href="#三、案例分析" class="headerlink" title="三、案例分析"></a>三、案例分析</h3><p>实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色</p><p><code>Html</code>结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;container&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><code>css</code>样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.target</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往<code>container</code>插入1000个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $container = $(<span class="string">&quot;.container&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入 100000 个 &lt;div class=&quot;target&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createTargets</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> htmlString = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">100000</span>)</span><br><span class="line">    .<span class="title function_">fill</span>(<span class="string">&#x27;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&#x27;</span>)</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  $container.<span class="title function_">html</span>(htmlString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，首先使用<code>getBoundingClientRect </code>方法进行判断元素是否在可视区域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPort</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> viewWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">    <span class="keyword">const</span> viewHeight =</span><br><span class="line">          <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; top, right, bottom, left &#125; = element.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top &gt;= <span class="number">0</span> &amp;&amp; left &gt;= <span class="number">0</span> &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始监听<code>scroll</code>事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为<code>yellow</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">on</span>(<span class="string">&quot;scroll&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;scroll !&quot;</span>);</span><br><span class="line">    $targets.<span class="title function_">each</span>(<span class="function">(<span class="params">index, element</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isInViewPort</span>(element)) &#123;</span><br><span class="line">            $(element).<span class="title function_">css</span>(<span class="string">&quot;background-color&quot;</span>, <span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了<code>scroll</code>事件，<code>scroll</code>事件伴随了大量的计算，会造成资源方面的浪费</p><p>下面通过<code>Intersection Observer</code>的形式同样实现相同的功能</p><p>首先创建一个观察者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(getYellow, &#123; <span class="attr">threshold</span>: <span class="number">1.0</span> &#125;);</span><br></pre></td></tr></table></figure><p><code>getYellow</code>回调函数实现对背景颜色改变，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getYellow</span>(<span class="params">entries, observer</span>) &#123;</span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">        $(entry.<span class="property">target</span>).<span class="title function_">css</span>(<span class="string">&quot;background-color&quot;</span>, <span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后传入观察者，即<code>.target</code>元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$targets.<span class="title function_">each</span>(<span class="function">(<span class="params">index, element</span>) =&gt;</span> &#123;</span><br><span class="line">    observer.<span class="title function_">observe</span>(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到功能同样完成，并且页面不会出现卡顿的情况</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API">https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_visible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说你对作用域链的理解</title>
      <link href="/2019/12/13/js-scope/"/>
      <url>/2019/12/13/js-scope/</url>
      
        <content type="html"><![CDATA[<h1 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" class="headerlink" title="说说你对作用域链的理解"></a>说说你对作用域链的理解</h1><h2 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h2><p>作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合</p><p>换句话说，作用域决定了代码区块中变量和其他资源的可见性</p><p>举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> inVariable = <span class="string">&quot;函数内部变量&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">myFunction</span>();<span class="comment">//要先执行这个函数，否则根本不知道里面是啥</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(inVariable); <span class="comment">// Uncaught ReferenceError: inVariable is not defined</span></span><br></pre></td></tr></table></figure><p>上述例子中，函数<code>myFunction</code>内部创建一个<code>inVariable</code>变量，当我们在全局访问这个变量的时候，系统会报错</p><p>这就说明我们在全局是无法获取到（闭包除外）函数内部的变量</p><p>我们一般将作用域分成：</p><ul><li><p>全局作用域</p></li><li><p>函数作用域</p></li><li><p>块级作用域</p></li></ul><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="title function_">greet</span>();</span><br><span class="line"><span class="comment">// 报错： Uncaught ReferenceError: greeting is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br></pre></td></tr></table></figure><p>可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>ES6引入了<code>let</code>和<code>const</code>关键字,和<code>var</code>关键字不同，在大括号中使用<code>let</code>和<code>const</code>声明的变量存在于块级作用域中。在大括号之外不能访问这些变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 块级作用域中的变量</span></span><br><span class="line">  <span class="keyword">let</span> greeting = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> lang = <span class="string">&#x27;English&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting); <span class="comment">// Prints &#x27;Hello World!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变量 &#x27;English&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lang);</span><br><span class="line"><span class="comment">// 报错：Uncaught ReferenceError: greeting is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br></pre></td></tr></table></figure><h2 id="二、词法作用域"><a href="#二、词法作用域" class="headerlink" title="二、词法作用域"></a>二、词法作用域</h2><p>词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，<code>JavaScript</code> 遵循的就是词法作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>()</span><br></pre></td></tr></table></figure><p>上述代码改变成一张图</p><p> <img src="https://static.vue-js.com/29fab3d0-718f-11eb-85f6-6fac77c0c9b3.png"></p><p>由于<code>JavaScript</code>遵循词法作用域，相同层级的 <code>foo</code> 和 <code>bar</code> 就没有办法访问到彼此块作用域中的变量，所以输出2</p><h2 id="三、作用域链"><a href="#三、作用域链" class="headerlink" title="三、作用域链"></a>三、作用域链</h2><p>当在<code>Javascript</code>中使用一个变量的时候，首先<code>Javascript</code>引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域</p><p>如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错</p><p>这里拿《你不知道的Javascript(上)》中的一张图解释：</p><p>把作用域比喻成一个建筑，这份建筑代表程序中的嵌套作用域链，第一层代表当前的执行作用域，顶层代表全局作用域</p><p> <img src="https://static.vue-js.com/33f9c100-718f-11eb-85f6-6fac77c0c9b3.png"></p><p>变量的引用会顺着当前楼层进行查找，如果找不到，则会往上一层找，一旦到达顶层，查找的过程都会停止</p><p>下面代码演示下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sex = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">student</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// 张三</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(sex); <span class="comment">// 男 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">student</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// Uncaught ReferenceError: age is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">person</span>();</span><br></pre></td></tr></table></figure><p>上述代码主要主要做了以下工作：</p><ul><li><code>student</code>函数内部属于最内层作用域，找不到<code>name</code>，向上一层作用域<code>person</code>函数内部找，找到了输出“张三”</li><li><code>student</code>内部输出<code>sex</code>时找不到，向上一层作用域<code>person</code>函数找，还找不到继续向上一层找，即全局作用域，找到了输出“男”</li><li>在<code>person</code>函数内部输出<code>age</code>时找不到，向上一层作用域找，即全局作用域，还是找不到则报错</li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_scope </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说new操作符具体干了什么？</title>
      <link href="/2019/12/12/js-new/"/>
      <url>/2019/12/12/js-new/</url>
      
        <content type="html"><![CDATA[<h1 id="说说new操作符具体干了什么？"><a href="#说说new操作符具体干了什么？" class="headerlink" title="说说new操作符具体干了什么？"></a>说说new操作符具体干了什么？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>在<code>JavaScript</code>中，<code>new</code>操作符用于创建一个给定构造函数的实例对象</p><p>例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1)  <span class="comment">// Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span></span><br><span class="line">t.<span class="title function_">sayName</span>() <span class="comment">// &#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure><p>从上面可以看到：</p><ul><li><code>new</code> 通过构造函数 <code>Person</code> 创建出来的实例可以访问到构造函数中的属性</li><li><code>new</code> 通过构造函数 <code>Person</code> 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来）</li></ul><p>现在在构建函数中显式加上返回值，并且这个返回值是一个原始类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="property">name</span>) <span class="comment">// &#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure><p>可以发现，构造函数中返回一个原始值，然而这个返回值并没有作用</p><p>下面在构造函数中返回一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// Test &#123; name: &#x27;xxx&#x27; &#125;</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">age</span>: <span class="number">26</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t) <span class="comment">// &#123; age: 26 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="property">name</span>) <span class="comment">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure><p>从上面可以发现，构造函数如果返回值为一个对象，那么这个返回值会被正常使用</p><h2 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h2><p>从上面介绍中，我们可以看到<code>new</code>关键字主要做了以下的工作：</p><ul><li><p>创建一个新的对象<code>obj</code></p></li><li><p>将对象与构建函数通过原型链连接起来</p></li><li><p>将构建函数中的<code>this</code>绑定到新建的对象<code>obj</code>上</p></li><li><p>根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理</p></li></ul><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1)  <span class="comment">// Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span></span><br><span class="line">t.<span class="title function_">sayName</span>() <span class="comment">// &#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure><p>流程图如下：</p><p> <img src="https://static.vue-js.com/b429b990-7a39-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="三、手写new操作符"><a href="#三、手写new操作符" class="headerlink" title="三、手写new操作符"></a>三、手写new操作符</h2><p>现在我们已经清楚地掌握了<code>new</code>的执行过程</p><p>那么我们就动手来实现一下<code>new</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mynew</span>(<span class="params">Func, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.创建一个新对象</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">// 2.新对象原型指向构造函数原型对象</span></span><br><span class="line">    obj.<span class="property">__proto__</span> = <span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    <span class="comment">// 3.将构建函数的this指向新对象</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="title class_">Func</span>.<span class="title function_">apply</span>(obj, args)</span><br><span class="line">    <span class="comment">// 4.根据返回值判断</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mynew</span>(<span class="params">func, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    obj.<span class="property">__proto__</span> = func.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    <span class="keyword">let</span> result = func.<span class="title function_">apply</span>(obj, args)</span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="title function_">mynew</span>(<span class="title class_">Person</span>, <span class="string">&quot;huihui&quot;</span>, <span class="number">123</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p) <span class="comment">// Person &#123;name: &quot;huihui&quot;, age: 123&#125;</span></span><br><span class="line">p.<span class="title function_">say</span>() <span class="comment">// huihui</span></span><br></pre></td></tr></table></figure><p>可以发现，代码虽然很短，但是能够模拟实现<code>new</code></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_new </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说 JavaScript 中内存泄漏的几种情况？</title>
      <link href="/2019/12/11/js-memory-leak/"/>
      <url>/2019/12/11/js-memory-leak/</url>
      
        <content type="html"><![CDATA[<h1 id="说说-JavaScript-中内存泄漏的几种情况？"><a href="#说说-JavaScript-中内存泄漏的几种情况？" class="headerlink" title="说说 JavaScript 中内存泄漏的几种情况？"></a>说说 JavaScript 中内存泄漏的几种情况？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存</p><p>并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费</p><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存</p><p>对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃</p><p> <img src="https://static.vue-js.com/56d4bd90-821c-11eb-ab90-d9ae814b240d.png"></p><p>在<code>C</code>语言中，因为是手动管理内存，内存泄露是经常出现的事情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char * buffer;</span><br><span class="line">buffer = (char*) malloc(42);</span><br><span class="line"></span><br><span class="line">// Do something with buffer</span><br><span class="line"></span><br><span class="line">free(buffer);</span><br></pre></td></tr></table></figure><p>上面是 C 语言代码，<code>malloc</code>方法用来申请内存，使用完毕之后，必须自己用<code>free</code>方法释放内存。</p><p>这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”</p><h2 id="二、垃圾回收机制"><a href="#二、垃圾回收机制" class="headerlink" title="二、垃圾回收机制"></a>二、垃圾回收机制</h2><p>Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存</p><p>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存</p><p>通常情况下有两种实现方式：</p><ul><li>标记清除</li><li>引用计数</li></ul><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p><code>JavaScript</code>最常用的垃圾收回机制</p><p>当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“</p><p>垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉</p><p>在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了</p><p>随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">0</span>,n = <span class="number">19</span> <span class="comment">// 把 m,n,add() 标记为进入环境。</span></span><br><span class="line"><span class="title function_">add</span>(m, n) <span class="comment">// 把 a, b, c标记为进入环境。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">// a,b,c标记为离开环境，等待垃圾回收。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  a++</span><br><span class="line">  <span class="keyword">var</span> c = a + b</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是<code>0</code>，就表示这个值不再用到了，因此可以将这块内存释放</p><p>如果一个值不再需要了，引用数却不为<code>0</code>，垃圾回收机制无法释放这块内存，从而导致内存泄漏</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>[1, 2, 3, 4]</code>是一个值，会占用内存。变量<code>arr</code>是仅有的对这个值的引用，因此引用次数为<code>1</code>。尽管后面的代码没有用到<code>arr</code>，它还是会持续占用内存</p><p>如果需要这块内存被垃圾回收机制释放，只需要设置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>通过设置<code>arr</code>为<code>null</code>，就解除了对数组<code>[1,2,3,4]</code>的引用，引用次数变为 0，就被垃圾回收了</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>有了垃圾回收机制，不代表不用关注内存泄露。那些很占空间的值，一旦不再用到，需要检查是否还存在对它们的引用。如果是的话，就必须手动解除引用</p><h2 id="三、常见内存泄露情况"><a href="#三、常见内存泄露情况" class="headerlink" title="三、常见内存泄露情况"></a>三、常见内存泄露情况</h2><p>意外的全局变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种意外的全局变量可能由 <code>this</code> 创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">variable</span> = <span class="string">&quot;potential accidental global&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 调用自己，this 指向了全局对象（window）</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>上述使用严格模式，可以避免意外的全局变量</p><p>定时器也常会造成内存泄露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = <span class="title function_">getData</span>();</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;Node&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="comment">// 处理 node 和 someResource</span></span><br><span class="line">        node.<span class="property">innerHTML</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>如果<code>id</code>为Node的元素从<code>DOM</code>中移除，该定时器仍会存在，同时，因为回调函数中包含对<code>someResource</code>的引用，定时器外面的<code>someResource</code>也不会被释放</p><p>包括我们之前所说的闭包，维持函数内局部变量，使其得不到释放</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;XXX&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj, <span class="string">&#x27;闭包内引用obj obj不会被释放&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  obj = <span class="literal">null</span>; <span class="comment">// 解决方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有清理对<code>DOM</code>元素的引用同样造成内存泄露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refA = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;refA&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(refA); <span class="comment">// dom删除了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(refA, <span class="string">&#x27;refA&#x27;</span>); <span class="comment">// 但是还存在引用能console出整个div 没有被回收</span></span><br><span class="line">refA = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(refA, <span class="string">&#x27;refA&#x27;</span>); <span class="comment">// 解除引用</span></span><br></pre></td></tr></table></figure><p>包括使用事件监听<code>addEventListener</code>监听的时候，在不监听的情况下使用<code>removeEventListener</code>取消对事件监听</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html">http://www.ruanyifeng.com/blog/2017/04/memory-leak.html</a></li><li><a href="https://zh.wikipedia.org/wiki">https://zh.wikipedia.org/wiki</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_memory_leak </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说你了解的js数据结构？</title>
      <link href="/2019/12/06/js-data-structure/"/>
      <url>/2019/12/06/js-data-structure/</url>
      
        <content type="html"><![CDATA[<h1 id="面试官：说说你了解的js数据结构？"><a href="#面试官：说说你了解的js数据结构？" class="headerlink" title="面试官：说说你了解的js数据结构？"></a>面试官：说说你了解的js数据结构？</h1><h2 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h2><p>数据结构是计算机存储、组织数据的方式。<br>数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。</p><p>我们每天的编码中都会用到数据结构<br>数组是最简单的内存数据结构<br>下面是常见的数据结构：</p><ol><li>数组（Array）</li><li>栈（Stack）</li><li>队列（Queue）</li><li>链表（Linked List）</li><li>字典</li><li>散列表（Hash table）</li><li>树（Tree）</li><li>图（Graph）</li><li>堆（Heap）</li></ol><h2 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h2><p>数组是最最基本的数据结构，很多语言都内置支持数组。<br>数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的。</p><p>在日常生活中，人们经常使用列表：待办事项列表、购物清单等。</p><p>而计算机程序也在使用列表，在下面的条件下，选择列表作为数据结构就显得尤为有用：<br>数据结构较为简单<br>不需要在一个长序列中查找元素，或者对其进行排序<br>反之，如果数据结构非常复杂，列表的作用就没有那么大了。</p><h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><p>栈是一种遵循后进先出（LIFO）原则的有序集合<br>在栈里，新元素都接近栈顶，旧元素都接近栈底。<br>每次加入新的元素和拿走元素都在顶部操作<br><img src="https://upload-images.jianshu.io/upload_images/13253432-ddcb884374470d2c?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp"></p><h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><p>队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项<br>队列在尾部添加新元素，并从顶部移除元素<br>最新添加的元素必须排在队列的末尾<br><img src="https://upload-images.jianshu.io/upload_images/13253432-55ad7c7db40d3796?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp"></p><h2 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h2><p>链表也是一种列表，已经设计了数组，为什么还需要链表呢？<br>JavaScript中数组的主要问题时，它们被实现成了对象，<br>与其他语言（比如C++和Java）的数组相对，效率很低。<br>如果你发现数组在实际使用时很慢，就可以考虑使用链表来代替它。</p><p>使用条件：<br>链表几乎可以用在任何可以使用一维数组的情况中。<br>如果需要随机访问，数组仍然是更好的选择。<br><img src="https://raw.githubusercontent.com/zoro-web/blog/master/img/lian.jpg"></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是一种以键-值对存储数据的数据结构，js中的Object类就是以字典的形式设计的。JavaScript可以通过实现字典类，让这种字典类型的对象使用起来更加简单，字典可以实现对象拥有的常见功能，并相应拓展自己想要的功能，而对象在JavaScript编写中随处可见，所以字典的作用也异常明显了。</p><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>也称为哈希表，特点是在散列表上插入、删除和取用数据都非常快。<br>为什么要设计这种数据结构呢？<br>用数组或链表存储数据，如果想要找到其中一个数据，需要从头进行遍历，因为不知道这个数据存储到了数组的哪个位置。</p><p>散列表在JavaScript中可以基础数组去进行设计。<br>数组的长度是预先设定的，所有元素根据和该元素对应的键，保存在数组的特定位置，这里的键和对象的键是类型的概念。<br>使用散列表存储数组时，通过一个散列函数将键映射为一个数字，这个数字的范围是0到散列表的长度。</p><p>即使使用一个高效的散列函数，依然存在将两个键映射为同一个值得可能，这种现象叫做碰撞。常见碰撞的处理方法有：开链法和线性探测法（具体概念有兴趣的可以网上自信了解）<br>使用条件：<br>可以用于数据的插入、删除和取用，不适用于查找数据<br><img src="https://raw.githubusercontent.com/zoro-web/blog/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170820211406.png"></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_data_structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript如何实现继承？</title>
      <link href="/2019/11/16/js-inherit/"/>
      <url>/2019/11/16/js-inherit/</url>
      
        <content type="html"><![CDATA[<h1 id="Javascript如何实现继承？"><a href="#Javascript如何实现继承？" class="headerlink" title="Javascript如何实现继承？"></a>Javascript如何实现继承？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>继承（inheritance）是面向对象软件技术当中的一个概念。</p><p>如果一个类别B“继承自”另一个类别A，就把这个B称为“A的子类”，而把A称为“B的父类别”也可以称“A是B的超类”</p><ul><li>继承的优点</li></ul><p>继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码</p><p>在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能</p><p>虽然<code>JavaScript</code>并不是真正的面向对象语言，但它天生的灵活性，使应用场景更加丰富</p><p>关于继承，我们举个形象的例子：</p><p>定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">color,speed</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = color</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">speed</span> = speed</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由汽车这个类可以派生出“轿车”和“货车”两个类，在汽车的基础属性上，为轿车添加一个后备厢、给货车添加一个大货箱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 货车</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Truck</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Car</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">color,speed</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(color,speed)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Container</span> = <span class="literal">true</span> <span class="comment">// 货箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样轿车和货车就是不一样的，但是二者都属于汽车这个类，汽车、轿车继承了汽车的属性，而不需要再次在“轿车”中定义汽车已经有的属性</p><p>在“轿车”继承“汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与“汽车”这个父类不同的属性和方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Truck</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Car</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">color,speed</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(color,speed)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&quot;black&quot;</span> <span class="comment">//覆盖</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Container</span> = <span class="literal">true</span> <span class="comment">// 货箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子中就能详细说明汽车、轿车以及卡车之间的继承关系</p><h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><p>下面给出<code>JavaScripy</code>常见的继承方式：</p><ul><li><p>原型链继承</p></li><li><p>构造函数继承（借助 call）</p></li><li><p>组合继承</p></li><li><p>原型式继承</p></li><li><p>寄生式继承</p></li><li><p>寄生组合式继承</p></li></ul><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针</p><p>举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent1&#x27;</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child2&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title class_">Child1</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child</span>())</span><br></pre></td></tr></table></figure><p>上面代码看似没问题，实际存在潜在问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">Child2</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="title class_">Child2</span>();</span><br><span class="line">s1.<span class="property">play</span>.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">play</span>, s2.<span class="property">play</span>); <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure><p>改变<code>s1</code>的<code>play</code>属性，会发现<code>s2</code>也跟着发生变化了，这是因为两个实例使用的是同一个原型对象，内存空间是共享的</p><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>借助 <code>call </code>调用<code>Parent</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Parent1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child);  <span class="comment">// 没问题</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="title function_">getName</span>());  <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure><p>可以看到，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法</p><p>相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>前面我们讲到两种继承方式，各有优缺点。组合继承则将前两种方式继承起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent3</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent3&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent3</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child3</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 第二次调用 Parent3()</span></span><br><span class="line">    <span class="title class_">Parent3</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child3&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用 Parent3()</span></span><br><span class="line"><span class="title class_">Child3</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent3</span>();</span><br><span class="line"><span class="comment">// 手动挂上构造器，指向自己的构造函数</span></span><br><span class="line"><span class="title class_">Child3</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child3</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> <span class="title class_">Child3</span>();</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> <span class="title class_">Child3</span>();</span><br><span class="line">s3.<span class="property">play</span>.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3.<span class="property">play</span>, s4.<span class="property">play</span>);  <span class="comment">// 不互相影响</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3.<span class="title function_">getName</span>()); <span class="comment">// 正常输出&#x27;parent3&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s4.<span class="title function_">getName</span>()); <span class="comment">// 正常输出&#x27;parent3&#x27;</span></span><br></pre></td></tr></table></figure><p>这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到<code> Parent3</code> 执行了两次，造成了多构造一次的性能开销</p><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>这里主要借助<code>Object.create</code>方法实现普通对象的继承</p><p>同样举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parent4 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;parent4&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&quot;p1&quot;</span>, <span class="string">&quot;p2&quot;</span>, <span class="string">&quot;p3&quot;</span>],</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> person4 = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent4);</span><br><span class="line">  person4.<span class="property">name</span> = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">  person4.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;jerry&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> person5 = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent4);</span><br><span class="line">  person5.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person4.<span class="property">name</span>); <span class="comment">// tom</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person4.<span class="property">name</span> === person4.<span class="title function_">getName</span>()); <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person5.<span class="property">name</span>); <span class="comment">// parent4</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person4.<span class="property">friends</span>); <span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person5.<span class="property">friends</span>); <span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span></span><br></pre></td></tr></table></figure><p>这种继承方式的缺点也很明显，因为<code>Object.create </code>方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能</p><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parent5 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;parent5&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&quot;p1&quot;</span>, <span class="string">&quot;p2&quot;</span>, <span class="string">&quot;p3&quot;</span>],</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">original</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(original);</span><br><span class="line">    clone.<span class="property">getFriends</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">friends</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person5 = <span class="title function_">clone</span>(parent5);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person5.<span class="title function_">getName</span>()); <span class="comment">// parent5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person5.<span class="title function_">getFriends</span>()); <span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;]</span></span><br></pre></td></tr></table></figure><p>其优缺点也很明显，跟上面讲的原型式继承一样</p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>寄生组合式继承，借助解决普通对象的继承问题的<code> Object.create</code> 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span> (parent, child) &#123;</span><br><span class="line">    <span class="comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span></span><br><span class="line">    child.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    child.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent6</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent6&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent6</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child6</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Parent6</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = <span class="string">&#x27;child5&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">clone</span>(<span class="title class_">Parent6</span>, <span class="title class_">Child6</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child6</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getFriends</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">friends</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person6 = <span class="keyword">new</span> <span class="title class_">Child6</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person6); <span class="comment">//&#123;friends:&quot;child5&quot;,name:&quot;child5&quot;,play:[1,2,3],__proto__:Parent6&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person6.<span class="title function_">getName</span>()); <span class="comment">// parent6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person6.<span class="title function_">getFriends</span>()); <span class="comment">// child5</span></span><br></pre></td></tr></table></figure><p>可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题</p><p>文章一开头，我们是使用<code>ES6</code> 中的<code>extends </code>关键字直接实现 <code>JavaScript </code>的继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 原型方法</span></span><br><span class="line">  <span class="comment">// 即 Person.prototype.getName = function() &#123; &#125;</span></span><br><span class="line">  <span class="comment">// 下面可以简写为 getName() &#123;...&#125;</span></span><br><span class="line">  getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gamer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> asuna = <span class="keyword">new</span> <span class="title class_">Gamer</span>(<span class="string">&#x27;Asuna&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">asuna.<span class="title function_">getName</span>() <span class="comment">// 成功访问到父类的方法</span></span><br></pre></td></tr></table></figure><p>利用<code>babel</code>工具进行转换，我们会发现<code>extends</code>实际采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>下面以一张图作为总结：</p><p> <img src="https://static.vue-js.com/0df74700-731c-11eb-ab90-d9ae814b240d.png"></p><p>通过<code>Object.create</code> 来划分不同的继承方式，最后的寄生式组合继承方式是通过组合继承改造之后的最优继承方式，而 <code>extends</code> 的语法糖和寄生组合继承的方式基本类似</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF">https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_inherit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型，原型链 ? 有什么特点？</title>
      <link href="/2019/11/11/js-prototype/"/>
      <url>/2019/11/11/js-prototype/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript原型，原型链-有什么特点？"><a href="#JavaScript原型，原型链-有什么特点？" class="headerlink" title="JavaScript原型，原型链 ? 有什么特点？"></a>JavaScript原型，原型链 ? 有什么特点？</h1><h2 id="一、原型"><a href="#一、原型" class="headerlink" title="一、原型"></a>一、原型</h2><p><code>JavaScript</code> 常被描述为一种基于原型的语言——每个对象拥有一个原型对象</p><p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p><p>准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的<code>prototype</code>属性上，而非实例对象本身</p><p>下面举个例子：</p><p>函数可以有属性。 每个函数都有一个特殊的属性叫作原型<code>prototype</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( doSomething.<span class="property"><span class="keyword">prototype</span></span> );</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">constructor</span>: ƒ <span class="title function_">doSomething</span>(),</span><br><span class="line">    <span class="attr">__proto__</span>: &#123;</span><br><span class="line">        <span class="attr">constructor</span>: ƒ <span class="title class_">Object</span>(),</span><br><span class="line">        <span class="attr">hasOwnProperty</span>: ƒ <span class="title function_">hasOwnProperty</span>(),</span><br><span class="line">        <span class="attr">isPrototypeOf</span>: ƒ <span class="title function_">isPrototypeOf</span>(),</span><br><span class="line">        <span class="attr">propertyIsEnumerable</span>: ƒ <span class="title function_">propertyIsEnumerable</span>(),</span><br><span class="line">        <span class="attr">toLocaleString</span>: ƒ <span class="title function_">toLocaleString</span>(),</span><br><span class="line">        <span class="attr">toString</span>: ƒ <span class="title function_">toString</span>(),</span><br><span class="line">        <span class="attr">valueOf</span>: ƒ <span class="title function_">valueOf</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个对象，就是大家常说的原型对象</p><p>可以看到，原型对象有一个自有属性<code>constructor</code>，这个属性指向该函数，如下图关系展示</p><p> <img src="https://static.vue-js.com/56d87250-725e-11eb-ab90-d9ae814b240d.png"></p><h2 id="二、原型链"><a href="#二、原型链" class="headerlink" title="二、原型链"></a>二、原型链</h2><p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法</p><p>在对象实例和它的构造器之间建立一个链接（它是<code>__proto__</code>属性，是从构造函数的<code>prototype</code>属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法</p><p>下面举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二步 创建实例</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person&#x27;</span>)</span><br></pre></td></tr></table></figure><p>根据代码，我们可以得到下图</p><p> <img src="https://static.vue-js.com/60825aa0-725e-11eb-85f6-6fac77c0c9b3.png"></p><p>下面分析一下：</p><ul><li><p>构造函数<code>Person</code>存在原型对象<code>Person.prototype</code></p></li><li><p>构造函数生成实例对象<code>person</code>，<code>person</code>的<code>__proto__</code>指向构造函数<code>Person</code>原型对象</p></li><li><p><code>Person.prototype.__proto__</code> 指向内置对象，因为 <code>Person.prototype</code> 是个对象，默认是由 <code>Object </code>函数作为类创建的，而 <code>Object.prototype</code> 为内置对象</p></li><li><p><code>Person.__proto__</code> 指向内置匿名函数 <code>anonymous</code>，因为 Person 是个函数对象，默认由 Function 作为类创建</p></li><li><p><code>Function.prototype</code> 和 <code>Function.__proto__ </code>同时指向内置匿名函数 <code>anonymous</code>，这样原型链的终点就是 <code>null</code></p></li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>下面首先要看几个概念：</p><p><code>__proto__</code>作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的</p><p> <img src="https://static.vue-js.com/6a742160-725e-11eb-ab90-d9ae814b240d.png"></p><p>每个对象的<code>__proto__</code>都是指向它的构造函数的原型对象<code>prototype</code>的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure><p>构造函数是一个函数对象，是通过 <code>Function </code>构造器产生的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure><p>原型对象本身是一个普通对象，而普通对象的构造函数都是<code>Object</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure><p>刚刚上面说了，所有的构造器都是函数对象，函数对象都是 <code>Function </code>构造产生的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure><p><code>Object </code>的原型对象也有<code>__proto__</code>属性指向<code>null</code>，<code>null</code>是原型链的顶端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>下面作出总结：</p><ul><li><p>一切对象都是继承自<code>Object</code>对象，<code>Object</code> 对象直接继承根源对象<code> null</code></p></li><li><p>一切的函数对象（包括 <code>Object</code> 对象），都是继承自 <code>Function</code> 对象</p></li><li><p><code>Object</code> 对象直接继承自 <code>Function</code> 对象</p></li><li><p><code>Function</code>对象的<code>__proto__</code>会指向自己的原型对象，最终还是继承自<code>Object</code>对象</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6870732239556640775#heading-7">https://juejin.cn/post/6870732239556640775#heading-7</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_prototype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>举例说明你对尾递归的理解，有哪些应用场景</title>
      <link href="/2019/11/10/js-tail-recursion/"/>
      <url>/2019/11/10/js-tail-recursion/</url>
      
        <content type="html"><![CDATA[<h1 id="举例说明你对尾递归的理解，有哪些应用场景"><a href="#举例说明你对尾递归的理解，有哪些应用场景" class="headerlink" title="举例说明你对尾递归的理解，有哪些应用场景"></a>举例说明你对尾递归的理解，有哪些应用场景</h1><h2 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h2><p>递归（英语：Recursion）</p><p>在数学与计算机科学中，是指在函数的定义中使用函数自身的方法</p><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数</p><p>其核心思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解</p><p>一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回</p><p>下面实现一个函数 <code>pow(x, n)</code>，它可以计算 <code>x</code> 的 <code>n</code> 次方</p><p>使用迭代的方式，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pow</span>(<span class="params">x, n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再循环中，用 x 乘以 result n 次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result *= x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递归的方式，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pow</span>(<span class="params">x, n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="title function_">pow</span>(x, n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pow(x, n)</code> 被调用时，执行分为两个分支：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             <span class="keyword">if</span> n==<span class="number">1</span>  = x</span><br><span class="line">             /</span><br><span class="line"><span class="title function_">pow</span>(x, n) =</span><br><span class="line">             \</span><br><span class="line">              <span class="keyword">else</span>     = x * <span class="title function_">pow</span>(x, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>也就是说<code>pow</code> 递归地调用自身 直到 <code>n == 1</code></p><p> <img src="https://static.vue-js.com/8002c960-815d-11eb-ab90-d9ae814b240d.png"></p><p>为了计算 <code>pow(2, 4)</code>，递归变体经过了下面几个步骤：</p><ol><li><code>pow(2, 4) = 2 * pow(2, 3)</code></li><li><code>pow(2, 3) = 2 * pow(2, 2)</code></li><li><code>pow(2, 2) = 2 * pow(2, 1)</code></li><li><code>pow(2, 1) = 2</code></li></ol><p>因此，递归将函数调用简化为一个更简单的函数调用，然后再将其简化为一个更简单的函数，以此类推，直到结果</p><h2 id="二、尾递归"><a href="#二、尾递归" class="headerlink" title="二、尾递归"></a>二、尾递归</h2><p>尾递归，即在函数尾位置调用自身（或是一个尾调用本身的其他函数等等）。尾递归也是递归的一种特殊情形。尾递归是一种特殊的尾调用，即在尾部直接调用自身的递归函数</p><p>尾递归在普通尾调用的基础上，多出了2个特征：</p><ul><li>在尾部调用的是函数自身</li><li>可通过优化，使得计算仅占用常量栈空间</li></ul><p>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢出</p><p>这时候，我们就可以使用尾递归，即一个函数中所有递归形式的调用都出现在函数的末尾，对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误</p><p>实现一下阶乘，如果用普通的递归，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="title function_">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>如果<code>n</code>等于5，这个方法要执行5次，才返回最终的计算表达式，这样每次都要保存这个方法，就容易造成栈溢出，复杂度为<code>O(n)</code></p><p>如果我们使用尾递归，则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>可以看到，每一次返回的就是一个新的函数，不带上一个函数的参数，也就不需要储存上一个函数了。尾递归只需要保存一个调用栈，复杂度 O(1)</p><h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2><p>数组求和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumArray</span>(<span class="params">arr, total</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">sum</span>(arr, total + arr.<span class="title function_">pop</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用尾递归优化求斐波那契数列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial2</span> (n, start = <span class="number">1</span>, total = <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> factorial2 (n -<span class="number">1</span>, total, total + start)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组扁平化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]]</span><br><span class="line"><span class="comment">// 变成</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 具体实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr = [], result = []</span>) &#123;</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(v)) &#123;</span><br><span class="line">            result = result.<span class="title function_">concat</span>(<span class="title function_">flat</span>(v, []))</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组对象格式化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">c</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">        <span class="attr">D</span>: &#123;</span><br><span class="line">            <span class="attr">E</span>: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转化为如下：</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">c</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">        <span class="attr">d</span>: &#123;</span><br><span class="line">            <span class="attr">e</span>: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">keysLower</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;([A-Z]+)&quot;</span>, <span class="string">&quot;g&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = obj[key];</span><br><span class="line">            <span class="keyword">if</span> (reg.<span class="title function_">test</span>(key.<span class="title function_">toString</span>())) &#123;</span><br><span class="line">                <span class="comment">// 将修改后的属性名重新赋值给temp，并在对象obj内添加一个转换后的属性</span></span><br><span class="line">                temp = obj[key.<span class="title function_">replace</span>(reg, <span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result.<span class="title function_">toLowerCase</span>()</span><br><span class="line">                &#125;)] = obj[key];</span><br><span class="line">                <span class="comment">// 将之前大写的键属性删除</span></span><br><span class="line">                <span class="keyword">delete</span> obj[key];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果属性是对象或者数组，重新执行函数</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> temp === <span class="string">&#x27;object&#x27;</span> || <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(temp) === <span class="string">&#x27;[object Array]&#x27;</span>) &#123;</span><br><span class="line">                <span class="title function_">keysLower</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8">https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_tail_recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说你对函数式编程的理解？优缺点？</title>
      <link href="/2019/11/06/js-functional-programming/"/>
      <url>/2019/11/06/js-functional-programming/</url>
      
        <content type="html"><![CDATA[<h1 id="说说你对函数式编程的理解？优缺点？"><a href="#说说你对函数式编程的理解？优缺点？" class="headerlink" title="说说你对函数式编程的理解？优缺点？"></a>说说你对函数式编程的理解？优缺点？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>函数式编程是一种”编程范式”（programming paradigm），一种编写程序的方法论</p><p>主要的编程范式有三种：命令式编程，声明式编程和函数式编程</p><p>相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程</p><p>举个例子，将数组每个元素进行平方操作，命令式编程与函数式编程如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式编程</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    array[i] = <span class="title class_">Math</span>.<span class="title function_">pow</span>(array[i], <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式方式</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(num, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果</p><p>即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值</p><p> <img src="https://static.vue-js.com/f9f83900-8534-11eb-85f6-6fac77c0c9b3.png"></p><p>可以看到，函数实际上是一个关系，或者说是一种映射，而这种映射关系是可以组合的，一旦我们知道一个函数的输出类型可以匹配另一个函数的输入，那他们就可以进行组合</p><h2 id="二、概念"><a href="#二、概念" class="headerlink" title="二、概念"></a>二、概念</h2><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>函数式编程旨在尽可能的提高代码的无状态性和不变性。要做到这一点，就要学会使用无副作用的函数，也就是纯函数</p><p>纯函数是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不可变的，即纯函数&#x3D;无状态+数据不可变</p><p> <img src="https://static.vue-js.com/04f50720-8535-11eb-ab90-d9ae814b240d.png"></p><p>举一个简单的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">double</span> = value=&gt;value*<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>特性：</p><ul><li>函数内部传入指定的值，就会返回确定唯一的值</li><li>不会造成超出作用域的变化，例如修改全局变量或引用传递的参数</li></ul><p>优势：</p><ul><li>使用纯函数，我们可以产生可测试的代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;double(2) 等于 4&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">expect</span>(<span class="title function_">double</span>(<span class="number">2</span>)).<span class="title function_">toBe</span>(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>不依赖外部环境计算，不会产生副作用，提高函数的复用性</p></li><li><p>可读性更强 ，函数不管是否是纯函数  都会有一个语义化的名称，更便于阅读</p></li><li><p>可以组装成复杂任务的可能性。符合模块化概念及单一职责原则</p></li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>在我们的编程世界中，我们需要处理的其实也只有“数据”和“关系”，而关系就是函数</p><p>编程工作也就是在找一种映射关系，一旦关系找到了，问题就解决了，剩下的事情，就是让数据流过这种关系，然后转换成另一个数据，如下图所示</p><p> <img src="https://static.vue-js.com/104af1c0-8535-11eb-ab90-d9ae814b240d.png"></p><p>在这里，就是高阶函数的作用。高级函数，就是以函数作为输入或者输出的函数被称为高阶函数</p><p>通过高阶函数抽象过程，注重结果，如下面例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forEach = <span class="keyword">function</span>(<span class="params">arr,fn</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="title function_">fn</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">forEach</span>(arr,<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面通过高阶函数 <code>forEach</code>来抽象循环如何做的逻辑，直接关注做了什么</p><p>高阶函数存在缓存的特性，主要是利用闭包作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">once</span> = (<span class="params">fn</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!done)&#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,fn);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;该函数已经执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程</p><p>一个二元函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params">x,y</span>)=&gt;x+y;</span><br></pre></td></tr></table></figure><p>转化成柯里化函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fn</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myfn = <span class="title function_">curry</span>(fn);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">myfn</span>(<span class="number">1</span>)(<span class="number">2</span>) );</span><br></pre></td></tr></table></figure><p>上面的<code>curry</code>函数只能处理二元情况，下面再来实现一个实现多参数的情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多参数柯里化；</span></span><br><span class="line"><span class="keyword">const</span> curry = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curriedFn</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.<span class="property">length</span>&lt;fn.<span class="property">length</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">curriedFn</span>(...args.<span class="title function_">concat</span>([...<span class="variable language_">arguments</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">x,y,z,a</span>)=&gt;x+y+z+a;</span><br><span class="line"><span class="keyword">const</span> myfn = <span class="title function_">curry</span>(fn);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myfn</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>关于柯里化函数的意义如下：</p><ul><li>让纯函数更纯，每次接受一个参数，松散解耦</li><li>惰性执行</li></ul><h3 id="组合与管道"><a href="#组合与管道" class="headerlink" title="组合与管道"></a>组合与管道</h3><p>组合函数，目的是将多个函数组合成一个函数</p><p>举个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">afn</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bfn</span>(<span class="params">b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> b*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">a,b</span>)=&gt;<span class="function"><span class="params">c</span>=&gt;</span><span class="title function_">a</span>(<span class="title function_">b</span>(c));</span><br><span class="line"><span class="keyword">let</span> myfn =  <span class="title function_">compose</span>(afn,bfn);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">myfn</span>(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>可以看到<code>compose</code>实现一个简单的功能：形成了一个新的函数，而这个函数就是一条从 <code>bfn -&gt; afn</code> 的流水线</p><p>下面再来看看如何实现一个多函数组合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">...fns</span>)=&gt;<span class="function"><span class="params">val</span>=&gt;</span>fns.<span class="title function_">reverse</span>().<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc,fn</span>)=&gt;</span><span class="title function_">fn</span>(acc),val);</span><br></pre></td></tr></table></figure><p><code>compose</code>执行是从右到左的。而管道函数，执行顺序是从左到右执行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">pipe</span> = (<span class="params">...fns</span>)=&gt;<span class="function"><span class="params">val</span>=&gt;</span>fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc,fn</span>)=&gt;</span><span class="title function_">fn</span>(acc),val);</span><br></pre></td></tr></table></figure><p>组合函数与管道函数的意义在于：可以把很多小函数组合起来完成更复杂的逻辑</p><h2 id="三、优缺点"><a href="#三、优缺点" class="headerlink" title="三、优缺点"></a>三、优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况</p></li><li><p>更简单的复用：固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响</p></li><li><p>更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性</p></li><li><p>隐性好处。减少代码量，提高维护性</p></li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><p>性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销</p></li><li><p>资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式</p></li><li><p>递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/81302150">https://zhuanlan.zhihu.com/p/81302150</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_functional_programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈this对象的理解</title>
      <link href="/2019/11/01/js-this/"/>
      <url>/2019/11/01/js-this/</url>
      
        <content type="html"><![CDATA[<h1 id="谈谈this对象的理解"><a href="#谈谈this对象的理解" class="headerlink" title="谈谈this对象的理解"></a>谈谈this对象的理解</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>函数的 <code>this</code> 关键字在 <code>JavaScript</code> 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别</p><p>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值（运行时绑定）</p><p><code>this</code> 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置是全局作用域</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;baz&quot;</span> );</span><br><span class="line">    <span class="title function_">bar</span>(); <span class="comment">// &lt;-- bar的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz --&gt; bar</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在baz中</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;bar&quot;</span> );</span><br><span class="line">    <span class="title function_">foo</span>(); <span class="comment">// &lt;-- foo的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz --&gt; bar --&gt; foo</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在bar中</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;foo&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">baz</span>(); <span class="comment">// &lt;-- baz的调用位置</span></span><br></pre></td></tr></table></figure><p>同时，<code>this</code>在函数执行过程中，<code>this</code>一旦被确定了，就不可以再更改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span> = obj; <span class="comment">// 修改this，运行后会报错</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><h2 id="二、绑定规则"><a href="#二、绑定规则" class="headerlink" title="二、绑定规则"></a>二、绑定规则</h2><p>根据不同的使用场合，<code>this</code>有不同的值，主要分为下面几种情况：</p><ul><li><p>默认绑定</p></li><li><p>隐式绑定</p></li><li><p>new绑定</p></li><li><p>显示绑定</p></li></ul><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>全局环境中定义<code>person</code>函数，内部使用<code>this</code>关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jenny&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">person</span>());  <span class="comment">//Jenny</span></span><br></pre></td></tr></table></figure><p>上述代码输出<code>Jenny</code>，原因是调用函数的对象在游览器中位<code>window</code>，因此<code>this</code>指向<code>window</code>，所以输出<code>Jenny</code></p><p>注意：</p><p>严格模式下，不能将全局对象用于默认绑定，this会绑定到<code>undefined</code>，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象</p><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>函数还可以作为某个对象的方法调用，这时<code>this</code>就指这个上级对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">m</span> = test;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">m</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，<code>this</code>指向的也只是它上一级的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>:&#123;</span><br><span class="line">        <span class="attr">fn</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">//undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.<span class="property">b</span>.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p>上述代码中，<code>this</code>的上一级对象为<code>b</code>，<code>b</code>内部并没有<code>a</code>变量的定义，所以输出<code>undefined</code></p><p>这里再举一种特殊情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>:&#123;</span><br><span class="line">        <span class="attr">a</span>:<span class="number">12</span>,</span><br><span class="line">        <span class="attr">fn</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">//undefined</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//window</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = o.<span class="property">b</span>.<span class="property">fn</span>;</span><br><span class="line"><span class="title function_">j</span>();</span><br></pre></td></tr></table></figure><p>此时<code>this</code>指向的是<code>window</code>，这里的大家需要记住，<code>this</code>永远指向的是最后调用它的对象，虽然<code>fn</code>是对象<code>b</code>的方法，但是<code>fn</code>赋值给<code>j</code>时候并没有执行，所以最终指向<code>window</code></p><h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>通过构建函数<code>new</code>关键字生成一个实例对象，此时<code>this</code>指向这个实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">　<span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">test</span>();</span><br><span class="line">obj.<span class="property">x</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上述代码之所以能过输出1，是因为<code>new</code>关键字改变了<code>this</code>的指向</p><p>这里再列举一些特殊情况：</p><p><code>new</code>过程遇到<code>return</code>一个对象，此时<code>this</code>指向为返回的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">fn</span>();  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>如果返回一个简单类型的时候，则<code>this</code>指向实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//xxx</span></span><br></pre></td></tr></table></figure><p>注意的是<code>null</code>虽然也是对象，但是此时<code>new</code>仍然指向实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//xxx</span></span><br></pre></td></tr></table></figure><h3 id="显示修改"><a href="#显示修改" class="headerlink" title="显示修改"></a>显示修改</h3><p><code>apply()、call()、bind()</code>是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时<code>this</code>指的就是这第一个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">　<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">m</span> = test;</span><br><span class="line">obj.<span class="property">m</span>.<span class="title function_">apply</span>(obj) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>关于<code>apply、call、bind</code>三者的区别，我们后面再详细说</p><h2 id="三、箭头函数"><a href="#三、箭头函数" class="headerlink" title="三、箭头函数"></a>三、箭头函数</h2><p>在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 <code>this</code> 的指向（编译时绑定）</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">sayThis</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">sayThis</span>(); <span class="comment">// window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了</span></span><br><span class="line"><span class="keyword">const</span> globalSay = obj.<span class="property">sayThis</span>;</span><br><span class="line"><span class="title function_">globalSay</span>(); <span class="comment">// window 浏览器中的 global 对象</span></span><br></pre></td></tr></table></figure><p>虽然箭头函数的<code>this</code>能够在编译的时候就确定了<code>this</code>的指向，但也需要注意一些潜在的坑</p><p>下面举个例子：</p><p>绑定事件监听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mngb&#x27;</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;clicked button&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述可以看到，我们其实是想要<code>this</code>为点击的<code>button</code>，但此时<code>this</code>指向了<code>window</code></p><p>包括在原型上添加方法时候，此时<code>this</code>指向<code>window</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">//true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;mm&#x27;</span>);</span><br><span class="line">cat.<span class="title function_">sayName</span>()</span><br></pre></td></tr></table></figure><p>同样的，箭头函数不能作为构建函数</p><h2 id="四、优先级"><a href="#四、优先级" class="headerlink" title="四、优先级"></a>四、优先级</h2><h3 id="隐式绑定-VS-显式绑定"><a href="#隐式绑定-VS-显式绑定" class="headerlink" title="隐式绑定 VS 显式绑定"></a>隐式绑定 VS 显式绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br><span class="line">obj2.<span class="title function_">foo</span>(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>( obj2 ); <span class="comment">// 3</span></span><br><span class="line">obj2.<span class="property">foo</span>.<span class="title function_">call</span>( obj1 ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>显然，显示绑定的优先级更高</p><h3 id="new绑定-VS-隐式绑定"><a href="#new绑定-VS-隐式绑定" class="headerlink" title="new绑定 VS 隐式绑定"></a>new绑定 VS 隐式绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>( <span class="number">2</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>( obj2, <span class="number">3</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj2.<span class="property">a</span> ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.<span class="title function_">foo</span>( <span class="number">4</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( bar.<span class="property">a</span> ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>可以看到，new绑定的优先级<code>&gt;</code>隐式绑定</p><h3 id="new绑定-VS-显式绑定"><a href="#new绑定-VS-显式绑定" class="headerlink" title="new绑定 VS 显式绑定"></a><code>new</code>绑定 VS 显式绑定</h3><p>因为<code>new</code>和<code>apply、call</code>无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>( obj1 );</span><br><span class="line"><span class="title function_">bar</span>( <span class="number">2</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>( <span class="number">3</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( baz.<span class="property">a</span> ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><code>bar</code>被绑定到obj1上，但是<code>new bar(3)</code> 并没有像我们预计的那样把<code>obj1.a</code>修改为3。但是，<code>new</code>修改了绑定调用<code>bar()</code>中的<code>this</code></p><p>我们可认为<code>new</code>绑定优先级<code>&gt;</code>显式绑定</p><p>综上，new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说JavaScript中的事件模型</title>
      <link href="/2019/10/06/js-event-model/"/>
      <url>/2019/10/06/js-event-model/</url>
      
        <content type="html"><![CDATA[<h1 id="说说JavaScript中的事件模型"><a href="#说说JavaScript中的事件模型" class="headerlink" title="说说JavaScript中的事件模型"></a>说说JavaScript中的事件模型</h1><h2 id="一、事件与事件流"><a href="#一、事件与事件流" class="headerlink" title="一、事件与事件流"></a>一、事件与事件流</h2><p><code>javascript</code>中的事件，可以理解就是在<code>HTML</code>文档或者浏览器中发生的一种交互操作，使得网页具备互动性， 常见的有加载事件、鼠标事件、自定义事件等</p><p>由于<code>DOM</code>是一个树结构，如果在父子节点绑定事件时候，当触发子节点的时候，就存在一个顺序问题，这就涉及到了事件流的概念</p><p>事件流都会经历三个阶段：</p><ul><li>事件捕获阶段(capture phase)</li><li>处于目标阶段(target phase)</li><li>事件冒泡阶段(bubbling phase)</li></ul><p> <img src="https://static.vue-js.com/3e9a6450-74cf-11eb-85f6-6fac77c0c9b3.png"></p><p>事件冒泡是一种从下往上的传播方式，由最具体的元素（触发节点）然后逐渐向上传播到最不具体的那个节点，也就是<code>DOM</code>中最高层的父节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;clickMe&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，我们给<code>button</code>和它的父元素，加入点击事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;clickMe&#x27;</span>);</span><br><span class="line"></span><br><span class="line">button.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1.Button&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2.body&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3.document&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4.window&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>点击按钮，输出如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>button</span><br><span class="line"><span class="number">2.</span>body</span><br><span class="line"><span class="number">3.</span><span class="variable language_">document</span></span><br><span class="line"><span class="number">4.</span><span class="variable language_">window</span></span><br></pre></td></tr></table></figure><p>点击事件首先在<code>button</code>元素上发生，然后逐级向上传播</p><p>事件捕获与事件冒泡相反，事件最开始由不太具体的节点最早接受事件, 而最具体的节点（触发节点）最后接受事件</p><h2 id="二、事件模型"><a href="#二、事件模型" class="headerlink" title="二、事件模型"></a>二、事件模型</h2><p>事件模型可以分为三种：</p><ul><li>原始事件模型（DOM0级）</li><li>标准事件模型（DOM2级）</li><li>IE事件模型（基本不用）</li></ul><h3 id="原始事件模型"><a href="#原始事件模型" class="headerlink" title="原始事件模型"></a>原始事件模型</h3><p>事件绑定监听函数比较简单, 有两种方式：</p><ul><li>HTML代码中直接绑定</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;fun()&quot;</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>通过<code>JS</code>代码绑定</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = fun;</span><br></pre></td></tr></table></figure><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>绑定速度快</li></ul><p><code>DOM0</code>级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行</p><ul><li><p>只支持冒泡，不支持捕获</p></li><li><p>同一个类型的事件只能绑定一次</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn&quot;</span> onclick=<span class="string">&quot;fun1()&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = fun2;</span><br></pre></td></tr></table></figure><p>如上，当希望为同一个元素绑定多个同类型事件的时候（上面的这个<code>btn</code>元素绑定2个点击事件），是不被允许的，后绑定的事件会覆盖之前的事件</p><p>删除 <code>DOM0</code> 级事件处理程序只要将对应事件属性置为<code>null</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="标准事件模型"><a href="#标准事件模型" class="headerlink" title="标准事件模型"></a>标准事件模型</h3><p>在该事件模型中，一次事件共有三个过程:</p><ul><li>事件捕获阶段：事件从<code>document</code>一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li><li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数</li><li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li></ul><p>事件绑定监听函数的方式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure><p>事件移除监听函数的方式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeEventListener(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure><p>参数如下：</p><ul><li><code>eventType</code>指定事件类型(不要加on)</li><li><code>handler</code>是事件处理函数</li><li><code>useCapture</code>是一个<code>boolean</code>用于指定是否在捕获阶段进行处理，一般设置为<code>false</code>与IE浏览器保持一致</li></ul><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(‘click’, showMessage, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ul><li>可以在一个<code>DOM</code>元素上绑定多个事件处理器，各自并不会冲突</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage1, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage2, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage3, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li>执行时机</li></ul><p>当第三个参数(<code>useCapture</code>)设置为<code>true</code>就在捕获过程中执行，反之在冒泡过程中执行处理函数</p><p>下面举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&#x27;div&#x27;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;p&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&#x27;span&#x27;</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &lt;/p &gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>设置点击事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onClickFn</span> (event) &#123;</span><br><span class="line">    <span class="keyword">var</span> tagName = event.<span class="property">currentTarget</span>.<span class="property">tagName</span>;</span><br><span class="line">    <span class="keyword">var</span> phase = event.<span class="property">eventPhase</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(tagName, phase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">false</span>);</span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>上述使用了<code>eventPhase</code>，返回一个代表当前执行阶段的整数值。1为捕获阶段、2为事件对象触发阶段、3为冒泡阶段</p><p>点击<code>Click Me!</code>，输出如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P <span class="number">3</span></span><br><span class="line"><span class="variable constant_">DIV</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>p</code>和<code>div</code>都是在冒泡阶段响应了事件，由于冒泡的特性，裹在里层的<code>p</code>率先做出响应</p><p>如果把第三个参数都改为<code>true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">true</span>);</span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DIV</span> <span class="number">1</span></span><br><span class="line">P <span class="number">1</span></span><br></pre></td></tr></table></figure><p>两者都是在捕获阶段响应事件，所以<code>div</code>比<code>p</code>标签先做出响应</p><h3 id="IE事件模型"><a href="#IE事件模型" class="headerlink" title="IE事件模型"></a>IE事件模型</h3><p>IE事件模型共有两个过程:</p><ul><li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。</li><li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li></ul><p>事件绑定监听函数的方式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attachEvent(eventType, handler)</span><br></pre></td></tr></table></figure><p>事件移除监听函数的方式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">detachEvent(eventType, handler)</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">attachEvent</span>(‘onclick’, showMessage);</span><br><span class="line">btn.<span class="title function_">detachEvent</span>(‘onclick’, showMessage);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_event_model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说 Javascript 数字精度丢失的问题，如何解决？</title>
      <link href="/2019/09/11/js-loss-accuracy/"/>
      <url>/2019/09/11/js-loss-accuracy/</url>
      
        <content type="html"><![CDATA[<h1 id="说说-Javascript-数字精度丢失的问题，如何解决？"><a href="#说说-Javascript-数字精度丢失的问题，如何解决？" class="headerlink" title="说说 Javascript 数字精度丢失的问题，如何解决？"></a>说说 Javascript 数字精度丢失的问题，如何解决？</h1><h2 id="一、场景复现"><a href="#一、场景复现" class="headerlink" title="一、场景复现"></a>一、场景复现</h2><p>一个经典的面试题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>为什么是<code>false</code>呢?</p><p>先看下面这个比喻</p><p>比如一个数 1÷3&#x3D;0.33333333…… </p><p>3会一直无限循环，数学可以表示，但是计算机要存储，方便下次取出来再使用，但0.333333…… 这个数无限循环，再大的内存它也存不下，所以不能存储一个相对于数学来说的值，只能存储一个近似值，当计算机存储后再取出时就会出现精度丢失问题</p><h2 id="二、浮点数"><a href="#二、浮点数" class="headerlink" title="二、浮点数"></a>二、浮点数</h2><p>“浮点数”是一种表示数字的标准，整数也可以用浮点数的格式来存储</p><p>我们也可以理解成，浮点数就是小数</p><p>在<code>JavaScript</code>中，现在主流的数值类型是<code>Number</code>，而<code>Number</code>采用的是<code>IEEE754</code>规范中64位双精度浮点数编码</p><p>这样的存储结构优点是可以归一化处理整数和小数，节省存储空间</p><p>对于一个整数，可以很轻易转化成十进制或者二进制。但是对于一个浮点数来说，因为小数点的存在，小数点的位置不是固定的。解决思路就是使用科学计数法，这样小数点位置就固定了</p><p>而计算机只能用二进制（0或1）表示，二进制转换为科学记数法的公式如下：</p><p> <img src="https://static.vue-js.com/1b4b1620-86f4-11eb-ab90-d9ae814b240d.png"></p><p>其中，<code>a</code>的值为0或者1，e为小数点移动的位置</p><p>举个例子：</p><p>27.0转化成二进制为11011.0 ，科学计数法表示为：</p><p> <img src="https://static.vue-js.com/37007090-86f4-11eb-ab90-d9ae814b240d.png"></p><p>前面讲到，<code>javaScript</code>存储方式是双精度浮点数，其长度为8个字节，即64位比特</p><p>64位比特又可分为三个部分：</p><ul><li>符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数</li><li>指数位E：中间的 11 位存储指数（exponent），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为1023</li><li>尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零</li></ul><p>如下图所示：</p><p> <img src="https://static.vue-js.com/430d0100-86f4-11eb-85f6-6fac77c0c9b3.png"></p><p>举个例子：</p><p>27.5 转换为二进制11011.1</p><p>11011.1转换为科学记数法 <img src="https://www.zhihu.com/equation?tex=1.10111*2%5E4" alt="[公式]"></p><p>符号位为1(正数)，指数位为4+，1023+4，即1027</p><p>因为它是十进制的需要转换为二进制，即 <code>10000000011</code>，小数部分为<code>10111</code>，补够52位即： 1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000&#96;</p><p>所以27.5存储为计算机的二进制标准形式（符号位+指数位+小数部分 (阶数)），既下面所示</p><p>0+10000000011+011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000&#96;</p><h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><p>再回到问题上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>通过上面的学习，我们知道，在<code>javascript</code>语言中，0.1 和 0.2 都转化成二进制后再进行运算</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.1 和 0.2 都转化成二进制后再进行运算</span></span><br><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011010</span> +</span><br><span class="line"><span class="number">0.0011001100110011001100110011001100110011001100110011010</span> =</span><br><span class="line"><span class="number">0.0100110011001100110011001100110011001100110011001100111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转成十进制正好是 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>所以输出<code>false</code></p><p>再来一个问题，那么为什么<code>x=0.1</code>得到<code>0.1</code>？</p><p>主要是存储二进制时小数点的偏移量最大为52位，最多可以表达的位数是<code>2^53=9007199254740992</code>，对应科学计数尾数是 <code>9.007199254740992</code>，这也是 JS 最多能表示的精度</p><p>它的长度是 16，所以可以使用 <code>toPrecision(16)</code> 来做精度运算，超过的精度会自动做凑整处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">.10000000000000000555</span>.<span class="title function_">toPrecision</span>(<span class="number">16</span>)</span><br><span class="line"><span class="comment">// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1</span></span><br></pre></td></tr></table></figure><p>但看到的 <code>0.1</code> 实际上并不是 <code>0.1</code>。不信你可用更高的精度试试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span>.<span class="title function_">toPrecision</span>(<span class="number">21</span>) = <span class="number">0.100000000000000005551</span></span><br></pre></td></tr></table></figure><p>如果整数大于 <code>9007199254740992</code> 会出现什么情况呢？</p><p>由于指数位最大值是1023，所以最大可以表示的整数是 <code>2^1024 - 1</code>，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 <code>2^1024</code> 开始就变成了 <code>Infinity</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.pow(2, 1023)</span><br><span class="line">8.98846567431158e+307</span><br><span class="line"></span><br><span class="line">&gt; Math.pow(2, 1024)</span><br><span class="line">Infinity</span><br></pre></td></tr></table></figure><p>那么对于 <code>(2^53, 2^63)</code> 之间的数会出现什么情况呢？</p><ul><li><code>(2^53, 2^54)</code> 之间的数会两个选一个，只能精确表示偶数</li><li><code>(2^54, 2^55)</code> 之间的数会四个选一个，只能精确表示4个倍数</li><li>… 依次跳过更多2的倍数</li></ul><p>要想解决大数的问题你可以引用第三方库 <code>bignumber.js</code>，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生差很多</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，然后计算机以自己的规则{符号位+(指数位+指数偏移量的二进制)+小数部分}存储二进制的科学记数法</p><p>因为存储时有位数限制（64位），并且某些十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0舍1入)，当再转换为十进制时就造成了计算误差</p><h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><p>理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果</p><p>当你拿到 <code>1.4000000000000001</code> 这样的数据要展示时，建议使用 <code>toPrecision</code> 凑整并 <code>parseFloat</code> 转成数字后再显示，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True</span><br></pre></td></tr></table></figure><p>封装成方法就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strip</span>(<span class="params">num, precision = <span class="number">12</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="built_in">parseFloat</span>(num.<span class="title function_">toPrecision</span>(precision));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于运算类操作，如 <code>+-*/</code>，就不能使用 <code>toPrecision</code> 了。正确的做法是把小数转成整数后再运算。以加法为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 精确加法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> num1Digits = (num1.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span>).<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> num2Digits = (num2.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span>).<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> baseNum = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>, <span class="title class_">Math</span>.<span class="title function_">max</span>(num1Digits, num2Digits));</span><br><span class="line">  <span class="keyword">return</span> (num1 * baseNum + num2 * baseNum) / baseNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后还可以使用第三方库，如<code>Math.js</code>、<code>BigDecimal.js</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/100353781">https://zhuanlan.zhihu.com/p/100353781</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_loss_accuracy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解释下什么是事件代理？应用场景？</title>
      <link href="/2019/09/09/js-event-agent/"/>
      <url>/2019/09/09/js-event-agent/</url>
      
        <content type="html"><![CDATA[<h1 id="解释下什么是事件代理？应用场景？"><a href="#解释下什么是事件代理？应用场景？" class="headerlink" title="解释下什么是事件代理？应用场景？"></a>解释下什么是事件代理？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>事件代理，俗地来讲，就是把一个元素响应事件（<code>click</code>、<code>keydown</code>……）的函数委托到另一个元素</p><p>前面讲到，事件流的都会经过三个阶段： 捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段，而事件委托就是在冒泡阶段完成</p><p>事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素</p><p>当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数</p><p>下面举个例子：</p><p>比如一个宿舍的同学同时快递到了，一种笨方法就是他们一个个去领取</p><p>较优方法就是把这件事情委托给宿舍长，让一个人出去拿好所有快递，然后再根据收件人一一分发给每个同学</p><p>在这里，取快递就是一个事件，每个同学指的是需要响应事件的 <code>DOM </code>元素，而出去统一领取快递的宿舍长就是代理的元素</p><p>所以真正绑定事件的是这个元素，按照收件人分发快递的过程就是在事件执行中，需要判断当前响应的事件应该匹配到被代理元素中的哪一个或者哪几个</p><h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2><p>如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  ......</span><br><span class="line">  &lt;li&gt;item n&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素</span></span><br><span class="line"><span class="keyword">const</span> lis = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>)</span><br><span class="line"><span class="comment">// 循环遍历绑定事件</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lis.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    lis[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">innerHTML</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就可以事件委托，把点击事件绑定在父级元素<code>ul</code>上面，然后执行事件的时候再去匹配目标元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给父层元素绑定事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// 兼容性处理</span></span><br><span class="line">    <span class="keyword">var</span> event = e || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">    <span class="keyword">var</span> target = event.<span class="property">target</span> || event.<span class="property">srcElement</span>;</span><br><span class="line">    <span class="comment">// 判断是否匹配目标元素</span></span><br><span class="line">    <span class="keyword">if</span> (target.<span class="property">nodeName</span>.<span class="property">toLocaleLowerCase</span> === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;the content is: &#x27;</span>, target.<span class="property">innerHTML</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还有一种场景是上述列表项并不多，我们给每个列表项都绑定了事件</p><p>但是如果用户能够随时动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件</p><p>如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的</p><p>举个例子：</p><p>下面<code>html</code>结构中，点击<code>input</code>可以动态添加元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用事件委托</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> oUl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;ul1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> num = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件委托，添加的子元素也有事件</span></span><br><span class="line">oUl.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line">    ev = ev || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">    <span class="keyword">const</span> target = ev.<span class="property">target</span> || ev.<span class="property">srcElement</span>;</span><br><span class="line">    <span class="keyword">if</span> (target.<span class="property">nodeName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;the content is: &#x27;</span>, target.<span class="property">innerHTML</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加新节点</span></span><br><span class="line">oBtn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">const</span> oLi = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">    oLi.<span class="property">innerHTML</span> = <span class="string">`item <span class="subst">$&#123;num&#125;</span>`</span>;</span><br><span class="line">    oUl.<span class="title function_">appendChild</span>(oLi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，使用事件委托，在动态绑定事件的情况下是可以减少很多重复工作的</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>适合事件委托的事件有：<code>click</code>，<code>mousedown</code>，<code>mouseup</code>，<code>keydown</code>，<code>keyup</code>，<code>keypress</code></p><p>从上面应用场景中，我们就可以看到使用事件委托存在两大优点：</p><ul><li>减少整个页面所需的内存，提升整体性能</li><li>动态绑定，减少重复工作</li></ul><p>但是使用事件委托也是存在局限性：</p><ul><li><p><code>focus</code>、<code>blur </code>这些事件没有事件冒泡机制，所以无法进行委托绑定事件</p></li><li><p><code>mousemove</code>、<code>mouseout </code>这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的</p></li></ul><p>如果把所有事件都用事件代理，可能会出现事件误判，即本不该被触发的事件被绑定上了事件</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_event_agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的数据类型？存储上的差别？</title>
      <link href="/2019/09/02/js-data-type/"/>
      <url>/2019/09/02/js-data-type/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript中的数据类型？存储上的差别？"><a href="#JavaScript中的数据类型？存储上的差别？" class="headerlink" title="JavaScript中的数据类型？存储上的差别？"></a>JavaScript中的数据类型？存储上的差别？</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<code>JavaScript</code>中，我们可以分成两种类型：</p><ul><li>基本类型</li><li>复杂类型</li></ul><p>两种类型的区别是：存储位置不同</p><h2 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h2><p>基本类型主要为以下6种：</p><ul><li>Number</li><li>String</li><li>Boolean</li><li>Undefined</li><li>null</li><li>symbol</li></ul><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>数值最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span> <span class="comment">// 10进制的55</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">070</span> <span class="comment">// 8进制的56</span></span><br><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xA</span> <span class="comment">//16进制的10</span></span><br></pre></td></tr></table></figure><p>浮点类型则在数值汇总必须包含小数点，还可通过科学计数法表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum3 = <span class="number">.1</span>; <span class="comment">// 有效，但不推荐</span></span><br><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于 31250000</span></span><br></pre></td></tr></table></figure><p>在数值类型中，存在一个特殊数值<code>NaN</code>，意为“不是数值”，用于表示本来要返回数值的操作失败了（而不是抛出错误）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>/<span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span>/+<span class="number">0</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h3><p><code>Undefined</code> 类型只有一个值，就是特殊值 <code>undefined</code>。当使用 <code>var </code>或 <code>let </code>声明了变量但没有初始化时，就相当于给变量赋予了 <code>undefined </code>值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>包含<code> undefined</code> 值的变量跟未定义变量是有区别的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 没有声明过这个变量，报错</span></span><br></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串可以使用双引号（”）、单引号（’）或反引号（&#96;）标示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&#x27;Jacob&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">`Jingleheimerschmidt`</span></span><br></pre></td></tr></table></figure><p>字符串是不可变的，意思是一旦创建，它们的值就不能变了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;  <span class="comment">// 先销毁再创建</span></span><br></pre></td></tr></table></figure><h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><p><code>Null </code>类型同样只有一个值，即特殊值 <code>null</code></p><p>逻辑上讲， null 值表示一个空对象指针，这也是给<code>typeof </code>传一个 <code>null</code> 会返回 <code>&quot;object&quot;</code> 的原因</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> car); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p><code>undefined</code> 值是由 <code>null </code>值派生而来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>只要变量要保存对象，而当时又没有那个对象可保存，就可用 <code>null </code>来填充该变量</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p><code>Boolean </code>（布尔值）类型有两个字面值： <code>true</code> 和<code> false</code></p><p>通过<code>Boolean</code>可以将其他类型的数据转化成布尔值</p><p>规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据类型      转换为 <span class="literal">true</span> 的值      转换为 <span class="literal">false</span> 的值</span><br><span class="line"> <span class="title class_">String</span>         非空字符串          <span class="string">&quot;&quot;</span> </span><br><span class="line"> <span class="title class_">Number</span> 非零数值（包括无穷值）<span class="number">0</span> 、 <span class="title class_">NaN</span> </span><br><span class="line"> <span class="title class_">Object</span>  任意对象    <span class="literal">null</span></span><br><span class="line"><span class="title class_">Undefined</span> N/A （不存在） <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>Symbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> otherGenericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(genericSymbol == otherGenericSymbol); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooSymbol == otherFooSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="二、引用类型"><a href="#二、引用类型" class="headerlink" title="二、引用类型"></a>二、引用类型</h2><p>复杂类型统称为<code>Object</code>，我们这里主要讲述下面三种：</p><ul><li>Object</li><li>Array</li><li>Function</li></ul><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>创建<code>object</code>常用方式为对象字面量表示法，属性名可以是字符串或数值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p><code>JavaScript</code>数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。并且，数组也是动态大小的，会随着数据添加而自动增长</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="number">2</span>, &#123;<span class="attr">age</span>: <span class="number">20</span> &#125;]</span><br><span class="line">colors.<span class="title function_">push</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>函数实际上是对象，每个函数都是 <code>Function</code>类型的实例，而 <code>Function </code>也有属性和方法，跟其他引用类型一样</p><p>函数存在三种常见的表达方式：</p><ul><li>函数声明</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> (num1, num2) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数表达式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>箭头函数</li></ul><p>函数声明和函数表达式两种方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="其他引用类型"><a href="#其他引用类型" class="headerlink" title="其他引用类型"></a>其他引用类型</h3><p>除了上述说的三种之外，还包括<code>Date</code>、<code>RegExp</code>、<code>Map</code>、<code>Set</code>等……</p><h2 id="三、存储区别"><a href="#三、存储区别" class="headerlink" title="三、存储区别"></a>三、存储区别</h2><p>基本数据类型和引用数据类型存储在内存中的位置不同：</p><ul><li><p>基本数据类型存储在栈中</p></li><li><p>引用类型的对象存储于堆中</p></li></ul><p>当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值</p><p>下面来举个例子</p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = a; <span class="comment">// 赋值操作</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10值</span></span><br></pre></td></tr></table></figure><p><code>a</code>的值为一个基本类型，是存储在栈中，将<code>a</code>的值赋给<code>b</code>，虽然两个变量的值相等，但是两个变量保存了两个不同的内存地址</p><p>下图演示了基本类型赋值的过程：</p><p> <img src="https://static.vue-js.com/906ffb90-6463-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&quot;Xxx&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span>); <span class="comment">// xxx</span></span><br></pre></td></tr></table></figure><p>引用类型数据存放在堆中，每个堆内存对象都有对应的引用地址指向它，引用地址存放在栈中。</p><p><code>obj1</code>是一个引用类型，在赋值操作过程汇总，实际是将堆内存对象在栈内存的引用地址复制了一份给了<code>obj2</code>，实际上他们共同指向了同一个堆内存对象，所以更改<code>obj2</code>会对<code>obj1</code>产生影响</p><p>下图演示这个引用类型赋值过程</p><p> <img src="https://static.vue-js.com/a34bdd10-6463-11eb-ab90-d9ae814b240d.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>声明变量时不同的内存地址分配：<ul><li>简单类型的值存放在栈中，在栈中存放的是对应的值</li><li>引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址</li></ul></li><li>不同的类型数据导致赋值变量时的不同：<ul><li>简单类型赋值，是生成相同的值，两个对象对应不同的地址</li><li>复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_data_type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说你对事件循环的理解</title>
      <link href="/2019/08/06/js-event-loop/"/>
      <url>/2019/08/06/js-event-loop/</url>
      
        <content type="html"><![CDATA[<h1 id="说说你对事件循环的理解"><a href="#说说你对事件循环的理解" class="headerlink" title="说说你对事件循环的理解"></a>说说你对事件循环的理解</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>首先，<code>JavaScript </code>是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环</p><p>在<code>JavaScript</code>中，所有的任务都可以分为</p><ul><li><p>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</p></li><li><p>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout </code>定时函数等</p></li></ul><p>同步任务与异步任务的运行流程图如下：</p><p> <img src="https://static.vue-js.com/61efbc20-7cb8-11eb-85f6-6fac77c0c9b3.png"></p><p>从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环</p><h2 id="二、宏任务与微任务"><a href="#二、宏任务与微任务" class="headerlink" title="二、宏任务与微任务"></a>二、宏任务与微任务</h2><p>如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new Promise&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>如果按照上面流程图来分析代码，我们会得到下面的执行步骤：</p><ul><li><code>console.log(1) </code>，同步任务，主线程中执行</li><li><code>setTimeout()</code> ，异步任务，放到 <code>Event Table</code>，0 毫秒后<code>console.log(2) </code>回调推入 <code>Event Queue</code> 中</li><li><code>new Promise</code> ，同步任务，主线程直接执行</li><li><code>.then</code> ，异步任务，放到 <code>Event Table</code></li><li><code>console.log(3)</code>，同步任务，主线程执行</li></ul><p>所以按照分析，它的结果应该是 <code>1</code> &#x3D;&gt; <code>&#39;new Promise&#39;</code> &#x3D;&gt; <code>3</code> &#x3D;&gt; <code>2</code> &#x3D;&gt; <code>&#39;then&#39;</code></p><p>但是实际结果是：<code>1</code>&#x3D;&gt;<code>&#39;new Promise&#39;</code>&#x3D;&gt; <code>3</code> &#x3D;&gt; <code>&#39;then&#39;</code> &#x3D;&gt; <code>2</code></p><p>出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取</p><p>例子中 <code>setTimeout</code>回调事件是先进入队列中的，按理说应该先于 <code>.then</code> 中的执行，但是结果却偏偏相反</p><p>原因在于异步任务还可以细分为微任务与宏任务</p><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p><p>常见的微任务有：</p><ul><li><p>Promise.then</p></li><li><p>MutaionObserver</p></li><li><p>Object.observe（已废弃；Proxy 对象替代）</p></li><li><p>process.nextTick（Node.js）</p></li></ul><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p><p>常见的宏任务有：</p><ul><li>script (可以理解为外层同步代码) </li><li>setTimeout&#x2F;setInterval </li><li>UI rendering&#x2F;UI事件 </li><li>postMessage、MessageChannel </li><li>setImmediate、I&#x2F;O（Node.js）</li></ul><p>这时候，事件循环，宏任务，微任务的关系如图所示</p><p> <img src="https://static.vue-js.com/6e80e5e0-7cb8-11eb-85f6-6fac77c0c9b3.png"></p><p>按照这个流程，它的执行机制是：</p><ul><li>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中</li><li>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</li></ul><p>回到上面的题目</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new Promise&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>流程如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遇到 console.log(1) ，直接打印 1</span></span><br><span class="line"><span class="comment">// 遇到定时器，属于新的宏任务，留着后面执行</span></span><br><span class="line"><span class="comment">// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;</span></span><br><span class="line"><span class="comment">// .then 属于微任务，放入微任务队列，后面再执行</span></span><br><span class="line"><span class="comment">// 遇到 console.log(3) 直接打印 3</span></span><br><span class="line"><span class="comment">// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;</span></span><br><span class="line"><span class="comment">// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2</span></span><br></pre></td></tr></table></figure><h2 id="三、async与await"><a href="#三、async与await" class="headerlink" title="三、async与await"></a>三、async与await</h2><p><code>async</code> 是异步的意思，<code>await </code>则可以理解为 <code>async wait</code>。所以可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await </code>是用来等待异步方法执行</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p><code>async</code>函数返回一个<code>promise</code>对象，下面两种方法是等效的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;TEST&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// asyncF is equivalent to f!</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncF</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;TEST&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise </code>对象，返回该对象的结果。如果不是 <code>Promise </code>对象，就直接返回对应的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    <span class="comment">// return 123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn1</span> ()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fn2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>) <span class="comment">// 阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn2</span> ()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async </code>外面的同步代码，同步代码执行完，再回到 <code>async</code> 函数中，再执行之前阻塞的代码</p><p>所以上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p><h2 id="四、流程分析"><a href="#四、流程分析" class="headerlink" title="四、流程分析"></a>四、流程分析</h2><p>通过对上面的了解，我们对<code>JavaScript</code>对各种场景的执行顺序有了大致的了解</p><p>这里直接上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>分析过程：</p><ol><li>执行整段代码，遇到 <code>console.log(&#39;script start&#39;)</code> 直接打印结果，输出 <code>script start</code></li><li>遇到定时器了，它是宏任务，先放着不执行</li><li>遇到 <code>async1()</code>，执行 <code>async1</code> 函数，先打印 <code>async1 start</code>，下面遇到<code>await</code>怎么办？先执行 <code>async2</code>，打印 <code>async2</code>，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码</li><li>跳到 <code>new Promise</code> 这里，直接执行，打印 <code>promise1</code>，下面遇到 <code>.then()</code>，它是微任务，放到微任务列表等待执行</li><li>最后一行直接打印 <code>script end</code>，现在同步代码执行完了，开始执行微任务，即 <code>await </code>下面的代码，打印 <code>async1 end</code></li><li>继续执行下一个微任务，即执行 <code>then</code> 的回调，打印 <code>promise2</code></li><li>上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 <code>settimeout</code></li></ol><p>所以最后的结果是：<code>script start</code>、<code>async1 start</code>、<code>async2</code>、<code>promise1</code>、<code>script end</code>、<code>async1 end</code>、<code>promise2</code>、<code>settimeout</code></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_event_loop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现上拉加载，下拉刷新？</title>
      <link href="/2019/08/05/js-pull-up-loading-pull-down/"/>
      <url>/2019/08/05/js-pull-up-loading-pull-down/</url>
      
        <content type="html"><![CDATA[<h1 id="如何实现上拉加载，下拉刷新？"><a href="#如何实现上拉加载，下拉刷新？" class="headerlink" title="如何实现上拉加载，下拉刷新？"></a>如何实现上拉加载，下拉刷新？</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>下拉刷新和上拉加载这两种交互方式通常出现在移动端中</p><p>本质上等同于PC网页中的分页，只是交互形式不同</p><p>开源社区也有很多优秀的解决方案，如<code>iscroll</code>、<code>better-scroll</code>、<code>pulltorefresh.js</code>库等等</p><p>这些第三方库使用起来非常便捷</p><p>我们通过原生的方式实现一次上拉加载，下拉刷新，有助于对第三方库有更好的理解与使用</p><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><p>上拉加载及下拉刷新都依赖于用户交互</p><p>最重要的是要理解在什么场景，什么时机下触发交互动作</p><h3 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h3><p>首先可以看一张图</p><p> <img src="https://static.vue-js.com/df498a00-8ae3-11eb-ab90-d9ae814b240d.png"></p><p>上拉加载的本质是页面触底，或者快要触底时的动作</p><p>判断页面触底我们需要先了解一下下面几个属性</p><ul><li><p><code>scrollTop</code>：滚动视窗的高度距离<code>window</code>顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值</p></li><li><p><code>clientHeight</code>:它是一个定值，表示屏幕可视区域的高度；</p></li><li><p><code>scrollHeight</code>：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示<code>body</code>所有元素的总长度(包括body元素自身的padding)</p></li></ul><p>综上我们得出一个触底公式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrollTop + clientHeight &gt;= scrollHeight</span><br></pre></td></tr></table></figure><p>简单实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> clientHeight  = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>; <span class="comment">//浏览器高度</span></span><br><span class="line"><span class="keyword">let</span> scrollHeight = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span>;</span><br><span class="line"><span class="keyword">let</span> scrollTop = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> distance = <span class="number">50</span>;  <span class="comment">//距离视窗还用50的时候，开始触发；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始加载数据&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h3><p>下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作</p><p>关于下拉刷新的原生实现，主要分成三步：</p><ul><li>监听原生<code>touchstart</code>事件，记录其初始位置的值，<code>e.touches[0].pageY</code>；</li><li>监听原生<code>touchmove</code>事件，记录并计算当前滑动的位置值与初始位置值的差值，大于<code>0</code>表示向下拉动，并借助CSS3的<code>translateY</code>属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li><li>监听原生<code>touchend</code>事件，若此时元素滑动达到最大值，则触发<code>callback</code>，同时将<code>translateY</code>重设为<code>0</code>，元素回到初始位置</li></ul><p>举个例子：</p><p><code>Html</code>结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;main&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;refreshText&quot;</span>&gt;</span>&lt;/p &gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;refreshContainer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>444<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>555<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ...</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>监听<code>touchstart</code>事件，记录初始的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;refreshContainer&#x27;</span>),</span><br><span class="line">    _refreshText = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.refreshText&#x27;</span>),</span><br><span class="line">    _startPos = <span class="number">0</span>,  <span class="comment">// 初始的值</span></span><br><span class="line">    _transitionHeight = <span class="number">0</span>; <span class="comment">// 移动的距离</span></span><br><span class="line"></span><br><span class="line">_element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    _startPos = e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">pageY</span>; <span class="comment">// 记录初始位置</span></span><br><span class="line">    _element.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;relative&#x27;</span>;</span><br><span class="line">    _element.<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;transform 0s&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>监听<code>touchmove</code>移动事件，记录滑动差值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// e.touches[0].pageY 当前位置</span></span><br><span class="line">    _transitionHeight = e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">pageY</span> - _startPos; <span class="comment">// 记录差值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_transitionHeight &gt; <span class="number">0</span> &amp;&amp; _transitionHeight &lt; <span class="number">60</span>) &#123; </span><br><span class="line">        _refreshText.<span class="property">innerText</span> = <span class="string">&#x27;下拉刷新&#x27;</span>; </span><br><span class="line">        _element.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">&#x27;translateY(&#x27;</span>+_transitionHeight+<span class="string">&#x27;px)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_transitionHeight &gt; <span class="number">55</span>) &#123;</span><br><span class="line">            _refreshText.<span class="property">innerText</span> = <span class="string">&#x27;释放更新&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>最后，就是监听<code>touchend</code>离开的事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    _element.<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;transform 0.5s ease 1s&#x27;</span>;</span><br><span class="line">    _element.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">&#x27;translateY(0px)&#x27;</span>;</span><br><span class="line">    _refreshText.<span class="property">innerText</span> = <span class="string">&#x27;更新中...&#x27;</span>;</span><br><span class="line">    <span class="comment">// todo...</span></span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>从上面可以看到，在下拉到松手的过程中，经历了三个阶段：</p><ul><li>当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作</li><li>下拉到一定值时，显示松手释放后的操作提示</li><li>下拉到达设定最大值松手时，执行回调，提示正在进行更新操作</li></ul><h2 id="三、案例"><a href="#三、案例" class="headerlink" title="三、案例"></a>三、案例</h2><p>在实际开发中，我们更多的是使用第三方库，下面以<code>better-scroll</code>进行举例：</p><p>HTML结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;position-wrapper&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;refresh&quot;</span>&gt;</span>下拉刷新&lt;/p &gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;position-list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="comment">&lt;!--列表内容--&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;more&quot;</span>&gt;</span>查看更多&lt;/p &gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>实例化上拉下拉插件，通过<code>use</code>来注册插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">BScroll</span> <span class="keyword">from</span> <span class="string">&quot;@better-scroll/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PullDown</span> <span class="keyword">from</span> <span class="string">&quot;@better-scroll/pull-down&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PullUp</span> <span class="keyword">from</span> <span class="string">&#x27;@better-scroll/pull-up&#x27;</span>;</span><br><span class="line"><span class="title class_">BScroll</span>.<span class="title function_">use</span>(<span class="title class_">PullDown</span>);</span><br><span class="line"><span class="title class_">BScroll</span>.<span class="title function_">use</span>(<span class="title class_">PullUp</span>);</span><br></pre></td></tr></table></figure><p>实例化<code>BetterScroll</code>，并传入相关的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pageNo = <span class="number">1</span>,pageSize = <span class="number">10</span>,dataList = [],isMore = <span class="literal">true</span>;  </span><br><span class="line"><span class="keyword">var</span> scroll= <span class="keyword">new</span> <span class="title class_">BScroll</span>(<span class="string">&quot;#position-wrapper&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">scrollY</span>:<span class="literal">true</span>,<span class="comment">//垂直方向滚动</span></span><br><span class="line">    <span class="attr">click</span>:<span class="literal">true</span>,<span class="comment">//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true</span></span><br><span class="line">    <span class="attr">pullUpLoad</span>:<span class="literal">true</span>,<span class="comment">//上拉加载更多</span></span><br><span class="line">    <span class="attr">pullDownRefresh</span>:&#123;</span><br><span class="line">        <span class="attr">threshold</span>:<span class="number">50</span>,<span class="comment">//触发pullingDown事件的位置</span></span><br><span class="line">        <span class="attr">stop</span>:<span class="number">0</span><span class="comment">//下拉回弹后停留的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//监听下拉刷新</span></span><br><span class="line">scroll.<span class="title function_">on</span>(<span class="string">&quot;pullingDown&quot;</span>,pullingDownHandler);</span><br><span class="line"><span class="comment">//监测实时滚动</span></span><br><span class="line">scroll.<span class="title function_">on</span>(<span class="string">&quot;scroll&quot;</span>,scrollHandler);</span><br><span class="line"><span class="comment">//上拉加载更多</span></span><br><span class="line">scroll.<span class="title function_">on</span>(<span class="string">&quot;pullingUp&quot;</span>,pullingUpHandler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">pullingDownHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">    dataList=[];</span><br><span class="line">    pageNo=<span class="number">1</span>;</span><br><span class="line">    isMore=<span class="literal">true</span>;</span><br><span class="line">    $(<span class="string">&quot;.more&quot;</span>).<span class="title function_">text</span>(<span class="string">&quot;查看更多&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">getlist</span>();<span class="comment">//请求数据</span></span><br><span class="line">    scroll.<span class="title function_">finishPullDown</span>();<span class="comment">//每次下拉结束后，需要执行这个操作</span></span><br><span class="line">    scroll.<span class="title function_">refresh</span>();<span class="comment">//当滚动区域的dom结构有变化时，需要执行这个操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">pullingUpHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isMore)&#123;</span><br><span class="line">        $(<span class="string">&quot;.more&quot;</span>).<span class="title function_">text</span>(<span class="string">&quot;没有更多数据了&quot;</span>);</span><br><span class="line">        scroll.<span class="title function_">finishPullUp</span>();<span class="comment">//每次上拉结束后，需要执行这个操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pageNo++;</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getlist</span>();<span class="comment">//请求数据</span></span><br><span class="line">    scroll.<span class="title function_">finishPullUp</span>();<span class="comment">//每次上拉结束后，需要执行这个操作</span></span><br><span class="line">    scroll.<span class="title function_">refresh</span>();<span class="comment">//当滚动区域的dom结构有变化时，需要执行这个操作    </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scrollHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">y</span>&gt;<span class="number">50</span>) $(<span class="string">&#x27;.refresh&#x27;</span>).<span class="title function_">text</span>(<span class="string">&quot;松手开始加载&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> $(<span class="string">&#x27;.refresh&#x27;</span>).<span class="title function_">text</span>(<span class="string">&quot;下拉刷新&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getlist</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//返回的数据</span></span><br><span class="line">    <span class="keyword">let</span> result=....;</span><br><span class="line">    dataList=dataList.<span class="title function_">concat</span>(result);</span><br><span class="line">    <span class="comment">//判断是否已加载完</span></span><br><span class="line">    <span class="keyword">if</span>(result.<span class="property">length</span>&lt;pageSize) isMore=<span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//将dataList渲染到html内容中</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>注意点：</p><p>使用<code>better-scroll </code>实现下拉刷新、上拉加载时要注意以下几点：</p><ul><li><code>wrapper</code>里必须只有一个子元素</li><li>子元素的高度要比<code>wrapper</code>要高</li><li>使用的时候，要确定<code>DOM</code>元素是否已经生成，必须要等到<code>DOM</code>渲染完成后，再<code>new BScroll()</code></li><li>滚动区域的<code>DOM</code>元素结构有变化后，需要执行刷新 <code>refresh() </code></li><li>上拉或者下拉，结束后，需要执行<code>finishPullUp()</code>或者<code>finishPullDown()</code>，否则将不会执行下次操作</li><li><code>better-scroll</code>，默认会阻止浏览器的原生<code>click</code>事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置<code>click:true</code></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>下拉刷新、上拉加载原理本身都很简单，真正复杂的是封装过程中，要考虑的兼容性、易用性、性能等诸多细节</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000014423308">https://segmentfault.com/a/1190000014423308</a></li><li><a href="https://github.com/ustbhuangyi/better-scroll">https://github.com/ustbhuangyi/better-scroll</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_pull_up_loading_pull_down </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是防抖和节流？有什么区别？如何实现？</title>
      <link href="/2019/07/16/js-debounce-throttle/"/>
      <url>/2019/07/16/js-debounce-throttle/</url>
      
        <content type="html"><![CDATA[<h1 id="面试官：什么是防抖和节流？有什么区别？如何实现？"><a href="#面试官：什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="面试官：什么是防抖和节流？有什么区别？如何实现？"></a>面试官：什么是防抖和节流？有什么区别？如何实现？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>本质上是优化高频率执行代码的一种手段</p><p>如：浏览器的 <code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p><p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 <strong>防抖（debounce）</strong> 和 <strong>节流（throttle）</strong> 的方式来减少调用频率</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</li><li>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</li></ul><p>一个经典的比喻:</p><p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应</p><p>假设电梯有两种运行策略 <code>debounce</code> 和 <code>throttle</code>，超时设定为15秒，不考虑容量限制</p><p>电梯第一个人进来后，15秒后准时运送一次，这是节流</p><p>电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>完成节流可以使用时间戳与定时器的写法</p><p>使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled1</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> newtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        <span class="keyword">if</span> (newtime - oldtime &gt;= delay) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="literal">null</span>, args)</span><br><span class="line">            oldtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用定时器写法，<code>delay</code>毫秒后第一次执行，第二次事件停止触发后依然会再一次执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled2</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> starttime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">let</span> remaining = delay - (curTime - starttime)  <span class="comment">// 从上一次到现在，还剩下多少多余时间</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">            starttime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(fn, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>简单版本的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>; <span class="comment">// 保存this指向</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>; <span class="comment">// 拿到event对象</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait, immediate</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout); <span class="comment">// timeout 不为null</span></span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">let</span> callNow = !timeout; <span class="comment">// 第一次会立即执行，以后只有事件执行后才会再次触发</span></span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">                func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h2><p>相同点：</p><ul><li>都可以通过使用 <code>setTimeout</code> 实现</li><li>目的都是，降低回调执行频率。节省计算资源</li></ul><p>不同点：</p><ul><li>函数防抖，在一段连续操作结束后，处理回调，利用<code>clearTimeout </code>和 <code>setTimeout</code>实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能</li><li>函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次</li></ul><p>例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次</p><p>如下图所示：</p><p> <img src="https://static.vue-js.com/a2c81b50-8787-11eb-ab90-d9ae814b240d.png"></p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>防抖在连续的事件，只需触发一次回调的场景有：</p><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li><li>手机号、邮箱验证输入检测</li><li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li></ul><p>节流在间隔一段时间执行一次回调的场景有：</p><ul><li>滚动加载，加载更多或滚到底部监听</li><li>搜索框，搜索联想功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_debounce_throttle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM常见的操作有哪些？</title>
      <link href="/2019/07/07/js-dom/"/>
      <url>/2019/07/07/js-dom/</url>
      
        <content type="html"><![CDATA[<h1 id="DOM常见的操作有哪些？"><a href="#DOM常见的操作有哪些？" class="headerlink" title="DOM常见的操作有哪些？"></a>DOM常见的操作有哪些？</h1><h2 id="一、DOM"><a href="#一、DOM" class="headerlink" title="一、DOM"></a>一、DOM</h2><p>文档对象模型 (DOM) 是 <code>HTML</code> 和 <code>XML</code> 文档的编程接口</p><p>它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容</p><p>任何 <code>HTML </code>或<code>XML</code>文档都可以用 <code>DOM </code>表示为一个由节点构成的层级结构</p><p>节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>DOM</code>像原子包含着亚原子微粒那样，也有很多类型的<code>DOM</code>节点包含着其他类型的节点。接下来我们先看看其中的三种：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">title</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">        content</span><br><span class="line">    &lt;/p &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述结构中，<code>div</code>、<code>p</code>就是元素节点，<code>content</code>就是文本节点，<code>title</code>就是属性节点</p><h2 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h2><p>日常前端开发，我们都离不开<code>DOM</code>操作</p><p>在以前，我们使用<code>Jquery</code>，<code>zepto</code>等库来操作<code>DOM</code>，之后在<code>vue</code>，<code>Angular</code>，<code>React</code>等框架出现后，我们通过操作数据来控制<code>DOM</code>（绝大多数时候），越来越少的去直接操作<code>DOM</code></p><p>但这并不代表原生操作不重要。相反，<code>DOM</code>操作才能有助于我们理解框架深层的内容</p><p>下面就来分析<code>DOM</code>常见的操作，主要分为：</p><ul><li>创建节点</li><li>查询节点</li><li>更新节点</li><li>添加节点</li><li>删除节点</li></ul><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h4><p>创建新元素，接受一个参数，即要创建元素的标签名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divEl = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode"></a>createTextNode</h4><p>创建一个文本节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textEl = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;content&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="createDocumentFragment"><a href="#createDocumentFragment" class="headerlink" title="createDocumentFragment"></a>createDocumentFragment</h4><p>用来创建一个文档碎片，它表示一种轻量级的文档，主要是用来存储临时节点，然后把文档碎片的内容一次性添加到<code>DOM</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br></pre></td></tr></table></figure><p>当请求把一个<code>DocumentFragment</code> 节点插入文档树时，插入的不是 <code>DocumentFragment </code>自身，而是它的所有子孙节点</p><h4 id="createAttribute"><a href="#createAttribute" class="headerlink" title="createAttribute"></a>createAttribute</h4><p>创建属性节点，可以是自定义属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataAttribute = <span class="variable language_">document</span>.<span class="title function_">createAttribute</span>(<span class="string">&#x27;custom&#x27;</span>);</span><br><span class="line">consle.<span class="title function_">log</span>(dataAttribute);</span><br></pre></td></tr></table></figure><h3 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h3><h4 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h4><p>传入任何有效的<code> css</code> 选择器，即可选中单个 <code>DOM </code>元素（首个）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.element&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#element&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[name=&quot;username&quot;]&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div + p &gt; span&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果页面上没有指定的元素时，返回 <code>null</code></p><h4 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h4><p>返回一个包含节点子树内所有与之相匹配的<code>Element</code>节点列表，如果没有相匹配的，则返回一个空节点列表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> notLive = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是，该方法返回的是一个 <code>NodeList </code>的静态实例，它是一个静态的“快照”，而非“实时”的查询</p><p>关于获取<code>DOM</code>元素的方法还有如下，就不一一述说</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id属性值&#x27;</span>);返回拥有指定id的对象的引用</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;class属性值&#x27;</span>);返回拥有指定<span class="keyword">class</span>的对象集合</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;标签名&#x27;</span>);返回拥有指定标签名的对象集合</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;name属性值&#x27;</span>); 返回拥有指定名称的对象结合</span><br><span class="line"><span class="variable language_">document</span>/element.<span class="title function_">querySelector</span>(<span class="string">&#x27;CSS选择器&#x27;</span>);  仅返回第一个匹配的元素</span><br><span class="line"><span class="variable language_">document</span>/element.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;CSS选择器&#x27;</span>);   返回所有匹配的元素</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>;  获取页面中的<span class="variable constant_">HTML</span>标签</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>; 获取页面中的<span class="variable constant_">BODY</span>标签</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">all</span>[<span class="string">&#x27;&#x27;</span>];  获取页面中的所有元素节点的对象集合型</span><br></pre></td></tr></table></figure><p>除此之外，每个<code>DOM</code>元素还有<code>parentNode</code>、<code>childNodes</code>、<code>firstChild</code>、<code>lastChild</code>、<code>nextSibling</code>、<code>previousSibling</code>属性，关系图如下图所示</p><p> <img src="https://static.vue-js.com/c100f450-7fdc-11eb-ab90-d9ae814b240d.png"></p><h3 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h3><h4 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h4><p>不但可以修改一个<code>DOM</code>节点的文本内容，还可以直接通过<code>HTML</code>片段修改<code>DOM</code>节点内部的子树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p&quot;&gt;...&lt;/p &gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&#x27;ABC&#x27;</span>; <span class="comment">// &lt;p id=&quot;p&quot;&gt;ABC&lt;/p &gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;...&lt;/p &gt;的内部结构已修改</span></span><br></pre></td></tr></table></figure><h4 id="innerText、textContent"><a href="#innerText、textContent" class="headerlink" title="innerText、textContent"></a>innerText、textContent</h4><p>自动对字符串进行<code>HTML</code>编码，保证无法设置任何<code>HTML</code>标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p &gt;</span><br><span class="line">var p = document.getElementById(&#x27;p-id&#x27;);</span><br><span class="line">// 设置文本:</span><br><span class="line">p.innerText = &#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;;</span><br><span class="line">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span><br><span class="line">// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p &gt;</span><br></pre></td></tr></table></figure><p>两者的区别在于读取属性时，<code>innerText</code>不返回隐藏元素的文本，而<code>textContent</code>返回所有文本</p><h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><p><code>DOM</code>节点的<code>style</code>属性对应所有的<code>CSS</code>，可以直接获取或设置。遇到<code>-</code>需要转化为驼峰命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p &gt;</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置CSS:</span></span><br><span class="line">p.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;#ff0000&#x27;</span>;</span><br><span class="line">p.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&#x27;20px&#x27;</span>; <span class="comment">// 驼峰命名</span></span><br><span class="line">p.<span class="property">style</span>.<span class="property">paddingTop</span> = <span class="string">&#x27;2em&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><h4 id="innerHTML-1"><a href="#innerHTML-1" class="headerlink" title="innerHTML"></a>innerHTML</h4><p>如果这个DOM节点是空的，例如，<code>&lt;div&gt;&lt;/div&gt;</code>，那么，直接使用<code>innerHTML = &#39;&lt;span&gt;child&lt;/span&gt;&#39;</code>就可以修改<code>DOM</code>节点的内容，相当于添加了新的<code>DOM</code>节点</p><p>如果这个DOM节点不是空的，那就不能这么做，因为<code>innerHTML</code>会直接替换掉原来的所有子节点</p><h4 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h4><p>把一个子节点添加到父节点的最后一个子节点</p><p>举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="variable constant_">HTML</span>结构 --&gt;</span><br><span class="line">&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p &gt;</span><br><span class="line">&lt;div id=&quot;list&quot;&gt;</span><br><span class="line">    &lt;p id=&quot;java&quot;&gt;Java&lt;/p &gt;</span><br><span class="line">    &lt;p id=&quot;python&quot;&gt;Python&lt;/p &gt;</span><br><span class="line">    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p &gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>添加一个<code>p</code>元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> js = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;js&#x27;</span>)</span><br><span class="line">js.<span class="property">innerHTML</span> = <span class="string">&quot;JavaScript&quot;</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">list.<span class="title function_">appendChild</span>(js);</span><br></pre></td></tr></table></figure><p>现在<code>HTML</code>结构变成了下面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="variable constant_">HTML</span>结构 --&gt;</span><br><span class="line">&lt;div id=&quot;list&quot;&gt;</span><br><span class="line">    &lt;p id=&quot;java&quot;&gt;Java&lt;/p &gt;</span><br><span class="line">    &lt;p id=&quot;python&quot;&gt;Python&lt;/p &gt;</span><br><span class="line">    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p &gt;</span><br><span class="line">    &lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p &gt;  &lt;!-- 添加元素 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上述代码中，我们是获取<code>DOM</code>元素后再进行添加操作，这个<code>js</code>节点是已经存在当前文档树中，因此这个节点首先会从原先的位置删除，再插入到新的位置</p><p>如果动态添加新的节点，则先创建一个新的节点，然后插入到指定的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>),</span><br><span class="line"><span class="keyword">const</span> haskell = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">haskell.<span class="property">id</span> = <span class="string">&#x27;haskell&#x27;</span>;</span><br><span class="line">haskell.<span class="property">innerText</span> = <span class="string">&#x27;Haskell&#x27;</span>;</span><br><span class="line">list.<span class="title function_">appendChild</span>(haskell);</span><br></pre></td></tr></table></figure><h4 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h4><p>把子节点插入到指定的位置，使用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentElement.<span class="title function_">insertBefore</span>(newElement, referenceElement)</span><br></pre></td></tr></table></figure><p>子节点会插入到<code>referenceElement</code>之前</p><h4 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute"></a>setAttribute</h4><p>在指定元素中添加一个属性节点，如果元素中已有该属性改变属性值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;white&#x27;</span>);<span class="comment">//第一个参数属性名，第二个参数属性值。</span></span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的<code>removeChild</code>把自己删掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">const</span> self = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;to-be-removed&#x27;</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">const</span> parent = self.<span class="property">parentElement</span>;</span><br><span class="line"><span class="comment">// 删除:</span></span><br><span class="line"><span class="keyword">const</span> removed = parent.<span class="title function_">removeChild</span>(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model">https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_dom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大文件上传如何做断点续传？</title>
      <link href="/2019/07/06/js-continue-to-upload/"/>
      <url>/2019/07/06/js-continue-to-upload/</url>
      
        <content type="html"><![CDATA[<h1 id="大文件上传如何做断点续传？"><a href="#大文件上传如何做断点续传？" class="headerlink" title="大文件上传如何做断点续传？"></a>大文件上传如何做断点续传？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂</p><p>文件上传简单，文件变大就复杂</p><p>上传大文件时，以下几个变量会影响我们的用户体验</p><ul><li>服务器处理数据的能力</li><li>请求超时</li><li>网络波动</li></ul><p>上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等</p><p>为了解决上述问题，我们需要对大文件上传单独处理</p><p>这里涉及到分片上传及断点续传两个概念</p><h4 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h4><p>分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传</p><p>如下图</p><p> <img src="https://static.vue-js.com/21db7520-8ba4-11eb-85f6-6fac77c0c9b3.png"></p><p>上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件</p><p>大致流程如下：</p><ol><li>将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；</li><li>初始化一个分片上传任务，返回本次分片上传唯一标识；</li><li>按照一定的策略（串行或并行）发送各个分片数据块；</li><li>发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件</li></ol><h4 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h4><p>断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分</p><p>每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度</p><p>一般实现方式有两种：</p><ul><li>服务器端返回，告知从哪开始</li><li>浏览器端自行处理</li></ul><p>上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可</p><p>如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可</p><h2 id="二、实现思路"><a href="#二、实现思路" class="headerlink" title="二、实现思路"></a>二、实现思路</h2><p>整体思路比较简单，拿到文件，保存文件唯一性标识，切割文件，分段上传，每次上传一段，根据唯一性标识判断文件上传进度，直到文件的全部片段上传完毕</p><p><img src="https://static.vue-js.com/465d2920-8ba4-11eb-85f6-6fac77c0c9b3.png"></p><p>下面的内容都是伪代码</p><p>读取文件内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> file = <span class="variable language_">this</span>.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以使用<code>md5</code>实现文件的唯一性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> md5code = <span class="title function_">md5</span>(file);</span><br></pre></td></tr></table></figure><p>然后开始对文件进行分割</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">reader.<span class="title function_">readAsArrayBuffer</span>(file);</span><br><span class="line">reader.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">//每10M切割一段,这里只做一个切割演示，实际切割需要循环切割，</span></span><br><span class="line">    <span class="keyword">var</span> slice = e.<span class="property">target</span>.<span class="property">result</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>h5上传一个（一片）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formdata = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">formdata.<span class="title function_">append</span>(<span class="string">&#x27;0&#x27;</span>, slice);</span><br><span class="line"><span class="comment">//这里是有一个坑的，部分设备无法获取文件名称，和文件类型，这个在最后给出解决方案</span></span><br><span class="line">formdata.<span class="title function_">append</span>(<span class="string">&#x27;filename&#x27;</span>, file.<span class="property">filename</span>);</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//xhr.responseText</span></span><br><span class="line">&#125;);</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(formdata);</span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;progress&#x27;</span>, updateProgress);</span><br><span class="line">xhr.<span class="property">upload</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;progress&#x27;</span>, updateProgress);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateProgress</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">        <span class="comment">//进度条</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给出常见的图片和视频的文件类型判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkFileType</span>(<span class="params">type, file, back</span>) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* type png jpg mp4 ...</span></span><br><span class="line"><span class="comment">* file input.change=&gt; this.files[0]</span></span><br><span class="line"><span class="comment">* back callback(boolean)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="title function_">back</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> type = args[<span class="number">0</span>]; <span class="comment">// type = &#x27;(png|jpg)&#x27; , &#x27;png&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> file = args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> back = <span class="keyword">typeof</span> args[<span class="number">2</span>] == <span class="string">&#x27;function&#x27;</span> ? args[<span class="number">2</span>] : <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="property">type</span> == <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果系统无法获取文件类型，则读取二进制流，对二进制进行解析文件类型</span></span><br><span class="line">        <span class="keyword">var</span> imgType = [</span><br><span class="line">            <span class="string">&#x27;ff d8 ff&#x27;</span>, <span class="comment">//jpg</span></span><br><span class="line">            <span class="string">&#x27;89 50 4e&#x27;</span>, <span class="comment">//png</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;0 0 0 14 66 74 79 70 69 73 6F 6D&#x27;</span>, <span class="comment">//mp4</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 18 66 74 79 70 33 67 70 35&#x27;</span>, <span class="comment">//mp4</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 0 66 74 79 70 33 67 70 35&#x27;</span>, <span class="comment">//mp4</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 0 66 74 79 70 4D 53 4E 56&#x27;</span>, <span class="comment">//mp4</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 0 66 74 79 70 69 73 6F 6D&#x27;</span>, <span class="comment">//mp4</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;0 0 0 18 66 74 79 70 6D 70 34 32&#x27;</span>, <span class="comment">//m4v</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 0 66 74 79 70 6D 70 34 32&#x27;</span>, <span class="comment">//m4v</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;0 0 0 14 66 74 79 70 71 74 20 20&#x27;</span>, <span class="comment">//mov</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 0 66 74 79 70 71 74 20 20&#x27;</span>, <span class="comment">//mov</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 0 6D 6F 6F 76&#x27;</span>, <span class="comment">//mov</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;4F 67 67 53 0 02&#x27;</span>, <span class="comment">//ogg</span></span><br><span class="line">            <span class="string">&#x27;1A 45 DF A3&#x27;</span>, <span class="comment">//ogg</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;52 49 46 46 x x x x 41 56 49 20&#x27;</span>, <span class="comment">//avi (RIFF fileSize fileType LIST)(52 49 46 46,DC 6C 57 09,41 56 49 20,4C 49 53 54)</span></span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">var</span> typeName = [</span><br><span class="line">            <span class="string">&#x27;jpg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;png&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mp4&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mp4&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mp4&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mp4&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mp4&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;m4v&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;m4v&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mov&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mov&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mov&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;ogg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;ogg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;avi&#x27;</span>,</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">var</span> sliceSize = <span class="regexp">/png|jpg|jpeg/</span>.<span class="title function_">test</span>(type) ? <span class="number">3</span> : <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">        reader.<span class="title function_">readAsArrayBuffer</span>(file);</span><br><span class="line">        reader.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> slice = e.<span class="property">target</span>.<span class="property">result</span>.<span class="title function_">slice</span>(<span class="number">0</span>, sliceSize);</span><br><span class="line">            reader = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (slice &amp;&amp; slice.<span class="property">byteLength</span> == sliceSize) &#123;</span><br><span class="line">                <span class="keyword">var</span> view = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(slice);</span><br><span class="line">                <span class="keyword">var</span> arr = [];</span><br><span class="line">                view.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">v</span>) &#123;</span><br><span class="line">                    arr.<span class="title function_">push</span>(v.<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line">                &#125;);</span><br><span class="line">                view = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">var</span> idx = arr.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">indexOf</span>(imgType);</span><br><span class="line">                <span class="keyword">if</span> (idx &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="title function_">back</span>(typeName[idx]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    arr = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">v</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">3</span> &amp;&amp; i &lt; <span class="number">8</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> v;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">var</span> idx = arr.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">indexOf</span>(imgType);</span><br><span class="line">                    <span class="keyword">if</span> (idx &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="title function_">back</span>(typeName[idx]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="title function_">back</span>(<span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">back</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> type = file.<span class="property">name</span>.<span class="title function_">match</span>(<span class="regexp">/\.(\w+)$/</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="title function_">back</span>(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">checkFileType</span>(<span class="string">&#x27;(mov|mp4|avi)&#x27;</span>,file,<span class="keyword">function</span>(<span class="params">fileType</span>)&#123;</span><br><span class="line">    <span class="comment">// fileType = mp4,</span></span><br><span class="line">    <span class="comment">// 如果file的类型不在枚举之列，则返回false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面上传文件的一步，可以改成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formdata.<span class="title function_">append</span>(<span class="string">&#x27;filename&#x27;</span>, md5code+<span class="string">&#x27;.&#x27;</span>+fileType);</span><br></pre></td></tr></table></figure><p>有了切割上传后，也就有了文件唯一标识信息，断点续传变成了后台的一个小小的逻辑判断</p><p>后端主要做的内容为：根据前端传给后台的<code>md5</code>值，到服务器磁盘查找是否有之前未完成的文件合并信息（也就是未完成的半成品文件切片），取到之后根据上传切片的数量，返回数据告诉前端开始从第几节上传</p><p>如果想要暂停切片的上传，可以使用<code>XMLHttpRequest </code>的 <code>abort </code>方法</p><h2 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h2><ul><li>大文件加速上传：当文件大小超过预期大小时，使用分片上传可实现并行上传多个 Part， 以加快上传速度</li><li>网络环境较差：建议使用分片上传。当出现上传失败的时候，仅需重传失败的Part</li><li>流式上传：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在视频监控等行业应用中比较常见</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当前的伪代码，只是提供一个简单的思路，想要把事情做到极致，我们还需要考虑到更多场景，比如</p><ul><li>切片上传失败怎么办</li><li>上传过程中刷新页面怎么办</li><li>如何进行并行上传</li><li>切片什么时候按数量切，什么时候按大小切</li><li>如何结合 Web Worker 处理大文件上传</li><li>如何实现秒传</li></ul><p>人生又何尝不是如此，极致的人生体验有无限可能，越是后面才发现越是精彩 <del>_</del></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000009448892">https://segmentfault.com/a/1190000009448892</a></li><li><a href="https://baike.baidu.com/">https://baike.baidu.com/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_continue_to_upload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript中如何实现函数缓存？函数缓存有哪些应用场景？</title>
      <link href="/2019/06/20/js-function-cache/"/>
      <url>/2019/06/20/js-function-cache/</url>
      
        <content type="html"><![CDATA[<h1 id="Javascript中如何实现函数缓存？函数缓存有哪些应用场景？"><a href="#Javascript中如何实现函数缓存？函数缓存有哪些应用场景？" class="headerlink" title="Javascript中如何实现函数缓存？函数缓存有哪些应用场景？"></a>Javascript中如何实现函数缓存？函数缓存有哪些应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>函数缓存，就是将函数运算过的结果进行缓存</p><p>本质上就是用空间（缓存存储）换时间（计算过程）</p><p>常用于缓存数据计算结果和缓存对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a,b</span>) =&gt; a+b;</span><br><span class="line"><span class="keyword">const</span> calc = <span class="title function_">memoize</span>(add); <span class="comment">// 函数缓存</span></span><br><span class="line"><span class="title function_">calc</span>(<span class="number">10</span>,<span class="number">20</span>);<span class="comment">// 30</span></span><br><span class="line"><span class="title function_">calc</span>(<span class="number">10</span>,<span class="number">20</span>);<span class="comment">// 30 缓存</span></span><br></pre></td></tr></table></figure><p>缓存只是一个临时的数据存储，它保存数据，以便将来对该数据的请求能够更快地得到处理</p><h2 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h2><p>实现函数缓存主要依靠闭包、柯里化、高阶函数，这里再简单复习下：</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包可以理解成，函数 + 函数体内可访问的变量总和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> sum = b + a</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">add</span>()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p><code>add </code>函数本身，以及其内部可访问的变量，即 <code>a = 1 </code>，这两个组合在⼀起就形成了闭包</p><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>把接受多个参数的函数转换成接受一个单一参数的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非函数柯里化</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params">x,y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">3</span>,<span class="number">4</span>) <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数柯里化</span></span><br><span class="line"><span class="keyword">var</span> add2 = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="comment">//**返回函数**</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">y</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add2</span>(<span class="number">3</span>)(<span class="number">4</span>) <span class="comment">//7</span></span><br></pre></td></tr></table></figure><p>将一个二元函数拆分成两个一元函数</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>通过接收其他函数作为参数或返回其他函数的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">baz</span>();<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>函数 <code>foo</code> 如何返回另一个函数 <code>bar</code>，<code>baz</code> 现在持有对 <code>foo</code> 中定义的<code>bar</code> 函数的引用。由于闭包特性，<code>a</code>的值能够得到</p><p>下面再看看如何实现函数缓存，实现原理也很简单，把参数和对应的结果数据存在一个对象中，调用时判断参数对应的数据是否存在，存在就返回对应的结果数据，否则就返回计算结果</p><p>如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoize = <span class="keyword">function</span> (<span class="params">func, content</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cache = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  content = content || <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache[key]) &#123;</span><br><span class="line">      cache[key] = func.<span class="title function_">apply</span>(content, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式也很简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calc = <span class="title function_">memoize</span>(add);</span><br><span class="line"><span class="keyword">const</span> num1 = <span class="title function_">calc</span>(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"><span class="keyword">const</span> num2 = <span class="title function_">calc</span>(<span class="number">100</span>,<span class="number">200</span>) <span class="comment">// 缓存得到的结果</span></span><br></pre></td></tr></table></figure><p>过程分析：</p><ul><li>在当前函数作用域定义了一个空对象，用于缓存运行结果</li><li>运用柯里化返回一个函数，返回的函数由于闭包特性，可以访问到<code>cache</code></li><li>然后判断输入参数是不是在<code>cache</code>的中。如果已经存在，直接返回<code>cache</code>的内容，如果没有存在，使用函数<code>func</code>对输入参数求值，然后把结果存储在<code>cache</code>中</li></ul><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>虽然使用缓存效率是非常高的，但并不是所有场景都适用，因此千万不要极端的将所有函数都添加缓存</p><p>以下几种情况下，适合使用缓存：</p><ul><li>对于昂贵的函数调用，执行复杂计算的函数</li><li>对于具有有限且高度重复输入范围的函数</li><li>对于具有重复输入值的递归函数</li><li>对于纯函数，即每次使用特定输入调用时返回相同输出的函数</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/112505577">https://zhuanlan.zhihu.com/p/112505577</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_function_cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对闭包的理解？闭包使用场景</title>
      <link href="/2019/06/06/js-closure/"/>
      <url>/2019/06/06/js-closure/</url>
      
        <content type="html"><![CDATA[<h1 id="对闭包的理解？闭包使用场景"><a href="#对闭包的理解？闭包使用场景" class="headerlink" title="对闭包的理解？闭包使用场景"></a>对闭包的理解？闭包使用场景</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</p><p>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域</p><p>在 <code>JavaScript </code>中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁</p><p>下面给出一个简单的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>; <span class="comment">// name 是一个被 init 创建的局部变量</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">displayName</span>(<span class="params"></span>) &#123; <span class="comment">// displayName() 是内部函数，一个闭包</span></span><br><span class="line">        <span class="title function_">alert</span>(name); <span class="comment">// 使用了父函数中声明的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">displayName</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><p><code>displayName()</code> 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量</p><h2 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h2><p>任何闭包的使用场景都离不开这两点：</p><ul><li>创建私有变量</li><li>延长变量的生命周期</li></ul><blockquote><p>一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的</p></blockquote><p>下面举个例子：</p><p>在页面上添加一些可以调整字号的按钮</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeSizer</span>(<span class="params">size</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = size + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> size12 = <span class="title function_">makeSizer</span>(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> size14 = <span class="title function_">makeSizer</span>(<span class="number">14</span>);</span><br><span class="line"><span class="keyword">var</span> size16 = <span class="title function_">makeSizer</span>(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;size-12&#x27;</span>).<span class="property">onclick</span> = size12;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;size-14&#x27;</span>).<span class="property">onclick</span> = size14;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;size-16&#x27;</span>).<span class="property">onclick</span> = size16;</span><br></pre></td></tr></table></figure><h3 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h3><p>柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个求长方形面积的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">width, height</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> width * height</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果我们碰到的长方形的宽老是10</span></span><br><span class="line"><span class="keyword">const</span> area1 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">const</span> area2 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> area3 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以使用闭包柯里化这个计算面积的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">width</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">height</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getTenWidthArea = <span class="title function_">getArea</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 之后碰到宽度为10的长方形就可以这样计算面积</span></span><br><span class="line"><span class="keyword">const</span> area1 = <span class="title function_">getTenWidthArea</span>(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而且如果遇到宽度偶尔变化也可以轻松复用</span></span><br><span class="line"><span class="keyword">const</span> getTwentyWidthArea = <span class="title function_">getArea</span>(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h3 id="使用闭包模拟私有方法"><a href="#使用闭包模拟私有方法" class="headerlink" title="使用闭包模拟私有方法"></a>使用闭包模拟私有方法</h3><p>在<code>JavaScript</code>中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法</p><p>下面举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Counter</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Counter1</span> = <span class="title function_">makeCounter</span>();</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Counter2</span> = <span class="title function_">makeCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter1</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 0 */</span></span><br><span class="line"><span class="title class_">Counter1</span>.<span class="title function_">increment</span>();</span><br><span class="line"><span class="title class_">Counter1</span>.<span class="title function_">increment</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter1</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 2 */</span></span><br><span class="line"><span class="title class_">Counter1</span>.<span class="title function_">decrement</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter1</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 1 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter2</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 0 */</span></span><br></pre></td></tr></table></figure><p>上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式</p><p>两个计数器 <code>Counter1</code> 和 <code>Counter2</code> 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期</p><h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><p>如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响</p><p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。</p><p>原因在于每个对象的创建，方法都会被重新赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getMessage</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMessage</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_closure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript本地存储的方式有哪些？区别及应用场景？</title>
      <link href="/2019/05/06/js-cache/"/>
      <url>/2019/05/06/js-cache/</url>
      
        <content type="html"><![CDATA[<h1 id="Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="Javascript本地存储的方式有哪些？区别及应用场景？"></a>Javascript本地存储的方式有哪些？区别及应用场景？</h1><h2 id="一、方式"><a href="#一、方式" class="headerlink" title="一、方式"></a>一、方式</h2><p><code>javaScript</code>本地缓存的方法我们主要讲述以下四种：</p><ul><li>cookie</li><li>sessionStorage</li><li>localStorage</li><li>indexedDB</li></ul><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p><code>Cookie</code>，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 <code>HTTP </code>无状态导致的问题</p><p>作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 <code>cookie </code>有效期、安全性、使用范围的可选属性组成</p><p>但是<code>cookie</code>在每次请求中都会被发送，如果不使用 <code>HTTPS </code>并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 <code>cookie </code>保持登录态的网站上，如果 <code>cookie </code>被窃取，他人很容易利用你的 <code>cookie </code>来假扮成你登录网站</p><p>关于<code>cookie</code>常用的属性如下：</p><ul><li>Expires 用于设置 Cookie 的过期时间</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Expires</span>=<span class="title class_">Wed</span>, <span class="number">21</span> <span class="title class_">Oct</span> <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> <span class="variable constant_">GMT</span></span><br></pre></td></tr></table></figure><ul><li>Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比<code>Expires</code>高）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Max</span>-<span class="title class_">Age</span>=<span class="number">604800</span></span><br></pre></td></tr></table></figure><ul><li><code>Domain </code>指定了 <code>Cookie</code> 可以送达的主机名</li><li><code>Path </code>指定了一个 <code>URL </code>路径，这个路径必须出现在要请求的资源的路径中才可以发送 <code>Cookie</code> 首部</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Path</span>=<span class="regexp">/docs   # /</span>docs/<span class="title class_">Web</span>/ 下的资源会带 <span class="title class_">Cookie</span> 首部</span><br></pre></td></tr></table></figure><ul><li>标记为 <code>Secure </code>的 <code>Cookie </code>只应通过被<code>HTTPS</code>协议加密过的请求发送给服务端</li></ul><p>通过上述，我们可以看到<code>cookie</code>又开始的作用并不是为了缓存而设计出来，只是借用了<code>cookie</code>的特性实现缓存</p><p>关于<code>cookie</code>的使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;名字=值&#x27;</span>;</span><br></pre></td></tr></table></figure><p>关于<code>cookie</code>的修改，首先要确定<code>domain</code>和<code>path</code>属性都是相同的才可以，其中有一个不同得时候都会创建出一个新的<code>cookie</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>:name=aa; domain=aa.<span class="property">net</span>; path=/  # 服务端设置</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> =name=bb; domain=aa.<span class="property">net</span>; path=/  # 客户端设置</span><br></pre></td></tr></table></figure><p>最后<code>cookie</code>的删除，最常用的方法就是给<code>cookie</code>设置一个过期的事件，这样<code>cookie</code>过期后会被浏览器删除</p><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p><code>HTML5</code>新方法，IE8及以上浏览器都兼容</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</li><li>存储的信息在同一域中是共享的</li><li>当本页操作（新增、修改、删除）了<code>localStorage</code>的时候，本页面不会触发<code>storage</code>事件,但是别的页面会触发<code>storage</code>事件。</li><li>大小：5M（跟浏览器厂商有关系）</li><li><code>localStorage</code>本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li><li>受同源策略的限制</li></ul><p>下面再看看关于<code>localStorage</code>的使用</p><p>设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;cfangxu&#x27;</span>);</span><br></pre></td></tr></table></figure><p>获取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;username&#x27;</span>)</span><br></pre></td></tr></table></figure><p>获取键名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">key</span>(<span class="number">0</span>) <span class="comment">//获取第一个键名</span></span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;username&#x27;</span>)</span><br></pre></td></tr></table></figure><p>一次性清除所有存储</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure><p><code>localStorage</code> 也不是完美的，它有两个缺点：</p><ul><li>无法像<code>Cookie</code>一样设置过期时间</li><li>只能存入字符串，无法直接存对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;value&#x27;</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>)); <span class="comment">// &#x27;[object, Object]&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p><code>sessionStorage </code>和 <code>localStorage </code>使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，<code>sessionStorage</code> 将会删除数据</p><h3 id="扩展的前端存储方式"><a href="#扩展的前端存储方式" class="headerlink" title="扩展的前端存储方式"></a>扩展的前端存储方式</h3><p><code>indexedDB </code>是一种低级API，用于客户端存储大量结构化数据(包括, 文件&#x2F; blobs)。该API使用索引来实现对该数据的高性能搜索</p><p>虽然 <code>Web Storage </code>对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。<code>IndexedDB</code>提供了一个解决方案</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>储存量理论上没有上限</li><li>所有操作都是异步的，相比 <code>LocalStorage</code> 同步操作性能更高，尤其是数据量较大时</li><li>原生支持储存<code>JS</code>的对象</li><li>是个正经的数据库，意味着数据库能干的事它都能干</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>操作非常繁琐</li><li>本身有一定门槛</li></ul><p>关于<code>indexedDB</code>的使用基本使用步骤如下：</p><ul><li><p>打开数据库并且开始一个事务</p></li><li><p>创建一个 <code>object store</code></p></li><li><p>构建一个请求来执行一些数据库操作，像增加或提取数据等。</p></li><li><p>通过监听正确类型的 <code>DOM</code> 事件以等待操作完成。</p></li><li><p>在操作结果上进行一些操作（可以在 <code>request </code>对象中找到）</p></li></ul><p>关于使用<code>indexdb</code>的使用会比较繁琐，大家可以通过使用<code>Godb.js</code>库进行缓存，最大化的降低操作难度</p><h2 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h2><p>关于<code>cookie</code>、<code>sessionStorage</code>、<code>localStorage</code>三者的区别主要如下：</p><ul><li><p>存储大小：<code> cookie</code>数据大小不能超过<code>4k</code>，<code>sessionStorage</code>和<code>localStorage </code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</p></li><li><p>有效时间：<code>localStorage  </code>存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； <code>sessionStorage  </code>数据在当前浏览器窗口关闭后自动删除；<code>cookie</code>设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</p></li><li><p>数据与服务器之间的交互方式，<code>  cookie</code>的数据会自动的传递到服务器，服务器端也可以写<code>cookie</code>到客户端； <code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</p></li></ul><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：</p><ul><li>标记用户与跟踪用户行为的情况，推荐使用<code>cookie</code></li><li>适合长期保存在本地的数据（令牌），推荐使用<code>localStorage</code></li><li>敏感账号一次性登录，推荐使用<code>sessionStorage</code></li><li>存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用<code>indexedDB</code></li></ul><h2 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h2><ul><li><a href="https://mp.weixin.qq.com/s/mROjtpoXarN--UDfEMqwhQ">https://mp.weixin.qq.com/s/mROjtpoXarN--UDfEMqwhQ</a></li><li><a href="https://github.com/chenstarx/GoDB.js">https://github.com/chenstarx/GoDB.js</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web常见的攻击方式有哪些？如何防御？</title>
      <link href="/2019/05/05/js-security/"/>
      <url>/2019/05/05/js-security/</url>
      
        <content type="html"><![CDATA[<h1 id="web常见的攻击方式有哪些？如何防御？"><a href="#web常见的攻击方式有哪些？如何防御？" class="headerlink" title="web常见的攻击方式有哪些？如何防御？"></a>web常见的攻击方式有哪些？如何防御？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>Web攻击（WebAttack）是针对用户上网行为或网站服务器等设备进行攻击的行为</p><p>如植入恶意代码，修改网站权限，获取网站用户隐私信息等等</p><p>Web应用程序的安全性是任何基于Web业务的重要组成部分</p><p>确保Web应用程序安全十分重要，即使是代码中很小的 bug 也有可能导致隐私信息被泄露</p><p>站点安全就是为保护站点不受未授权的访问、使用、修改和破坏而采取的行为或实践</p><p>我们常见的Web攻击方式有</p><ul><li>XSS (Cross Site Scripting) 跨站脚本攻击</li><li>CSRF（Cross-site request forgery）跨站请求伪造</li><li>SQL注入攻击</li></ul><h2 id="二、XSS"><a href="#二、XSS" class="headerlink" title="二、XSS"></a>二、XSS</h2><p>XSS，跨站脚本攻击，允许攻击者将恶意代码植入到提供给其它用户使用的页面中</p><p><code>XSS</code>涉及到三方，即攻击者、客户端与<code>Web</code>应用</p><p><code>XSS</code>的攻击目标是为了盗取存储在客户端的<code>cookie</code>或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互</p><p>举个例子：</p><p>一个搜索页面，根据<code>url</code>参数决定关键词的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&lt;%= getParameter(&quot;</span><span class="attr">keyword</span>&quot;) %&gt;</span>&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是：&lt;%= getParameter(&quot;keyword&quot;) %&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里看似并没有问题，但是如果不按套路出牌呢？</p><p>用户输入<code>&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code>，拼接到 HTML 中返回给浏览器。形成了如下的 HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是：&quot;&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器无法分辨出 <code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code> 是恶意代码，因而将其执行，试想一下，如果是获取<code>cookie</code>发送对黑客服务器呢？</p><p>根据攻击的来源，<code>XSS</code>攻击可以分成：</p><ul><li>存储型</li><li>反射型</li><li>DOM 型</li></ul><h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><p>存储型 XSS 的攻击步骤：</p><ol><li>攻击者将恶意代码提交到目标网站的数据库中</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ol><p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等</p><h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>反射型 XSS 的攻击步骤：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ol><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p><p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p><p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p><p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见</p><h3 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h3><p>DOM 型 XSS 的攻击步骤：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>用户打开带有恶意代码的 URL</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ol><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞</p><h3 id="XSS的预防"><a href="#XSS的预防" class="headerlink" title="XSS的预防"></a>XSS的预防</h3><p>通过前面介绍，看到<code>XSS</code>攻击的两大要素：</p><ul><li>攻击者提交而恶意代码</li><li>浏览器执行恶意代码</li></ul><p>针对第一个要素，我们在用户输入的过程中，过滤掉用户输入的恶劣代码，然后提交给后端，但是如果攻击者绕开前端请求，直接构造请求就不能预防了</p><p>而如果在后端写入数据库前，对输入进行过滤，然后把内容给前端，但是这个内容在不同地方就会有不同显示</p><p>例如：</p><p>一个正常的用户输入了 <code>5 &lt; 7</code> 这个内容，在写入数据库前，被转义，变成了 <code>5 &lt; 7</code></p><p>在客户端中，一旦经过了 <code>escapeHTML()</code>，客户端显示的内容就变成了乱码( <code>5 &lt; 7</code> )</p><p>在前端中，不同的位置所需的编码也不同。</p><ul><li>当 <code>5 &lt; 7</code> 作为 HTML 拼接页面时，可以正常显示：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;comment&quot;</span>&gt;</span>5 <span class="symbol">&amp;lt;</span> 7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>当 <code>5 &lt; 7</code> 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等</li></ul><p>可以看到，过滤并非可靠的，下面就要通过防止浏览器执行恶意代码：</p><p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等</p><p>如果用 <code>Vue/React</code> 技术栈，并且不使用 <code>v-html</code>&#x2F;<code>dangerouslySetInnerHTML</code> 功能，就在前端 <code>render</code> 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患</p><p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 链接内包含恶意代码 --&gt;</span><br><span class="line">&lt; a href=<span class="string">&quot; &quot;</span>&gt;<span class="number">1</span>&lt;/ a&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// setTimeout()/setInterval() 中调用恶意代码</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// location 调用恶意代码</span></span><br><span class="line">location.<span class="property">href</span> = <span class="string">&#x27;UNTRUSTED&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eval() 中调用恶意代码</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="三、CSRF"><a href="#三、CSRF" class="headerlink" title="三、CSRF"></a>三、CSRF</h2><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求</p><p>利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目</p><p>一个典型的CSRF攻击有着如下的流程：</p><ul><li>受害者登录a.com，并保留了登录凭证（Cookie）</li><li>攻击者引诱受害者访问了b.com</li><li>b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx。浏览器会默认携带a.com的Cookie</li><li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li><li>a.com以受害者的名义执行了act&#x3D;xx</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作</li></ul><p><code>csrf</code>可以通过<code>get</code>请求，即通过访问<code>img</code>的页面后，浏览器自动访问目标地址，发送请求</p><p>同样，也可以设置一个自动提交的表单发送<code>post</code>请求，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;http://bank.example/withdraw&quot;</span> method=<span class="variable constant_">POST</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span> /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;for&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">submit</span>(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br></pre></td></tr></table></figure><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次<code>POST</code>操作</p><p>还有一种为使用<code>a</code>标签的，需要用户点击链接才会触发</p><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt; a href=&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot; taget=&quot;_blank&quot;&gt;</span><br><span class="line">    重磅消息！！</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h3><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”</li><li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪</li></ul><h3 id="CSRF的预防"><a href="#CSRF的预防" class="headerlink" title="CSRF的预防"></a>CSRF的预防</h3><p>CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性</p><p>防止<code>csrf</code>常用方案如下：</p><ul><li>阻止不明外域的访问<ul><li>同源检测</li><li>Samesite Cookie</li></ul></li><li>提交时要求附加本域才能获取的信息<ul><li>CSRF Token</li><li>双重Cookie验证</li></ul></li></ul><p>这里主要讲讲<code>token</code>这种形式，流程如下：</p><ul><li>用户打开页面的时候，服务器需要给这个用户生成一个Token</li><li>对于GET请求，Token将附在请求地址之后。对于 POST 请求来说，要在 form 的最后加上</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”hidden”</span> <span class="attr">name</span>=<span class="string">”csrftoken”</span> <span class="attr">value</span>=<span class="string">”tokenvalue”/</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性</li></ul><h2 id="四、SQL注入"><a href="#四、SQL注入" class="headerlink" title="四、SQL注入"></a>四、SQL注入</h2><p>Sql 注入攻击，是通过将恶意的 <code>Sql </code>查询或添加语句插入到应用的输入参数中，再在后台 <code>Sql </code>服务器上解析执行进行的攻击</p><p> <img src="https://static.vue-js.com/ead52fa0-8d1d-11eb-85f6-6fac77c0c9b3.png"></p><p>流程如下所示：</p><ul><li><p>找出SQL漏洞的注入点</p></li><li><p>判断数据库的类型以及版本</p></li><li><p>猜解用户名和密码</p></li><li><p>利用工具查找Web后台管理入口</p></li><li><p>入侵和破坏</p></li></ul><p>预防方式如下：</p><ul><li>严格检查输入变量的类型和格式</li><li>过滤和转义特殊字符</li><li>对访问数据库的Web应用程序采用Web应用防火墙</li></ul><p>上述只是列举了常见的<code>web</code>攻击方式，实际开发过程中还会遇到很多安全问题，对于这些问题， 切记不可忽视</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://tech.meituan.com/2018/09/27/fe-security.html">https://tech.meituan.com/2018/09/27/fe-security.html</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/learn/Server-side/First_steps/Website_security">https://developer.mozilla.org/zh-CN/docs/learn/Server-side/First_steps/Website_security</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中执行上下文和执行栈是什么？</title>
      <link href="/2019/04/26/js-context-stack/"/>
      <url>/2019/04/26/js-context-stack/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript中执行上下文和执行栈是什么？"><a href="#JavaScript中执行上下文和执行栈是什么？" class="headerlink" title="JavaScript中执行上下文和执行栈是什么？"></a>JavaScript中执行上下文和执行栈是什么？</h1><h2 id="一、执行上下文"><a href="#一、执行上下文" class="headerlink" title="一、执行上下文"></a>一、执行上下文</h2><p>简单的来说，执行上下文是一种对<code>Javascript</code>代码执行环境的抽象概念，也就是说只要有<code>Javascript</code>代码运行，那么它就一定是运行在执行上下文中</p><p>执行上下文的类型分为三种：</p><ul><li>全局执行上下文：只有一个，浏览器中的全局对象就是 <code>window </code>对象，<code>this</code> 指向这个全局对象</li><li>函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文</li><li>Eval 函数执行上下文： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用</li></ul><p>下面给出全局上下文和函数上下文的例子：</p><p> <img src="https://static.vue-js.com/90dd3b60-74c1-11eb-85f6-6fac77c0c9b3.png"></p><p>紫色框住的部分为全局上下文，蓝色和橘色框起来的是不同的函数上下文。只有全局上下文（的变量）能被其他任何上下文访问</p><p>可以有任意多个函数上下文，每次调用函数创建一个新的上下文，会创建一个私有作用域，函数内部声明的任何变量都不能在当前函数作用域外部直接访问</p><h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><p>执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段</p><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><p>创建阶段即当函数被调用，但未执行任何其内部代码之前</p><p>创建阶段做了三件事：</p><ul><li>确定 this 的值，也被称为 <code>This Binding</code></li><li>LexicalEnvironment（词法环境） 组件被创建</li><li>VariableEnvironment（变量环境） 组件被创建</li></ul><p>伪代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ExecutionContext</span> = &#123;  </span><br><span class="line">  <span class="title class_">ThisBinding</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">this</span> <span class="attr">value</span>&gt;</span>,     // 确定this </span></span><br><span class="line"><span class="language-xml">  LexicalEnvironment = &#123; ... &#125;,   // 词法环境</span></span><br><span class="line"><span class="language-xml">  VariableEnvironment = &#123; ... &#125;,  // 变量环境</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="This-Binding"><a href="#This-Binding" class="headerlink" title="This Binding"></a>This Binding</h4><p>确定<code>this</code>的值我们前面讲到，<code>this</code>的值是在执行的时候才能确认，定义的时候不能确认</p><h4 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h4><p>词法环境有两个组成部分：</p><ul><li><p>全局环境：是一个没有外部环境的词法环境，其外部环境引用为<code> null</code>，有一个全局对象，<code>this</code> 的值指向这个全局对象</p></li><li><p>函数环境：用户在函数中定义的变量被存储在环境记录中，包含了<code>arguments</code> 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境</p></li></ul><p>伪代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">GlobalExectionContext</span> = &#123;  <span class="comment">// 全局执行上下文</span></span><br><span class="line">  <span class="title class_">LexicalEnvironment</span>: &#123;       <span class="comment">// 词法环境</span></span><br><span class="line">    <span class="title class_">EnvironmentRecord</span>: &#123;     <span class="comment">// 环境记录</span></span><br><span class="line">      <span class="title class_">Type</span>: <span class="string">&quot;Object&quot;</span>,           <span class="comment">// 全局环境</span></span><br><span class="line">      <span class="comment">// 标识符绑定在这里 </span></span><br><span class="line">      <span class="attr">outer</span>: &lt;<span class="literal">null</span>&gt;           <span class="comment">// 对外部环境的引用</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">FunctionExectionContext</span> = &#123; <span class="comment">// 函数执行上下文</span></span><br><span class="line">  <span class="title class_">LexicalEnvironment</span>: &#123;     <span class="comment">// 词法环境</span></span><br><span class="line">    <span class="title class_">EnvironmentRecord</span>: &#123;    <span class="comment">// 环境记录</span></span><br><span class="line">      <span class="title class_">Type</span>: <span class="string">&quot;Declarative&quot;</span>,      <span class="comment">// 函数环境</span></span><br><span class="line">      <span class="comment">// 标识符绑定在这里      // 对外部环境的引用</span></span><br><span class="line">      <span class="attr">outer</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">or</span> <span class="attr">outer</span> <span class="attr">function</span> <span class="attr">environment</span> <span class="attr">reference</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">  &#125;  </span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h4><p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性</p><p>在 ES6 中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（ <code>let</code> 和 <code>const</code> ）绑定，而后者仅用于存储变量（ <code>var</code> ）绑定</p><p>举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;  </span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;  </span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">e, f</span>) &#123;  </span><br><span class="line"> <span class="keyword">var</span> g = <span class="number">20</span>;  </span><br><span class="line"> <span class="keyword">return</span> e * f * g;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = <span class="title function_">multiply</span>(<span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>执行上下文如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">GlobalExectionContext</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">ThisBinding</span>: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;  // 词法环境</span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: &quot;Object&quot;,  </span><br><span class="line">      // 标识符绑定在这里  </span><br><span class="line">      a: &lt; uninitialized &gt;,  </span><br><span class="line">      b: &lt; uninitialized &gt;,  </span><br><span class="line">      multiply: &lt; func &gt;  </span><br><span class="line">    &#125;  </span><br><span class="line">    outer: &lt;null&gt;  </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;  // 变量环境</span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: &quot;Object&quot;,  </span><br><span class="line">      // 标识符绑定在这里  </span><br><span class="line">      c: undefined,  </span><br><span class="line">    &#125;  </span><br><span class="line">    outer: &lt;null&gt;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;  </span><br><span class="line">   </span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;  </span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: &quot;Declarative&quot;,  </span><br><span class="line">      // 标识符绑定在这里  </span><br><span class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,  </span><br><span class="line">    &#125;,  </span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;  </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;  </span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: &quot;Declarative&quot;,  </span><br><span class="line">      // 标识符绑定在这里  </span><br><span class="line">      g: undefined  </span><br><span class="line">    &#125;,  </span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>留意上面的代码，<code>let</code>和<code>const</code>定义的变量<code>a</code>和<code>b</code>在创建阶段没有被赋值，但<code>var</code>声明的变量从在创建阶段被赋值为<code>undefined</code></p><p>这是因为，创建阶段，会在代码中扫描变量和函数声明，然后将函数声明存储在环境中</p><p>但变量会被初始化为<code>undefined</code>(<code>var</code>声明的情况下)和保持<code>uninitialized</code>(未初始化状态)(使用<code>let</code>和<code>const</code>声明的情况下)</p><p>这就是变量提升的实际原因</p><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>在这阶段，执行变量赋值、代码执行</p><p>如果 <code>Javascript</code> 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 <code>undefined</code> 值</p><h3 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h3><p>执行上下文出栈等待虚拟机回收执行上下文</p><h2 id="二、执行栈"><a href="#二、执行栈" class="headerlink" title="二、执行栈"></a>二、执行栈</h2><p>执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文</p><p> <img src="https://static.vue-js.com/9eda0310-74c1-11eb-ab90-d9ae814b240d.png"></p><p>当<code>Javascript</code>引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中</p><p>每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中</p><p>引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">first</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inside first function&#x27;</span>);</span><br><span class="line">  <span class="title function_">second</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Again inside first function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">second</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inside second function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">first</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inside Global Execution Context&#x27;</span>);</span><br></pre></td></tr></table></figure><p>转化成图的形式</p><p> <img src="https://static.vue-js.com/ac11a600-74c1-11eb-ab90-d9ae814b240d.png"></p><p>简单分析一下流程：</p><ul><li>创建全局上下文请压入执行栈</li><li><code>first</code>函数被调用，创建函数执行上下文并压入栈</li><li>执行<code>first</code>函数过程遇到<code>second</code>函数，再创建一个函数执行上下文并压入栈</li><li><code>second</code>函数执行完毕，对应的函数执行上下文被推出执行栈，执行下一个执行上下文<code>first</code>函数</li><li><code>first</code>函数执行完毕，对应的函数执行上下文也被推出栈中，然后执行全局上下文</li><li>所有代码执行完毕，全局上下文也会被推出栈中，程序结束</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/107552264">https://zhuanlan.zhihu.com/p/107552264</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_context_stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说你对正则表达式的理解？应用场景？</title>
      <link href="/2019/04/06/js-regexp/"/>
      <url>/2019/04/06/js-regexp/</url>
      
        <content type="html"><![CDATA[<h1 id="说说你对正则表达式的理解？应用场景？"><a href="#说说你对正则表达式的理解？应用场景？" class="headerlink" title="说说你对正则表达式的理解？应用场景？"></a>说说你对正则表达式的理解？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>正则表达式是一种用来匹配字符串的强有力的武器</p><p>它的设计思想是用一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的</p><p>在 <code>JavaScript</code>中，正则表达式也是对象，构建正则表达式有两种方式：</p><ol><li>字面量创建，其由包含在斜杠之间的模式组成</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/\d+/g</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用<code>RegExp</code>对象的构造函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\d+&quot;</span>,<span class="string">&quot;g&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rul = <span class="string">&quot;\\d+&quot;</span></span><br><span class="line"><span class="keyword">const</span> re1 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(rul,<span class="string">&quot;g&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用构建函数创建，第一个参数可以是一个变量，遇到特殊字符<code>\</code>需要使用<code>\\</code>进行转义</p><h2 id="二、匹配规则"><a href="#二、匹配规则" class="headerlink" title="二、匹配规则"></a>二、匹配规则</h2><p>常见的校验规则如下：</p><table><thead><tr><th>规则</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>转义</td></tr><tr><td>^</td><td>匹配输入的开始</td></tr><tr><td>$</td><td>匹配输入的结束</td></tr><tr><td>*</td><td>匹配前一个表达式 0 次或多次</td></tr><tr><td>+</td><td>匹配前面一个表达式 1 次或者多次。等价于 <code>&#123;1,&#125;</code></td></tr><tr><td>?</td><td>匹配前面一个表达式 0 次或者 1 次。等价于<code>&#123;0,1&#125;</code></td></tr><tr><td>.</td><td>默认匹配除换行符之外的任何单个字符</td></tr><tr><td>x(?&#x3D;y)</td><td>匹配’x’仅仅当’x’后面跟着’y’。这种叫做先行断言</td></tr><tr><td>(?&lt;&#x3D;y)x</td><td>匹配’x’仅当’x’前面是’y’.这种叫做后行断言</td></tr><tr><td>x(?!y)</td><td>仅仅当’x’后面不跟着’y’时匹配’x’，这被称为正向否定查找</td></tr><tr><td>(?&lt;!<em>y</em>)<em>x</em></td><td>仅仅当’x’前面不是’y’时匹配’x’，这被称为反向否定查找</td></tr><tr><td>x|y</td><td>匹配‘x’或者‘y’</td></tr><tr><td>{n}</td><td>n 是一个正整数，匹配了前面一个字符刚好出现了 n 次</td></tr><tr><td>{n,}</td><td>n是一个正整数，匹配前一个字符至少出现了n次</td></tr><tr><td>{n,m}</td><td>n 和 m 都是整数。匹配前面的字符至少n次，最多m次</td></tr><tr><td>[xyz]</td><td>一个字符集合。匹配方括号中的任意字符</td></tr><tr><td>[^xyz]</td><td>匹配任何没有包含在方括号中的字符</td></tr><tr><td>\b</td><td>匹配一个词的边界，例如在字母和空格之间</td></tr><tr><td>\B</td><td>匹配一个非单词边界</td></tr><tr><td>\d</td><td>匹配一个数字</td></tr><tr><td>\D</td><td>匹配一个非数字字符</td></tr><tr><td>\f</td><td>匹配一个换页符</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\s</td><td>匹配一个空白字符，包括空格、制表符、换页符和换行符</td></tr><tr><td>\S</td><td>匹配一个非空白字符</td></tr><tr><td>\w</td><td>匹配一个单字字符（字母、数字或者下划线）</td></tr><tr><td>\W</td><td>匹配一个非单字字符</td></tr></tbody></table><h3 id="正则表达式标记"><a href="#正则表达式标记" class="headerlink" title="正则表达式标记"></a>正则表达式标记</h3><table><thead><tr><th align="left">标志</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>g</code></td><td align="left">全局搜索。</td></tr><tr><td align="left"><code>i</code></td><td align="left">不区分大小写搜索。</td></tr><tr><td align="left"><code>m</code></td><td align="left">多行搜索。</td></tr><tr><td align="left"><code>s</code></td><td align="left">允许 <code>.</code> 匹配换行符。</td></tr><tr><td align="left"><code>u</code></td><td align="left">使用<code>unicode</code>码的模式进行匹配。</td></tr><tr><td align="left"><code>y</code></td><td align="left">执行“粘性(<code>sticky</code>)”搜索,匹配从目标字符串的当前位置开始。</td></tr></tbody></table><p>使用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/pattern/</span>flags;</span><br><span class="line"><span class="keyword">var</span> re = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;pattern&quot;</span>, <span class="string">&quot;flags&quot;</span>);</span><br></pre></td></tr></table></figure><p>在了解下正则表达式基本的之外，还可以掌握几个正则表达式的特性：</p><h3 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h3><p>在了解贪婪模式前，首先举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/ab&#123;1,3&#125;c/</span></span><br></pre></td></tr></table></figure><p>在匹配过程中，尝试可能的顺序是从多往少的方向去尝试。首先会尝试<code>bbb</code>，然后再看整个正则是否能匹配。不能匹配时，吐出一个<code>b</code>，即在<code>bb</code>的基础上，再继续尝试，以此重复</p><p>如果多个贪婪量词挨着，则深度优先搜索</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> regx = <span class="regexp">/(\d&#123;1,3&#125;)(\d&#123;1,3&#125;)/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( string.<span class="title function_">match</span>(reg) );</span><br><span class="line"><span class="comment">// =&gt; [&quot;12345&quot;, &quot;123&quot;, &quot;45&quot;, index: 0, input: &quot;12345&quot;]</span></span><br></pre></td></tr></table></figure><p>其中，前面的<code>\d&#123;1,3&#125;</code>匹配的是”123”，后面的<code>\d&#123;1,3&#125;</code>匹配的是”45”</p><h3 id="懒惰模式"><a href="#懒惰模式" class="headerlink" title="懒惰模式"></a>懒惰模式</h3><p>惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;1,3&#125;?)(\d&#123;1,3&#125;)/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( string.<span class="title function_">match</span>(regex) );</span><br><span class="line"><span class="comment">// =&gt; [&quot;1234&quot;, &quot;1&quot;, &quot;234&quot;, index: 0, input: &quot;12345&quot;]</span></span><br></pre></td></tr></table></figure><p>其中<code>\d&#123;1,3&#125;?</code>只匹配到一个字符”1”，而后面的<code>\d&#123;1,3&#125;</code>匹配了”234”</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>分组主要是用过<code>()</code>进行实现，比如<code>beyond&#123;3&#125;</code>，是匹配<code>d</code>字母3次。而<code>(beyond)&#123;3&#125;</code>是匹配<code>beyond</code>三次</p><p>在<code>()</code>内使用<code>|</code>达到或的效果，如<code>(abc | xxx)</code>可以匹配<code>abc</code>或者<code>xxx</code></p><p>反向引用，巧用<code>$</code>分组捕获</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;John Smith&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换名字和姓氏</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">replace</span>(<span class="regexp">/(john) (smith)/i</span>, <span class="string">&#x27;$2, $1&#x27;</span>)) <span class="comment">// Smith, John</span></span><br></pre></td></tr></table></figure><h2 id="三、匹配方法"><a href="#三、匹配方法" class="headerlink" title="三、匹配方法"></a>三、匹配方法</h2><p>正则表达式常被用于某些方法，我们可以分成两类：</p><ul><li>字符串（str）方法：<code>match</code>、<code>matchAll</code>、<code>search</code>、<code>replace</code>、<code>split</code></li><li>正则对象下（regexp）的方法：<code>test</code>、<code>exec</code></li></ul><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">exec</td><td align="left">一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。</td></tr><tr><td align="left">test</td><td align="left">一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。</td></tr><tr><td align="left">match</td><td align="left">一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。</td></tr><tr><td align="left">matchAll</td><td align="left">一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。</td></tr><tr><td align="left">search</td><td align="left">一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。</td></tr><tr><td align="left">replace</td><td align="left">一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。</td></tr><tr><td align="left">split</td><td align="left">一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 <code>String</code> 方法。</td></tr></tbody></table><h3 id="str-match-regexp"><a href="#str-match-regexp" class="headerlink" title="str.match(regexp)"></a>str.match(regexp)</h3><p><code>str.match(regexp)</code> 方法在字符串 <code>str</code> 中找到匹配 <code>regexp</code> 的字符</p><p>如果 <code>regexp</code> 不带有 <code>g</code> 标记，则它以数组的形式返回第一个匹配项，其中包含分组和属性 <code>index</code>（匹配项的位置）、<code>input</code>（输入字符串，等于 <code>str</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;I love JavaScript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = str.<span class="title function_">match</span>(<span class="regexp">/Java(Script)/</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( result[<span class="number">0</span>] );     <span class="comment">// JavaScript（完全匹配）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( result[<span class="number">1</span>] );     <span class="comment">// Script（第一个分组）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( result.<span class="property">length</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他信息：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( result.<span class="property">index</span> );  <span class="comment">// 7（匹配位置）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( result.<span class="property">input</span> );  <span class="comment">// I love JavaScript（源字符串）</span></span><br></pre></td></tr></table></figure><p>如果 <code>regexp</code> 带有 <code>g</code> 标记，则它将所有匹配项的数组作为字符串返回，而不包含分组和其他详细信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;I love JavaScript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = str.<span class="title function_">match</span>(<span class="regexp">/Java(Script)/g</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( result[<span class="number">0</span>] ); <span class="comment">// JavaScript</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( result.<span class="property">length</span> ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>如果没有匹配项，则无论是否带有标记 <code>g</code> ，都将返回 <code>null</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;I love JavaScript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = str.<span class="title function_">match</span>(<span class="regexp">/HTML/</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><h3 id="str-matchAll-regexp"><a href="#str-matchAll-regexp" class="headerlink" title="str.matchAll(regexp)"></a>str.matchAll(regexp)</h3><p>返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;test1test2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [...str.<span class="title function_">matchAll</span>(regexp)];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="str-search-regexp"><a href="#str-search-regexp" class="headerlink" title="str.search(regexp)"></a>str.search(regexp)</h3><p>返回第一个匹配项的位置，如果未找到，则返回 <code>-1</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;A drop of ink may make a million think&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">search</span>( <span class="regexp">/ink/i</span> ) ); <span class="comment">// 10（第一个匹配位置）</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是，<code>search</code> 仅查找第一个匹配项</p><h2 id="str-replace-regexp"><a href="#str-replace-regexp" class="headerlink" title="str.replace(regexp)"></a>str.replace(regexp)</h2><p>替换与正则表达式匹配的子串，并返回替换后的字符串。在不设置全局匹配<code>g</code>的时候，只替换第一个匹配成功的字符串片段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reg1=<span class="regexp">/javascript/i</span>;</span><br><span class="line"><span class="keyword">const</span> reg2=<span class="regexp">/javascript/ig</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello Javascript Javascript Javascript&#x27;</span>.<span class="title function_">replace</span>(reg1,<span class="string">&#x27;js&#x27;</span>));</span><br><span class="line"><span class="comment">//hello js Javascript Javascript</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello Javascript Javascript Javascript&#x27;</span>.<span class="title function_">replace</span>(reg2,<span class="string">&#x27;js&#x27;</span>));</span><br><span class="line"><span class="comment">//hello js js js</span></span><br></pre></td></tr></table></figure><h3 id="str-split-regexp"><a href="#str-split-regexp" class="headerlink" title="str.split(regexp)"></a>str.split(regexp)</h3><p>使用正则表达式（或子字符串）作为分隔符来分割字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;12, 34, 56&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/,\s*/</span>)) <span class="comment">// 数组 [&#x27;12&#x27;, &#x27;34&#x27;, &#x27;56&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="regexp-exec-str"><a href="#regexp-exec-str" class="headerlink" title="regexp.exec(str)"></a>regexp.exec(str)</h3><p><code>regexp.exec(str)</code> 方法返回字符串 <code>str</code> 中的 <code>regexp</code> 匹配项，与以前的方法不同，它是在正则表达式而不是字符串上调用的</p><p>根据正则表达式是否带有标志 <code>g</code>，它的行为有所不同</p><p>如果没有 <code>g</code>，那么 <code>regexp.exec(str)</code> 返回的第一个匹配与 <code>str.match(regexp)</code> 完全相同</p><p>如果有标记 <code>g</code>，调用 <code>regexp.exec(str)</code> 会返回第一个匹配项，并将紧随其后的位置保存在属性<code>regexp.lastIndex</code> 中。 下一次同样的调用会从位置 <code>regexp.lastIndex</code> 开始搜索，返回下一个匹配项，并将其后的位置保存在 <code>regexp.lastIndex</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;More about JavaScript at https://javascript.info&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/javascript/ig</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (result = regexp.<span class="title function_">exec</span>(str)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">`Found <span class="subst">$&#123;result[<span class="number">0</span>]&#125;</span> at position <span class="subst">$&#123;result.index&#125;</span>`</span> );</span><br><span class="line">  <span class="comment">// Found JavaScript at position 11</span></span><br><span class="line">  <span class="comment">// Found javascript at position 33</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="regexp-test-str"><a href="#regexp-test-str" class="headerlink" title="regexp.test(str)"></a>regexp.test(str)</h3><p>查找匹配项，然后返回 <code>true/false</code> 表示是否存在</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;I love JavaScript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个测试相同</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="regexp">/love/i</span>.<span class="title function_">test</span>(str) ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h2><p>通过上面的学习，我们对正则表达式有了一定的了解</p><p>下面再来看看正则表达式一些案例场景：</p><p>验证QQ合法性（5~15位、全是数字、不以0开头）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/^[1-9][0-9]&#123;4,14&#125;$/</span></span><br><span class="line"><span class="keyword">const</span> isvalid = patrn.<span class="title function_">exec</span>(s)</span><br></pre></td></tr></table></figure><p>校验用户账号合法性（只能输入5-20个以字母开头、可带数字、“_”、“.”的字串）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> patrn=<span class="regexp">/^[a-zA-Z]&#123;1&#125;([a-zA-Z0-9]|[._])&#123;4,19&#125;$/</span>;</span><br><span class="line"><span class="keyword">const</span> isvalid = patrn.<span class="title function_">exec</span>(s)</span><br></pre></td></tr></table></figure><p>将<code>url</code>参数解析为对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> protocol = <span class="string">&#x27;(?&lt;protocol&gt;https?:)&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&#x27;(?&lt;host&gt;(?&lt;hostname&gt;[^/#?:]+)(?::(?&lt;port&gt;\\d+))?)&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;(?&lt;pathname&gt;(?:\\/[^/#?]+)*\\/?)&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> search = <span class="string">&#x27;(?&lt;search&gt;(?:\\?[^#]*)?)&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> hash = <span class="string">&#x27;(?&lt;hash&gt;(?:#.*)?)&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`^<span class="subst">$&#123;protocol&#125;</span>\/\/<span class="subst">$&#123;host&#125;</span><span class="subst">$&#123;path&#125;</span><span class="subst">$&#123;search&#125;</span><span class="subst">$&#123;hash&#125;</span>$`</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">execURL</span>(<span class="params">url</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> result = reg.<span class="title function_">exec</span>(url);</span><br><span class="line">    <span class="keyword">if</span>(result)&#123;</span><br><span class="line">        result.<span class="property">groups</span>.<span class="property">port</span> = result.<span class="property">groups</span>.<span class="property">port</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> result.<span class="property">groups</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">protocol</span>:<span class="string">&#x27;&#x27;</span>,<span class="attr">host</span>:<span class="string">&#x27;&#x27;</span>,<span class="attr">hostname</span>:<span class="string">&#x27;&#x27;</span>,<span class="attr">port</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">pathname</span>:<span class="string">&#x27;&#x27;</span>,<span class="attr">search</span>:<span class="string">&#x27;&#x27;</span>,<span class="attr">hash</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">execURL</span>(<span class="string">&#x27;https://localhost:8080/?a=b#xxxx&#x27;</span>));</span><br><span class="line"><span class="attr">protocol</span>: <span class="string">&quot;https:&quot;</span></span><br><span class="line"><span class="attr">host</span>: <span class="string">&quot;localhost:8080&quot;</span></span><br><span class="line"><span class="attr">hostname</span>: <span class="string">&quot;localhost&quot;</span></span><br><span class="line"><span class="attr">port</span>: <span class="string">&quot;8080&quot;</span></span><br><span class="line"><span class="attr">pathname</span>: <span class="string">&quot;/&quot;</span></span><br><span class="line"><span class="attr">search</span>: <span class="string">&quot;?a=b&quot;</span></span><br><span class="line"><span class="attr">hash</span>: <span class="string">&quot;#xxxx&quot;</span></span><br></pre></td></tr></table></figure><p>再将上面的<code>search</code>和<code>hash</code>进行解析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">execUrlParams</span>(<span class="params">str</span>)&#123;</span><br><span class="line">    str = str.<span class="title function_">replace</span>(<span class="regexp">/^[#?&amp;]/</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(!str)&#123; <span class="comment">//如果正则可能配到空字符串，极有可能造成死循环，判断很重要</span></span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/(?:^|&amp;)([^&amp;=]*)=?([^&amp;]*?)(?=&amp;|$)/y</span></span><br><span class="line">    <span class="keyword">let</span> exec = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">    <span class="keyword">while</span>(exec)&#123;</span><br><span class="line">        result[exec[<span class="number">1</span>]] = exec[<span class="number">2</span>];</span><br><span class="line">        exec = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">execUrlParams</span>(<span class="string">&#x27;#&#x27;</span>));<span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">execUrlParams</span>(<span class="string">&#x27;##&#x27;</span>));<span class="comment">//&#123;&#x27;#&#x27;:&#x27;&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">execUrlParams</span>(<span class="string">&#x27;?q=3606&amp;src=srp&#x27;</span>)); <span class="comment">//&#123;q: &quot;3606&quot;, src: &quot;srp&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">execUrlParams</span>(<span class="string">&#x27;test=a=b=c&amp;&amp;==&amp;a=&#x27;</span>));<span class="comment">//&#123;test: &quot;a=b=c&quot;, &quot;&quot;: &quot;=&quot;, a: &quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_regexp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bind、call、apply 区别？如何实现一个bind?</title>
      <link href="/2019/04/06/js-bind-call-apply/"/>
      <url>/2019/04/06/js-bind-call-apply/</url>
      
        <content type="html"><![CDATA[<h1 id="bind、call、apply-区别？如何实现一个bind"><a href="#bind、call、apply-区别？如何实现一个bind" class="headerlink" title="bind、call、apply 区别？如何实现一个bind?"></a>bind、call、apply 区别？如何实现一个bind?</h1><h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p><code>call </code>、<code>apply </code>、<code>bind </code>作用是改变函数执行时的上下文，简而言之就是改变函数运行时的<code>this</code>指向</p><p>那么什么情况下需要改变<code>this</code>的指向呢？下面举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;lucy&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;martin&quot;</span>,</span><br><span class="line">    <span class="attr">say</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">say</span>(); <span class="comment">// martin，this 指向 obj 对象</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">say</span>,<span class="number">0</span>); <span class="comment">// lucy，this 指向 window 对象</span></span><br></pre></td></tr></table></figure><p>从上面可以看到，正常情况<code>say</code>方法输出<code>martin</code></p><p>但是我们把<code>say</code>放在<code>setTimeout</code>方法中，在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，这时候<code>this</code>指向<code>window</code>，所以输出<code>lucy</code></p><p>我们实际需要的是<code>this</code>指向<code>obj</code>对象，这时候就需要该改变<code>this</code>指向了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">say</span>.<span class="title function_">bind</span>(obj),<span class="number">0</span>); <span class="comment">//martin，this指向obj对象</span></span><br></pre></td></tr></table></figure><h2 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h2><p>下面再来看看<code>apply</code>、<code>call</code>、<code>bind</code>的使用</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p><code>apply</code>接受两个参数，第一个参数是<code>this</code>的指向，第二个参数是函数接受的参数，以数组的形式传入</p><p>改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">myname</span>:<span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">apply</span>(obj,[<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// this会变成传入的obj，传入的参数必须是一个数组；</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure><p>当第一个参数为<code>null</code>、<code>undefined</code>的时候，默认指向<code>window</code>(在浏览器中)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// this指向window</span></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">undefined</span>,[<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p><code>call</code>方法的第一个参数也是<code>this</code>的指向，后面传入的是一个参数列表</p><p>跟<code>apply</code>一样，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">myname</span>:<span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">call</span>(obj,<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// this会变成传入的obj，传入的参数必须是一个数组；</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure><p>同样的，当第一个参数为<code>null</code>、<code>undefined</code>的时候，默认指向<code>window</code>(在浏览器中)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.<span class="title function_">call</span>(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// this指向window</span></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">undefined</span>,[<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind方法和call很相似，第一参数也是<code>this</code>的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)</p><p>改变<code>this</code>指向后不会立即执行，而是返回一个永久改变<code>this</code>指向的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">myname</span>:<span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindFn = fn.<span class="title function_">bind</span>(obj); <span class="comment">// this 也会变成传入的obj ，bind不是立即执行需要执行一次</span></span><br><span class="line"><span class="title function_">bindFn</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// this指向obj</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从上面可以看到，<code>apply</code>、<code>call</code>、<code>bind</code>三者的区别在于：</p><ul><li>三者都可以改变函数的<code>this</code>对象指向</li><li>三者第一个参数都是<code>this</code>要指向的对象，如果如果没有这个参数或参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code></li><li>三者都可以传参，但是<code>apply</code>是数组，而<code>call</code>是参数列表，且<code>apply</code>和<code>call</code>是一次性传入参数，而<code>bind</code>可以分为多次传入</li><li><code>bind </code>是返回绑定this之后的函数，<code>apply </code>、<code>call</code> 则是立即执行</li></ul><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><p>实现<code>bind</code>的步骤，我们可以分解成为三部分：</p><ul><li>修改<code>this</code>指向</li><li>动态传递参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：只在bind中传递函数参数</span></span><br><span class="line">fn.<span class="title function_">bind</span>(obj,<span class="number">1</span>,<span class="number">2</span>)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：在bind中传递函数参数，也在返回函数中传递参数</span></span><br><span class="line">fn.<span class="title function_">bind</span>(obj,<span class="number">1</span>)(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>兼容<code>new</code>关键字</li></ul><p>整体实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">          fn = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="keyword">new</span> <span class="title function_">fn</span>(...<span class="variable language_">arguments</span>) : context, args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_bind_call_apply </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你对BOM的理解，常见的BOM对象你了解哪些？</title>
      <link href="/2019/04/05/js-bom/"/>
      <url>/2019/04/05/js-bom/</url>
      
        <content type="html"><![CDATA[<h1 id="你对BOM的理解，常见的BOM对象你了解哪些？"><a href="#你对BOM的理解，常见的BOM对象你了解哪些？" class="headerlink" title="你对BOM的理解，常见的BOM对象你了解哪些？"></a>你对BOM的理解，常见的BOM对象你了解哪些？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>BOM</code> (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象</p><p>其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率</p><p>浏览器的全部内容可以看成<code>DOM</code>，整个浏览器可以看成<code>BOM</code>。区别如下：</p><p><img src="https://static.vue-js.com/482f33e0-8089-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="二、window"><a href="#二、window" class="headerlink" title="二、window"></a>二、window</h2><p><code>Bom</code>的核心对象是<code>window</code>，它表示浏览器的一个实例</p><p>在浏览器中，<code>window</code>对象有双重角色，即是浏览器窗口的一个接口，又是全局对象</p><p>因此所有在全局作用域中声明的变量、函数都会变成<code>window</code>对象的属性和方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;js每日一题&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lookName</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>);  <span class="comment">//js每日一题</span></span><br><span class="line"><span class="title function_">lookName</span>();                <span class="comment">//js每日一题</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">lookName</span>();         <span class="comment">//js每日一题</span></span><br></pre></td></tr></table></figure><p>关于窗口控制方法如下：</p><ul><li><code>moveBy(x,y)</code>：从当前位置水平移动窗体x个像素，垂直移动窗体y个像素，x为负数，将向左移动窗体，y为负数，将向上移动窗体</li><li><code>moveTo(x,y)</code>：移动窗体左上角到相对于屏幕左上角的(x,y)点</li><li><code>resizeBy(w,h)</code>：相对窗体当前的大小，宽度调整w个像素，高度调整h个像素。如果参数为负值，将缩小窗体，反之扩大窗体</li><li><code>resizeTo(w,h)</code>：把窗体宽度调整为w个像素，高度调整为h个像素</li><li><code>scrollTo(x,y)</code>：如果有滚动条，将横向滚动条移动到相对于窗体宽度为x个像素的位置，将纵向滚动条移动到相对于窗体高度为y个像素的位置</li><li><code>scrollBy(x,y)</code>： 如果有滚动条，将横向滚动条向左移动x个像素，将纵向滚动条向下移动y个像素</li></ul><p> <code>window.open()</code> 既可以导航到一个特定的<code>url</code>，也可以打开一个新的浏览器窗口</p><p>如果 <code>window.open()</code> 传递了第二个参数，且该参数是已有窗口或者框架的名称，那么就会在目标窗口加载第一个参数指定的URL</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;htttp://www.vue3js.cn&#x27;</span>,<span class="string">&#x27;topFrame&#x27;</span>)</span><br><span class="line">==&gt; &lt; a href=<span class="string">&quot; &quot;</span> target=<span class="string">&quot;topFrame&quot;</span>&gt;&lt;/ a&gt;</span><br></pre></td></tr></table></figure><p><code>window.open()</code> 会返回新窗口的引用，也就是新窗口的 <code>window</code> 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;http://www.vue3js.cn&#x27;</span>,<span class="string">&#x27;myWin&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>window.close()</code> 仅用于通过 <code>window.open()</code> 打开的窗口</p><p>新创建的 <code>window</code> 对象有一个 <code>opener</code> 属性，该属性指向打开他的原始窗口对象</p><h2 id="三、location"><a href="#三、location" class="headerlink" title="三、location"></a>三、location</h2><p><code>url</code>地址如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents</span></span><br></pre></td></tr></table></figure><p><code>location</code>属性描述如下：</p><table><thead><tr><th>属性名</th><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>hash</td><td>“#contents”</td><td>utl中#后面的字符，没有则返回空串</td></tr><tr><td>host</td><td><a href="http://www.wrox.com/">www.wrox.com:80</a></td><td>服务器名称和端口号</td></tr><tr><td>hostname</td><td><a href="http://www.wrox.com/">www.wrox.com</a></td><td>域名，不带端口号</td></tr><tr><td>href</td><td><a href="http://www.wrox.com/WileyCDA/?q=javascript#contents">http://www.wrox.com:80/WileyCDA/?q=javascript#contents</a></td><td>完整url</td></tr><tr><td>pathname</td><td>“&#x2F;WileyCDA&#x2F;“</td><td>服务器下面的文件路径</td></tr><tr><td>port</td><td>80</td><td>url的端口号，没有则为空</td></tr><tr><td>protocol</td><td>http:</td><td>使用的协议</td></tr><tr><td>search</td><td>?q&#x3D;javascript</td><td>url的查询字符串，通常为？后面的内容</td></tr></tbody></table><p>除了 <code>hash </code>之外，只要修改<code>location</code>的一个属性，就会导致页面重新加载新<code> URL</code></p><p><code>location.reload()</code>，此方法可以重新刷新当前页面。这个方法会根据最有效的方式刷新页面，如果页面自上一次请求以来没有改变过，页面就会从浏览器缓存中重新加载</p><p>如果要强制从服务器中重新加载，传递一个参数<code>true</code>即可</p><h2 id="四、navigator"><a href="#四、navigator" class="headerlink" title="四、navigator"></a>四、navigator</h2><p><code>navigator</code> 对象主要用来获取浏览器的属性，区分浏览器类型。属性较多，且兼容性比较复杂</p><p>下表列出了<code>navigator</code>对象接口定义的属性和方法：</p><p> <img src="https://static.vue-js.com/6797ab40-8089-11eb-ab90-d9ae814b240d.png"></p><p> <img src="https://static.vue-js.com/74096620-8089-11eb-ab90-d9ae814b240d.png"></p><h2 id="五、screen"><a href="#五、screen" class="headerlink" title="五、screen"></a>五、screen</h2><p>保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度</p><p> <img src="https://static.vue-js.com/7d6b21e0-8089-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="六、history"><a href="#六、history" class="headerlink" title="六、history"></a>六、history</h2><p><code>history</code>对象主要用来操作浏览器<code>URL</code>的历史记录，可以通过参数向前，向后，或者向指定<code>URL</code>跳转</p><p>常用的属性如下：</p><ul><li><code>history.go()</code></li></ul><p>接收一个整数数字或者字符串参数：向最近的一个记录中包含指定字符串的页面跳转，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">go</span>(<span class="string">&#x27;maixaofei.com&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当参数为整数数字的时候，正数表示向前跳转指定的页面，负数为向后跳转指定的页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">go</span>(<span class="number">3</span>) <span class="comment">//向前跳转三个记录</span></span><br><span class="line">history.<span class="title function_">go</span>(-<span class="number">1</span>) <span class="comment">//向后跳转一个记录</span></span><br></pre></td></tr></table></figure><ul><li><code>history.forward()</code>：向前跳转一个页面</li><li><code>history.back()</code>：向后跳转一个页面</li><li><code>history.length</code>：获取历史记录数</li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_bom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript字符串的常用方法有哪些？</title>
      <link href="/2019/03/16/js-string-api/"/>
      <url>/2019/03/16/js-string-api/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript字符串的常用方法有哪些？"><a href="#JavaScript字符串的常用方法有哪些？" class="headerlink" title="JavaScript字符串的常用方法有哪些？"></a>JavaScript字符串的常用方法有哪些？</h1><h2 id="一、操作方法"><a href="#一、操作方法" class="headerlink" title="一、操作方法"></a>一、操作方法</h2><p>我们也可将字符串常用的操作方法归纳为增、删、改、查，需要知道字符串的特点是一旦创建了，就不可变</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>这里增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作</p><p>除了常用<code>+</code>以及<code>$&#123;&#125;</code>进行字符串拼接之外，还可通过<code>concat</code></p><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>用于将一个或多个字符串拼接成一个新字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.<span class="title function_">concat</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作</p><p>常见的有：</p><ul><li>slice()</li><li>substr()</li><li>substring()</li></ul><p>这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo worl&quot;</span></span><br></pre></td></tr></table></figure><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作</p><p>常见的有：</p><ul><li><p>trim()、trimLeft()、trimRight()</p></li><li><p>repeat()</p></li><li><p>padStart()、padEnd()</p></li><li><p>toLowerCase()、 toUpperCase()</p></li></ul><h4 id="trim-、trimLeft-、trimRight"><a href="#trim-、trimLeft-、trimRight" class="headerlink" title="trim()、trimLeft()、trimRight()"></a>trim()、trimLeft()、trimRight()</h4><p>删除前、后或前后所有空格符，再返回新的字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot; hello world &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> trimmedStringValue = stringValue.<span class="title function_">trim</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot; hello world &quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trimmedStringValue); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;na &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> copyResult = stringValue.<span class="title function_">repeat</span>(<span class="number">2</span>) <span class="comment">// na na </span></span><br></pre></td></tr></table></figure><h4 id="padEnd"><a href="#padEnd" class="headerlink" title="padEnd()"></a>padEnd()</h4><p>复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">6</span>)); <span class="comment">// &quot; foo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;......foo&quot;</span></span><br></pre></td></tr></table></figure><h3 id="toLowerCase-、-toUpperCase"><a href="#toLowerCase-、-toUpperCase" class="headerlink" title="toLowerCase()、 toUpperCase()"></a>toLowerCase()、 toUpperCase()</h3><p>大小写转化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">toUpperCase</span>()); <span class="comment">// &quot;HELLO WORLD&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">toLowerCase</span>()); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>除了通过索引的方式获取字符串的值，还可通过：</p><ul><li><p>chatAt()</p></li><li><p>indexOf()</p></li><li><p>startWith()</p></li><li><p>includes()</p></li></ul><h4 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h4><p>返回给定索引位置的字符，由传给方法的整数参数指定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">2</span>)); <span class="comment">// &quot;c&quot;</span></span><br></pre></td></tr></table></figure><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h4><p>从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="startWith-、includes"><a href="#startWith-、includes" class="headerlink" title="startWith()、includes()"></a>startWith()、includes()</h4><p>从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;qux&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="二、转换方法"><a href="#二、转换方法" class="headerlink" title="二、转换方法"></a>二、转换方法</h2><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>把字符串按照指定的分割符，拆分成数组中的每一项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;12+23+34&quot;</span></span><br><span class="line"><span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&quot;+&quot;</span>) <span class="comment">// [12,23,34]</span></span><br></pre></td></tr></table></figure><h2 id="三、模板匹配方法"><a href="#三、模板匹配方法" class="headerlink" title="三、模板匹配方法"></a>三、模板匹配方法</h2><p>针对正则表达式，字符串设计了几个方法：</p><ul><li>match()</li><li>search()</li><li>replace()</li></ul><h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><p>接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象，返回数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> matches = text.<span class="title function_">match</span>(pattern);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// &quot;cat&quot;</span></span><br></pre></td></tr></table></figure><h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象，找到则返回匹配索引，否则返回 -1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pos = text.<span class="title function_">search</span>(<span class="regexp">/at/</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pos); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = text.<span class="title function_">replace</span>(<span class="string">&quot;at&quot;</span>, <span class="string">&quot;ond&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;cond, bat, sat, fat&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_string_api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的常用方法有哪些？</title>
      <link href="/2019/02/16/js-array-api/"/>
      <url>/2019/02/16/js-array-api/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的常用方法有哪些？"><a href="#数组的常用方法有哪些？" class="headerlink" title="数组的常用方法有哪些？"></a>数组的常用方法有哪些？</h1><h2 id="一、操作方法"><a href="#一、操作方法" class="headerlink" title="一、操作方法"></a>一、操作方法</h2><p>数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生影响，哪些方法不会</p><p>下面对数组常用的操作方法做一个归纳</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响</p><ul><li>push()</li><li>unshift()</li><li>splice()</li><li>concat()</li></ul><h4 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h4><p><code>push()</code>方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = []; <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 推入两项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><p>unshift()在数组开头添加任意多个值，然后返回新的数组长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">unshift</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 从数组开头推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><p>传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors) <span class="comment">// red,yellow,orange,green,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed) <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p>首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">&quot;yellow&quot;</span>, [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>下面三种都会影响原数组，最后一项不影响原数组：</p><ul><li>pop()</li><li>shift()</li><li>splice()</li><li>slice()</li></ul><h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p> <code>pop()</code> 方法用于删除数组的最后一项，同时减少数组的<code> length</code> 值，返回被删除的项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>(); <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// green</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><p><code>shift()</code>方法用于删除数组的第一项，同时减少数组的<code> length</code> 值，返回被删除的项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">shift</span>(); <span class="comment">// 取得第一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// red</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="splice-1"><a href="#splice-1" class="headerlink" title="splice()"></a>splice()</h4><p>传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// green,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed); <span class="comment">// red，只有一个元素的数组</span></span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p> slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors)   <span class="comment">// red,green,blue,yellow,purple</span></span><br><span class="line">concole.<span class="title function_">log</span>(colors2); <span class="comment">// green,blue,yellow,purple</span></span><br><span class="line">concole.<span class="title function_">log</span>(colors3); <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></table></figure><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p>即修改原来数组的内容，常用<code>splice</code></p><h4 id="splice-2"><a href="#splice-2" class="headerlink" title="splice()"></a>splice()</h4><p>传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;purple&quot;</span>); <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// red,red,purple,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed); <span class="comment">// green，只有一个元素的数组</span></span><br></pre></td></tr></table></figure><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>即查找元素，返回元素坐标或者元素值</p><ul><li>indexOf()</li><li>includes()</li><li>find()</li></ul><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h4><p>返回要查找的元素在数组中的位置，如果没找到则返回 -1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h4><p>返回要查找的元素在数组中的位置，找到返回<code>true</code>，否则<code>false</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">includes</span>(<span class="number">4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>返回第一个匹配的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">27</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line">people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>) <span class="comment">// // &#123;name: &quot;Matt&quot;, age: 27&#125;</span></span><br></pre></td></tr></table></figure><h2 id="二、排序方法"><a href="#二、排序方法" class="headerlink" title="二、排序方法"></a>二、排序方法</h2><p>数组有两个方法可以用来对元素重新排序：</p><ul><li>reverse() </li><li>sort()</li></ul><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>顾名思义，将数组元素方向反转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>sort()方法接受一个比较函数，用于判断哪个值应该排在前面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.<span class="title function_">sort</span>(compare);</span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 0,1,5,10,15</span></span><br></pre></td></tr></table></figure><h2 id="三、转换方法"><a href="#三、转换方法" class="headerlink" title="三、转换方法"></a>三、转换方法</h2><p>常见的转换方法有：</p><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>)); <span class="comment">// red,green,blue</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&quot;||&quot;</span>)); <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure><h2 id="四、迭代方法"><a href="#四、迭代方法" class="headerlink" title="四、迭代方法"></a>四、迭代方法</h2><p>常用来迭代数组的方法（都不改变原数组）有如下：</p><ul><li>some()</li><li>every()</li><li>forEach()</li><li>filter()</li><li>map()</li></ul><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p>对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> someResult = numbers.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(someResult) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p>对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> everyResult = numbers.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(everyResult) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>对数组每一项都运行传入的函数，没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>对数组每一项都运行传入的函数，函数返回 <code>true</code> 的项会组成数组之后返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filterResult); <span class="comment">// 3,4,5,4,3</span></span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapResult) <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_array_api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax原理是什么？如何实现？</title>
      <link href="/2019/02/06/js-ajax/"/>
      <url>/2019/02/06/js-ajax/</url>
      
        <content type="html"><![CDATA[<h1 id="ajax原理是什么？如何实现？"><a href="#ajax原理是什么？如何实现？" class="headerlink" title="ajax原理是什么？如何实现？"></a>ajax原理是什么？如何实现？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>AJAX </code>全称(Async Javascript and XML)</p><p>即异步的<code> JavaScript</code> 和<code> XML</code>，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页</p><p><code>Ajax</code>的原理简单来说通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>JavaScript</code>来操作<code>DOM</code>而更新页面</p><p>流程图如下：</p><p> <img src="https://static.vue-js.com/af42de10-7b2a-11eb-85f6-6fac77c0c9b3.png"></p><p>下面举个例子：</p><p>领导想找小李汇报一下工作，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作</p><p><code>Ajax</code>请求数据流程与“领导想找小李汇报一下工作”类似，上述秘书就相当于<code>XMLHttpRequest</code>对象，领导相当于浏览器，响应数据相当于小李</p><p>浏览器可以发送<code>HTTP</code>请求后，接着做其他事情，等收到<code>XHR</code>返回来的数据再进行操作</p><h2 id="二、实现过程"><a href="#二、实现过程" class="headerlink" title="二、实现过程"></a>二、实现过程</h2><p>实现 <code>Ajax </code>异步交互需要服务器逻辑进行配合，需要完成以下步骤：</p><ul><li><p>创建 <code>Ajax </code>的核心对象 <code>XMLHttpRequest </code>对象</p></li><li><p>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务端建立连接</p></li><li><p>构建请求所需的数据内容，并通过<code> XMLHttpRequest</code> 对象的 <code>send()</code> 方法发送给服务器端</p></li><li><p>通过 <code>XMLHttpRequest</code> 对象提供的 <code>onreadystatechange</code> 事件监听服务器端你的通信状态</p></li><li><p>接受并处理服务端向客户端响应的数据结果</p></li><li><p>将处理结果更新到 <code>HTML </code>页面中</p></li></ul><h3 id="创建XMLHttpRequest对象"><a href="#创建XMLHttpRequest对象" class="headerlink" title="创建XMLHttpRequest对象"></a>创建XMLHttpRequest对象</h3><p>通过<code>XMLHttpRequest()</code> 构造函数用于初始化一个 <code>XMLHttpRequest</code> 实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure><h3 id="与服务器建立连接"><a href="#与服务器建立连接" class="headerlink" title="与服务器建立连接"></a>与服务器建立连接</h3><p>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务器建立连接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(method, url, [<span class="keyword">async</span>][, user][, password])</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p><code>method</code>：表示当前的请求方式，常见的有<code>GET</code>、<code>POST</code></p></li><li><p><code>url</code>：服务端地址</p></li><li><p><code>async</code>：布尔值，表示是否异步执行操作，默认为<code>true</code></p></li><li><p><code>user</code>: 可选的用户名用于认证用途；默认为&#96;null</p></li><li><p><code>password</code>: 可选的密码用于认证用途，默认为&#96;null</p></li></ul><h3 id="给服务端发送数据"><a href="#给服务端发送数据" class="headerlink" title="给服务端发送数据"></a>给服务端发送数据</h3><p>通过 <code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法，将客户端页面的数据发送给服务端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>([body])</span><br></pre></td></tr></table></figure><p><code>body</code>: 在 <code>XHR</code> 请求中要发送的数据体，如果不传递数据则为 <code>null</code></p><p>如果使用<code>GET</code>请求发送数据的时候，需要注意如下：</p><ul><li>将请求数据添加到<code>open()</code>方法中的<code>url</code>地址中</li><li>发送请求数据中的<code>send()</code>方法中参数设置为<code>null</code></li></ul><h3 id="绑定onreadystatechange事件"><a href="#绑定onreadystatechange事件" class="headerlink" title="绑定onreadystatechange事件"></a>绑定onreadystatechange事件</h3><p><code>onreadystatechange</code> 事件用于监听服务器端的通信状态，主要监听的属性为<code>XMLHttpRequest.readyState</code> ,</p><p>关于<code>XMLHttpRequest.readyState</code>属性有五个状态，如下图显示</p><p><img src="https://static.vue-js.com/9782fc90-7b31-11eb-ab90-d9ae814b240d.png"></p><p>只要 <code>readyState </code>属性值一变化，就会触发一次 <code>readystatechange</code> 事件</p><p><code>XMLHttpRequest.responseText</code>属性用于接收服务器端的响应结果</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(request.<span class="property">readyState</span> === <span class="number">4</span>)&#123; <span class="comment">// 整个请求过程完毕</span></span><br><span class="line">        <span class="keyword">if</span>(request.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; request.<span class="property">status</span> &lt;= <span class="number">300</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">responseText</span>) <span class="comment">// 服务端返回的结果</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(request.<span class="property">status</span> &gt;=<span class="number">400</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;错误信息：&quot;</span> + request.<span class="property">status</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">request.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;http://xxxx&#x27;</span>)</span><br><span class="line">request.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure><h2 id="三、封装"><a href="#三、封装" class="headerlink" title="三、封装"></a>三、封装</h2><p>通过上面对<code>XMLHttpRequest </code>对象的了解，下面来封装一个简单的<code>ajax</code>请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装一个ajax请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="comment">//创建XMLHttpRequest对象</span></span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化参数的内容</span></span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    options.<span class="property">type</span> = (options.<span class="property">type</span> || <span class="string">&#x27;GET&#x27;</span>).<span class="title function_">toUpperCase</span>()</span><br><span class="line">    options.<span class="property">dataType</span> = options.<span class="property">dataType</span> || <span class="string">&#x27;json&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> params = options.<span class="property">data</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">type</span> === <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, options.<span class="property">url</span> + <span class="string">&#x27;?&#x27;</span> + params, <span class="literal">true</span>)</span><br><span class="line">        xhr.<span class="title function_">send</span>(<span class="literal">null</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.<span class="property">type</span> === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, options.<span class="property">url</span>, <span class="literal">true</span>)</span><br><span class="line">        xhr.<span class="title function_">send</span>(params)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收请求</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> status = xhr.<span class="property">status</span></span><br><span class="line">            <span class="keyword">if</span> (status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                options.<span class="property">success</span> &amp;&amp; options.<span class="title function_">success</span>(xhr.<span class="property">responseText</span>, xhr.<span class="property">responseXML</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                options.<span class="property">fail</span> &amp;&amp; options.<span class="title function_">fail</span>(status)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;https://xxxx&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">text,xml</span>)&#123;<span class="comment">//请求成功后的回调函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(text)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="keyword">function</span>(<span class="params">status</span>)&#123;<span class="comment">////请求失败后的回调函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(status)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typeof 与 instanceof 区别</title>
      <link href="/2019/01/09/js-typeof-instanceof/"/>
      <url>/2019/01/09/js-typeof-instanceof/</url>
      
        <content type="html"><![CDATA[<h1 id="typeof-与-instanceof-区别"><a href="#typeof-与-instanceof-区别" class="headerlink" title="typeof 与 instanceof 区别"></a>typeof 与 instanceof 区别</h1><h2 id="一、typeof"><a href="#一、typeof" class="headerlink" title="一、typeof"></a>一、typeof</h2><p><code>typeof</code> 操作符返回一个字符串，表示未经计算的操作数的类型</p><p>使用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> operand</span><br><span class="line"><span class="title function_">typeof</span>(operand)</span><br></pre></td></tr></table></figure><p><code>operand</code>表示对象或原始值的表达式，其类型将被返回</p><p>举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="property">log</span> <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure><p>从上面例子，前6个都是基础数据类型。虽然<code>typeof null</code>为<code>object</code>，但这只是<code> JavaScript</code> 存在的一个悠久 <code>Bug</code>，不代表<code>null </code>就是引用数据类型，并且<code>null </code>本身也不是对象</p><p>所以，<code>null </code>在 <code>typeof </code>之后返回的是有问题的结果，不能作为判断<code>null</code>的方法。如果你需要在 <code>if</code> 语句中判断是否为 <code>null</code>，直接通过<code>===null</code>来判断就好</p><p>同时，可以发现引用类型数据，用<code>typeof</code>来判断的话，除了<code>function</code>会被识别出来之外，其余的都输出<code>object</code></p><p>如果我们想要判断一个变量是否存在，可以使用<code>typeof</code>：(不能使用<code>if(a)</code>， 若<code>a</code>未声明，则报错)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> a != <span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">//变量存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、instanceof"><a href="#二、instanceof" class="headerlink" title="二、instanceof"></a>二、instanceof</h2><p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</p><p>使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> constructor</span><br></pre></td></tr></table></figure><p><code>object</code>为实例对象，<code>constructor</code>为构造函数</p><p>构造函数通过<code>new</code>可以实例对象，<code>instanceof </code>能判断这个对象是否是之前那个构造函数生成的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构建函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Car</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> benz = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line">benz <span class="keyword">instanceof</span> <span class="title class_">Car</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">car <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">str <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>关于<code>instanceof</code>的实现原理，可以参考下面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里先用typeof来判断基础数据类型，如果是，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> left !== <span class="string">&#x27;object&#x27;</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// getProtypeOf是Object对象自带的API，能够拿到参数的原型对象</span></span><br><span class="line">    <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;                  </span><br><span class="line">        <span class="keyword">if</span>(proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(proto === right.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//找到相同原型对象，返回true</span></span><br><span class="line">        proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeof</span>(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是顺着原型链去找，直到找到相同的原型对象，返回<code>true</code>，否则为<code>false</code></p><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p><code>typeof</code>与<code>instanceof</code>都是判断数据类型的方法，区别如下：</p><ul><li><p><code>typeof</code>会返回一个变量的基本类型，<code>instanceof</code>返回的是一个布尔值</p></li><li><p><code>instanceof</code> 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</p></li><li><p>而<code> typeof</code> 也存在弊端，它虽然可以判断基础数据类型（<code>null</code> 除外），但是引用数据类型中，除了<code> function</code> 类型以外，其他的也无法判断</p></li></ul><p>可以看到，上述两种方法都有弊端，并不能满足所有场景的需求</p><p>如果需要通用检测数据类型，可以采用<code>Object.prototype.toString</code>，调用该方法，统一返回格式<code>“[object Xxx]” </code>的字符串</p><p>如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>(&#123;&#125;)       <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)  <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>)    <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;1&#x27;</span>)  <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>)  <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)  <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>)   <span class="comment">//&quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">//&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/123/g</span>)    <span class="comment">//&quot;[object RegExp]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">//&quot;[object Date]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])       <span class="comment">//&quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="variable language_">document</span>)  <span class="comment">//&quot;[object HTMLDocument]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="variable language_">window</span>)   <span class="comment">//&quot;[object Window]&quot;</span></span><br></pre></td></tr></table></figure><p>了解了<code>toString</code>的基本用法，下面就实现一个全局通用的数据类型判断方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> type  = <span class="keyword">typeof</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (type !== <span class="string">&quot;object&quot;</span>) &#123;    <span class="comment">// 先进行typeof判断，如果是基础数据类型，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">replace</span>(<span class="regexp">/^\[object (\S+)\]$/</span>, <span class="string">&#x27;$1&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getType</span>([])     <span class="comment">// &quot;Array&quot; typeof []是object，因此toString返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="string">&#x27;123&#x27;</span>)  <span class="comment">// &quot;string&quot; typeof 直接返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="variable language_">window</span>) <span class="comment">// &quot;Window&quot; toString返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="literal">null</span>)   <span class="comment">// &quot;Null&quot;首字母大写，typeof null是object，需toString来判断</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="literal">undefined</span>)   <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line"><span class="title function_">getType</span>()            <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;) <span class="comment">// &quot;function&quot; typeof能判断，因此首字母小写</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="regexp">/123/g</span>)      <span class="comment">//&quot;RegExp&quot; toString返回</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_typeof_instanceof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈 JavaScript 中的类型转换机制</title>
      <link href="/2019/01/06/js-type-conversion/"/>
      <url>/2019/01/06/js-type-conversion/</url>
      
        <content type="html"><![CDATA[<h1 id="面试官：谈谈-JavaScript-中的类型转换机制"><a href="#面试官：谈谈-JavaScript-中的类型转换机制" class="headerlink" title="面试官：谈谈 JavaScript 中的类型转换机制"></a>面试官：谈谈 JavaScript 中的类型转换机制</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>前面我们讲到，<code>JS </code>中有六种简单数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>string</code>、<code>number</code>、<code>symbol</code>，以及引用类型：<code>object</code></p><p>但是我们在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = y ? <span class="number">1</span> : a;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>x</code>的值在编译阶段是无法获取的，只有等到程序运行时才能知道</p><p>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制</p><p>常见的类型转换有：</p><ul><li>强制转换（显示转换）</li><li>自动转换（隐式转换）</li></ul><h2 id="二、显示转换"><a href="#二、显示转换" class="headerlink" title="二、显示转换"></a>二、显示转换</h2><p>显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：</p><ul><li>Number()</li><li>parseInt()</li><li>String()</li><li>Boolean()</li></ul><h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p>将任意类型的值转化为数值</p><p>先给出类型转换规则：</p><p> <img src="https://static.vue-js.com/915b7300-6692-11eb-ab90-d9ae814b240d.png"></p><p>实践一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="number">324</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;324&#x27;</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果不可以被解析为数值，返回 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;324abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空字符串转为0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值：true 转成 1，false 转成 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined：转成 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null：转成0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象：通常转换成NaN(除了只包含单个数值的数组)</span></span><br><span class="line"><span class="title class_">Number</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">5</span>]) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>从上面可以看到，<code>Number</code>转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code></p><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><p><code>parseInt</code>相比<code>Number</code>，就没那么严格了，<code>parseInt</code>函数逐个解析字符，遇到不能转换的字符就停下来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;32a3&#x27;</span>) <span class="comment">//32</span></span><br></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><p>可以将任意类型的值转化成字符串</p><p>给出转换规则图：</p><p>   <img src="https://static.vue-js.com/48dd8eb0-6692-11eb-85f6-6fac77c0c9b3.png"></p><p>实践一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值：转为相应的字符串</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">1</span>) <span class="comment">// &quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串：转换后还是原来的值</span></span><br><span class="line"><span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) <span class="comment">// &quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//undefined：转为字符串&quot;undefined&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//null：转为字符串&quot;null&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>) <span class="comment">// &quot;null&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="title class_">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><p>可以将任意类型的值转为布尔值，转换规则如下：</p><p> <img src="https://static.vue-js.com/53bdad10-6692-11eb-ab90-d9ae814b240d.png"></p><p>实践一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="title class_">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="三、隐式转换"><a href="#三、隐式转换" class="headerlink" title="三、隐式转换"></a>三、隐式转换</h2><p>在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？</p><p>我们这里可以归纳为两种情况发生隐式转换的场景：</p><ul><li>比较运算（<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>）、<code>if</code>、<code>while</code>需要布尔值地方</li><li>算术运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）</li></ul><p>除了上面的场景，还要求运算符两边的操作数不是同一类型</p><h3 id="自动转换为布尔值"><a href="#自动转换为布尔值" class="headerlink" title="自动转换为布尔值"></a>自动转换为布尔值</h3><p>在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用<code>Boolean</code>函数</p><p>可以得出个小结：</p><ul><li>undefined </li><li>null </li><li>false </li><li>+0 </li><li>-0</li><li>NaN</li><li>“”</li></ul><p>除了上面几种会被转化成<code>false</code>，其他都换被转化成<code>true</code></p><h3 id="自动转换成字符串"><a href="#自动转换成字符串" class="headerlink" title="自动转换成字符串"></a>自动转换成字符串</h3><p>遇到预期为字符串的地方，就会将非字符串的值自动转为字符串</p><p>具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串</p><p>常发生在<code>+</code>运算中，一旦存在字符串，则会进行字符串拼接操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="number">1</span> <span class="comment">// &#x27;51&#x27;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">true</span> <span class="comment">// &quot;5true&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">false</span> <span class="comment">// &quot;5false&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + &#123;&#125; <span class="comment">// &quot;5[object Object]&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + [] <span class="comment">// &quot;5&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125; <span class="comment">// &quot;5function ()&#123;&#125;&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">undefined</span> <span class="comment">// &quot;5undefined&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">null</span> <span class="comment">// &quot;5null&quot;</span></span><br></pre></td></tr></table></figure><h3 id="自动转换成数值"><a href="#自动转换成数值" class="headerlink" title="自动转换成数值"></a>自动转换成数值</h3><p>除了<code>+</code>有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;2&#x27;</span> <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * <span class="string">&#x27;2&#x27;</span> <span class="comment">// 10</span></span><br><span class="line"><span class="literal">true</span> - <span class="number">1</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> - <span class="number">1</span> <span class="comment">// -1</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> - <span class="number">1</span>   <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * []    <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> / <span class="string">&#x27;5&#x27;</span> <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> - <span class="number">1</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> + <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="number">1</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p><code>null</code>转为数值时，值为<code>0</code> 。<code>undefined</code>转为数值时，值为<code>NaN</code></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_type_conversion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>== 和 ===区别，分别在什么情况使用</title>
      <link href="/2019/01/02/js/"/>
      <url>/2019/01/02/js/</url>
      
        <content type="html"><![CDATA[<h1 id="和-区别，分别在什么情况使用"><a href="#和-区别，分别在什么情况使用" class="headerlink" title="&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别，分别在什么情况使用"></a>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别，分别在什么情况使用</h1><h2 id="一、等于操作符"><a href="#一、等于操作符" class="headerlink" title="一、等于操作符"></a>一、等于操作符</h2><p>等于操作符用两个等于号（ &#x3D;&#x3D; ）表示，如果操作数相等，则会返回 <code>true</code></p><p>前面文章，我们提到在<code>JavaScript</code>中存在隐式转换。等于操作符（&#x3D;&#x3D;）在比较中会先进行类型转换，再确定操作数是否相等</p><p>遵循以下规则：</p><p>如果任一操作数是布尔值，则将其转换为数值再比较是否相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="literal">true</span> == <span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> == <span class="number">55</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果一个操作数是对象，另一个操作数不是，则调用对象的 <code>valueOf() </code>方法取得其原始值，再根据前面的规则进行比较</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">valueOf</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = (obj == <span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>null </code>和<code>undefined</code>相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="literal">null</span> == <span class="literal">undefined</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果有任一操作数是 <code>NaN</code> ，则相等操作符返回 <code>false</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="title class_">NaN</span> == <span class="title class_">NaN</span> ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回<code>true</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;name:&quot;xxx&quot;&#125;</span><br><span class="line">let obj2 = &#123;name:&quot;xxx&quot;&#125;</span><br><span class="line">let result1 = (obj1 == obj2 ); // false</span><br></pre></td></tr></table></figure><p>下面进一步做个小结：</p><ul><li><p>两个都为简单类型，字符串和布尔值都会转换成数值，再比较</p></li><li><p>简单类型与引用类型比较，对象转化成其原始类型的值，再比较</p></li><li><p>两个都为引用类型，则比较它们是否指向同一个对象</p></li><li><p>null 和 undefined 相等</p></li><li><p>存在 NaN 则返回 false</p></li></ul><h2 id="二、全等操作符"><a href="#二、全等操作符" class="headerlink" title="二、全等操作符"></a>二、全等操作符</h2><p>全等操作符由 3 个等于号（ &#x3D;&#x3D;&#x3D; ）表示，只有两个操作数在不转换的前提下相等才返回 <code>true</code>。即类型相同，值也需相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> === <span class="number">55</span>); <span class="comment">// false，不相等，因为数据类型不同</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="number">55</span> === <span class="number">55</span>); <span class="comment">// true，相等，因为数据类型相同值也相同</span></span><br></pre></td></tr></table></figure><p><code>undefined</code> 和 <code>null</code> 与自身严格相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="literal">null</span> === <span class="literal">null</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="literal">undefined</span> === <span class="literal">undefined</span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>相等操作符（&#x3D;&#x3D;）会做类型转换，再进行值的比较，全等运算符不会做类型转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> === <span class="number">55</span>); <span class="comment">// false，不相等，因为数据类型不同</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="number">55</span> === <span class="number">55</span>); <span class="comment">// true，相等，因为数据类型相同值也相同</span></span><br></pre></td></tr></table></figure><p><code>null</code> 和 <code>undefined</code> 比较，相等操作符（&#x3D;&#x3D;）为<code>true</code>，全等为<code>false</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="literal">null</span> == <span class="literal">undefined</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="literal">null</span>  === <span class="literal">undefined</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="string">&#x27;0&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;0&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;false&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;0&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; \t\r\n&#x27;</span> == <span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但在比较<code>null</code>的情况的时候，我们一般使用相等操作符<code>==</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(obj.<span class="property">x</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);  <span class="comment">//执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等同于下面写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj.<span class="property">x</span> === <span class="literal">null</span> || obj.<span class="property">x</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用相等操作符（&#x3D;&#x3D;）的写法明显更加简洁了</p><p>所以，除了在比较对象属性为<code>null</code>或者<code>undefined</code>的情况下，我们可以使用相等操作符（&#x3D;&#x3D;），其他情况建议一律使用全等操作符（&#x3D;&#x3D;&#x3D;）</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_==_=== </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是响应式设计？响应式设计的基本原理是什么？如何做？</title>
      <link href="/2018/12/21/css-responsive-layout/"/>
      <url>/2018/12/21/css-responsive-layout/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是响应式设计？响应式设计的基本原理是什么？如何做？"><a href="#什么是响应式设计？响应式设计的基本原理是什么？如何做？" class="headerlink" title="什么是响应式设计？响应式设计的基本原理是什么？如何做？"></a>什么是响应式设计？响应式设计的基本原理是什么？如何做？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>响应式网站设计（Responsive Web design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整</p><p>描述响应式界面最著名的一句话就是“Content is like water”</p><p>大白话便是“如果将屏幕看作容器，那么内容就像水一样”</p><p>响应式网站常见特点：</p><ul><li><p>同时适配PC + 平板 + 手机等</p></li><li><p>标签导航在接近手持终端设备时改变为经典的抽屉式导航</p></li><li><p>网站的布局会根据视口来调整模块的大小和位置</p></li></ul><p> <img src="https://static.vue-js.com/ae68be30-9dba-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><p>响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有<code>meta</code>声明<code>viewport</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;</span></span></span><br></pre></td></tr></table></figure><p>属性对应如下：</p><ul><li><p>width&#x3D;device-width: 是自适应手机屏幕的尺寸宽度</p></li><li><p>maximum-scale:是缩放比例的最大值</p></li><li><p>inital-scale:是缩放的初始化</p></li><li><p>user-scalable:是用户的可以缩放的操作</p></li></ul><p>实现响应式布局的方式有如下：</p><ul><li>媒体查询</li><li>百分比</li><li>vw&#x2F;vh</li><li>rem</li></ul><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p><code>CSS3 </code>中的增加了更多的媒体查询，就像<code>if</code>条件表达式一样，我们可以设置不同类型的媒体条件，并根据对应的条件，给相应符合条件的媒体调用相对应的样式表</p><p>使用<code>@Media</code>查询，可以针对不同的媒体类型定义不同的样式，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1920px</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>当视口在375px - 600px之间，设置特定字体大小18px</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen (<span class="attribute">min-width</span>: <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局，比如我们为不同分辨率的屏幕，设置不同的背景图片</p><p>比如给小屏幕手机设置@2x图，为大屏幕手机设置@3x图，通过媒体查询就能很方便的实现</p><h3 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h3><p>通过百分比单位 “ % “ 来实现响应式的效果</p><p> 比如当浏览器的宽度或者高度发生变化时，通过百分比单位，可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果</p><p><code>height</code>、<code>width</code>属性的百分比依托于父标签的宽高，但是其他盒子属性则不完全依赖父元素：</p><ul><li><p>子元素的top&#x2F;left和bottom&#x2F;right如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度&#x2F;宽度</p></li><li><p>子元素的padding如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关。</p></li><li><p>子元素的margin如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的width</p></li><li><p>border-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度</p></li></ul><p>可以看到每个属性都使用百分比，会照成布局的复杂度，所以不建议使用百分比来实现响应式</p><h3 id="vw-vh"><a href="#vw-vh" class="headerlink" title="vw&#x2F;vh"></a>vw&#x2F;vh</h3><p><code>vw</code>表示相对于视图窗口的宽度，<code>vh</code>表示相对于视图窗口高度。 任意层级元素，在使用<code>vw</code>单位的情况下，<code>1vw</code>都等于视图宽度的百分之一</p><p>与百分比布局很相似，在以前文章提过与<code>%</code>的区别，这里就不再展开述说</p><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>在以前也讲到，<code>rem</code>是相对于根元素<code>html</code>的<code>font-size</code>属性，默认情况下浏览器字体大小为<code>16px</code>，此时<code>1rem = 16px</code></p><p>可以利用前面提到的媒体查询，针对不同设备分辨率改变<code>font-size</code>的值，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">414px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">375px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">320px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更准确监听设备可视窗口变化，我们可以在<code>css</code>之前插入<code>script</code>标签，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态为根元素设置字体大小</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">init</span> () &#123;</span><br><span class="line">    <span class="comment">// 获取屏幕宽度</span></span><br><span class="line">    <span class="keyword">var</span> width = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line">    <span class="comment">// 设置根元素字体大小。此时为宽的10等分</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span> = width / <span class="number">10</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首次加载应用，设置一次</span></span><br><span class="line"><span class="title function_">init</span>()</span><br><span class="line"><span class="comment">// 监听手机旋转的事件的时机，重新设置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;orientationchange&#x27;</span>, init)</span><br><span class="line"><span class="comment">// 监听手机窗口变化，重新设置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, init)</span><br></pre></td></tr></table></figure><p>无论设备可视窗口如何变化，始终设置<code>rem</code>为<code>width</code>的1&#x2F;10，实现了百分比布局</p><p>除此之外，我们还可以利用主流<code>UI</code>框架，如：<code>element ui</code>、<code>antd</code>提供的栅格布局实现响应式</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>响应式设计实现通常会从以下几方面思考：</p><ul><li>弹性盒子（包括图片、表格、视频）和媒体查询等技术</li><li>使用百分比布局创建流式布局的弹性UI，同时使用媒体查询限制元素的尺寸和内容变更范围</li><li>使用相对单位使得内容自适应调节</li><li>选择断点，针对不同断点实现不同布局和内容展示</li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>响应式布局优点可以看到：</p><ul><li>面对不同分辨率设备灵活性强</li><li>能够快捷解决多设备显示适应问题</li></ul><p>缺点：</p><ul><li>仅适用布局、信息、框架并不复杂的部门类型网站</li><li>兼容各种设备工作量大，效率低下</li><li>代码累赘，会出现隐藏无用的元素，加载时间加长</li><li>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</li><li>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://baike.baidu.com/item/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1">https://baike.baidu.com/item/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1</a></li><li><a href="https://juejin.cn/post/6844904082751111176">https://juejin.cn/post/6844904082751111176</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_responsive_layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS如何画一个三角形？原理是什么？</title>
      <link href="/2018/12/11/css-triangle/"/>
      <url>/2018/12/11/css-triangle/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS如何画一个三角形？原理是什么？"><a href="#CSS如何画一个三角形？原理是什么？" class="headerlink" title="CSS如何画一个三角形？原理是什么？"></a>CSS如何画一个三角形？原理是什么？</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在前端开发的时候，我们有时候会需要用到一个三角形的形状，比如地址选择或者播放器里面播放按钮</p><p> <img src="https://static.vue-js.com/d6d8ff60-a279-11eb-85f6-6fac77c0c9b3.png"></p><p>通常情况下，我们会使用图片或者<code>svg</code>去完成三角形效果图，但如果单纯使用<code>css</code>如何完成一个三角形呢？</p><p>实现过程似乎也并不困难，通过边框就可完成</p><h2 id="二、实现过程"><a href="#二、实现过程" class="headerlink" title="二、实现过程"></a>二、实现过程</h2><p>在以前也讲过盒子模型，默认情况下是一个矩形，实现也很简单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.border</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">2px</span> solid;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-color</span>: <span class="number">#96ceb4</span> <span class="number">#ffeead</span> <span class="number">#d9534f</span> <span class="number">#ffad60</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;border&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下图所示：</p><p> <img src="https://static.vue-js.com/e3f244e0-a279-11eb-ab90-d9ae814b240d.png"></p><p>将<code>border</code>设置<code>50px</code>，效果图如下所示：</p><p> <img src="https://static.vue-js.com/ee0b42b0-a279-11eb-ab90-d9ae814b240d.png"></p><p>白色区域则为<code>width</code>、<code>height</code>，这时候只需要你将白色区域部分宽高逐渐变小，最终变为0，则变成如下图所示：</p><p> <img src="https://static.vue-js.com/2afaa030-a27a-11eb-85f6-6fac77c0c9b3.png"></p><p>这时候就已经能够看到4个不同颜色的三角形，如果需要下方三角形，只需要将上、左、右边框设置为0就可以得到下方的红色三角形</p><p> <img src="https://static.vue-js.com/2afaa030-a27a-11eb-85f6-6fac77c0c9b3.png"></p><p>但这种方式，虽然视觉上是实现了三角形，但实际上，隐藏的部分任然占据部分高度，需要将上方的宽度去掉</p><p>最终实现代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent <span class="number">#d9534f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要实现一个只有边框是空心的三角形，由于这里不能再使用<code>border</code>属性，所以最直接的方法是利用伪类新建一个小一点的三角形定位上去</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent <span class="number">#d9534f</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.border</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">border-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">40px</span> <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent <span class="number">#96ceb4</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下所示：</p><p> <img src="https://static.vue-js.com/59f4d720-a27a-11eb-85f6-6fac77c0c9b3.png" alt="i"></p><p>伪类元素定位参照对象的内容区域宽高都为0，则内容区域即可以理解成中心一点，所以伪元素相对中心这点定位</p><p>将元素定位进行微调以及改变颜色，就能够完成下方效果图：</p><p> <img src="https://static.vue-js.com/653a6e10-a27a-11eb-85f6-6fac77c0c9b3.png"></p><p>最终代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">40px</span> <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent <span class="number">#96ceb4</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h2><p>可以看到，边框是实现三角形的部分，边框实际上并不是一个直线，如果我们将四条边设置不同的颜色，将边框逐渐放大，可以得到每条边框都是一个梯形</p><p> <img src="https://static.vue-js.com/78d4bd90-a27a-11eb-85f6-6fac77c0c9b3.png"></p><p>当分别取消边框的时候，发现下面几种情况：</p><ul><li>取消一条边的时候，与这条边相邻的两条边的接触部分会变成直的</li><li>当仅有邻边时， 两个边会变成对分的三角</li><li>当保留边没有其他接触时，极限情况所有东西都会消失</li></ul><p> <img src="https://static.vue-js.com/84586ef0-a27a-11eb-85f6-6fac77c0c9b3.png"></p><p>通过上图的变化规则，利用旋转、隐藏，以及设置内容宽高等属性，就能够实现其他类型的三角形</p><p>如设置直角三角形，如上图倒数第三行实现过程，我们就能知道整个实现原理</p><p>实现代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="comment">/* 内部大小 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="comment">/* 边框大小 只设置两条边*/</span></span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">#4285f4</span> solid;</span><br><span class="line">    <span class="attribute">border-right</span>: transparent solid;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">85px</span>; </span><br><span class="line">    <span class="comment">/* 其他设置 */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/echolun/p/11888612.html">https://www.cnblogs.com/echolun/p/11888612.html</a></li><li><a href="https://juejin.cn/post/6844903567795421197">https://juejin.cn/post/6844903567795421197</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_triangle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3新增了哪些新特性？</title>
      <link href="/2018/12/03/css3-features/"/>
      <url>/2018/12/03/css3-features/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS3新增了哪些新特性？"><a href="#CSS3新增了哪些新特性？" class="headerlink" title="CSS3新增了哪些新特性？"></a>CSS3新增了哪些新特性？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>css</code>，即层叠样式表（Cascading Style Sheets）的简称，是一种标记语言，由浏览器解释执行用来使页面变得更美观</p><p><code>css3</code>是<code>css</code>的最新标准，是向后兼容的，<code>CSS1/2 </code>的特性在<code> CSS3</code> 里都是可以使用的</p><p>而<code> CSS3</code> 也增加了很多新特性，为开发带来了更佳的开发体验</p><h2 id="二、选择器"><a href="#二、选择器" class="headerlink" title="二、选择器"></a>二、选择器</h2><p><code>css3</code>中新增了一些选择器，主要为如下图所示：</p><p> <img src="https://static.vue-js.com/e368cf20-9b5e-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="三、新样式"><a href="#三、新样式" class="headerlink" title="三、新样式"></a>三、新样式</h2><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p><code>css3</code>新增了三个边框属性，分别是：</p><ul><li><p>border-radius：创建圆角边框</p></li><li><p>box-shadow：为元素添加阴影</p></li><li><p>border-image：使用图片来绘制边框</p></li></ul><h4 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h4><p>设置元素阴影，设置属性如下：</p><ul><li>水平阴影</li><li>垂直阴影</li><li>模糊距离(虚实)</li><li>阴影尺寸(影子大小)</li><li>阴影颜色</li><li>内&#x2F;外阴影</li></ul><p>其中水平阴影和垂直阴影是必须设置的</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>新增了几个关于背景的属性，分别是<code>background-clip</code>、<code>background-origin</code>、<code>background-size</code>和<code>background-break</code></p><h4 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h4><p>用于确定背景画区，有以下几种可能的属性：</p><ul><li>background-clip: border-box; 背景从border开始显示</li><li>background-clip: padding-box; 背景从padding开始显示</li><li>background-clip: content-box; 背景显content区域开始显示</li><li>background-clip: no-clip; 默认属性，等同于border-box</li></ul><p>通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围</p><h4 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h4><p>当我们设置背景图片时，图片是会以左上角对齐，但是是以<code>border</code>的左上角对齐还是以<code>padding</code>的左上角或者<code>content</code>的左上角对齐? <code>border-origin</code>正是用来设置这个的</p><ul><li>background-origin: border-box; 从border开始计算background-position</li><li>background-origin: padding-box; 从padding开始计算background-position</li><li>background-origin: content-box; 从content开始计算background-position</li></ul><p>默认情况是<code>padding-box</code>，即以<code>padding</code>的左上角为原点</p><h4 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h4><p>background-size属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：</p><ul><li>background-size: contain; 缩小图片以适合元素（维持像素长宽比）</li><li>background-size: cover; 扩展元素以填补元素（维持像素长宽比）</li><li>background-size: 100px 100px; 缩小图片至指定的大小</li><li>background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸</li></ul><h3 id="background-break"><a href="#background-break" class="headerlink" title="background-break"></a>background-break</h3><p>元素可以被分成几个独立的盒子（如使内联元素span跨越多行），<code>background-break</code> 属性用来控制背景怎样在这些不同的盒子中显示</p><ul><li>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）</li><li>background-break: bounding-box; 把盒之间的距离计算在内；</li><li>background-break: each-box; 为每个盒子单独重绘背景</li></ul><h3 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h3><h3 id="word-wrap"><a href="#word-wrap" class="headerlink" title="word-wrap"></a>word-wrap</h3><p>语法：<code>word-wrap: normal|break-word</code></p><ul><li>normal：使用浏览器默认的换行</li><li>break-all：允许在单词内换行</li></ul><h3 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a>text-overflow</h3><p><code> text-overflow</code>设置或检索当当前行超过指定容器的边界时如何显示，属性有两个值选择：</p><ul><li>clip：修剪文本</li><li>ellipsis：显示省略符号来代表被修剪的文本</li></ul><h3 id="text-shadow"><a href="#text-shadow" class="headerlink" title="text-shadow"></a>text-shadow</h3><p><code>text-shadow</code>可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色</p><h3 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a>text-decoration</h3><p>CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：</p><ul><li><p>text-fill-color: 设置文字内部填充颜色</p></li><li><p>text-stroke-color: 设置文字边界填充颜色</p></li><li><p>text-stroke-width: 设置文字边界宽度</p></li></ul><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p><code>css3</code>新增了新的颜色表示方式<code>rgba</code>与<code>hsla</code></p><ul><li>rgba分为两部分，rgb为颜色值，a为透明度</li><li>hala分为四部分，h为色相，s为饱和度，l为亮度，a为透明度</li></ul><h2 id="四、transition-过渡"><a href="#四、transition-过渡" class="headerlink" title="四、transition 过渡"></a>四、transition 过渡</h2><p><code>transition</code>属性可以被指定为一个或多个<code>CSS</code>属性的过渡效果，多个属性之间用逗号进行分隔，必须规定两项内容：</p><ul><li>过度效果</li><li>持续时间</li></ul><p>语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition</span>： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上面为简写模式，也可以分开写各个属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition-property</span>: width; </span><br><span class="line"><span class="attribute">transition-duration</span>: <span class="number">1s</span>;</span><br><span class="line"><span class="attribute">transition-timing-function</span>: linear;</span><br><span class="line"><span class="attribute">transition-delay</span>: <span class="number">2s</span>;</span><br></pre></td></tr></table></figure><h3 id="五、transform-转换"><a href="#五、transform-转换" class="headerlink" title="五、transform 转换"></a>五、transform 转换</h3><p><code>transform</code>属性允许你旋转，缩放，倾斜或平移给定元素</p><p><code>transform-origin</code>：转换元素的位置（围绕那个点进行转换），默认值为<code>(x,y,z):(50%,50%,0)</code></p><p>使用方式：</p><ul><li>transform: translate(120px, 50%)：位移</li><li>transform: scale(2, 0.5)：缩放</li><li>transform: rotate(0.5turn)：旋转</li><li>transform: skew(30deg, 20deg)：倾斜</li></ul><h3 id="六、animation-动画"><a href="#六、animation-动画" class="headerlink" title="六、animation 动画"></a>六、animation 动画</h3><p>动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬</p><p>animation也有很多的属性</p><ul><li>animation-name：动画名称</li><li>animation-duration：动画持续时间</li><li>animation-timing-function：动画时间函数</li><li>animation-delay：动画延迟时间</li><li>animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环</li><li>animation-direction：动画执行方向</li><li>animation-paly-state：动画播放状态</li><li>animation-fill-mode：动画填充模式</li></ul><h2 id="七、渐变"><a href="#七、渐变" class="headerlink" title="七、渐变"></a>七、渐变</h2><p>颜色渐变是指在两个颜色之间平稳的过渡，<code>css3</code>渐变包括</p><ul><li>linear-gradient：线性渐变</li></ul><blockquote><p>background-image: linear-gradient(direction, color-stop1, color-stop2, …);</p></blockquote><ul><li>radial-gradient：径向渐变</li></ul><blockquote><p>linear-gradient(0deg, red, green); </p></blockquote><h2 id="八、其他"><a href="#八、其他" class="headerlink" title="八、其他"></a>八、其他</h2><p>关于<code>css3</code>其他的新特性还包括<code>flex</code>弹性布局、<code>Grid</code>栅格布局，这两个布局在以前就已经讲过，这里就不再展示</p><p>除此之外，还包括多列布局、媒体查询、混合模式等等……</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://juejin.cn/post/6844903518520901639#heading-1">https://juejin.cn/post/6844903518520901639#heading-1</a></p></li><li><p><a href="https://www.w3school.com.cn/css/index.asp">https://www.w3school.com.cn/css/index.asp</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css3_features </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现单行／多行文本溢出的省略样式？</title>
      <link href="/2018/11/26/css-single-multi-line/"/>
      <url>/2018/11/26/css-single-multi-line/</url>
      
        <content type="html"><![CDATA[<h1 id="如何实现单行／多行文本溢出的省略样式？"><a href="#如何实现单行／多行文本溢出的省略样式？" class="headerlink" title="如何实现单行／多行文本溢出的省略样式？"></a>如何实现单行／多行文本溢出的省略样式？</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在日常开发展示页面，如果一段文本的数量过长，受制于元素宽度的因素，有可能不能完全显示，为了提高用户的使用体验，这个时候就需要我们把溢出的文本显示成省略号</p><p>对于文本的溢出，我们可以分成两种形式：</p><ul><li>单行文本溢出</li><li>多行文本溢出</li></ul><h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><h3 id="单行文本溢出省略"><a href="#单行文本溢出省略" class="headerlink" title="单行文本溢出省略"></a>单行文本溢出省略</h3><p>理解也很简单，即文本在一行内显示，超出部分以省略号的形式展现</p><p>实现方式也很简单，涉及的<code>css</code>属性有：</p><ul><li>text-overflow：规定当文本溢出时，显示省略符号来代表被修剪的文本</li><li>white-space：设置文字在一行显示，不能换行</li><li>overflow：文字长度超出限定宽度，则隐藏超出的内容</li></ul><p><code>overflow</code>设为<code>hidden</code>，普通情况用在块级元素的外层隐藏内部溢出元素，或者配合下面两个属性实现文本溢出省略</p><p><code>white-space:nowrap</code>，作用是设置文本不换行，是<code>overflow:hidden</code>和<code>text-overflow：ellipsis</code>生效的基础</p><p><code>text-overflow</code>属性值有如下：</p><ul><li>clip：当对象内文本溢出部分裁切掉</li><li>ellipsis：当对象内文本溢出时显示省略标记（…）</li></ul><p><code>text-overflow</code>只有在设置了<code>overflow:hidden</code>和<code>white-space:nowrap</code>才能够生效的</p><p>举个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">line-height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>:<span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>:<span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-overflow</span>: ellipsis;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">white-space</span>: nowrap;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本</span>&lt;/<span class="attr">p</span> &gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p> <img src="https://static.vue-js.com/bb3048e0-a0e9-11eb-85f6-6fac77c0c9b3.png"></p><p>可以看到，设置单行文本溢出较为简单，并且省略号显示的位置较好</p><h3 id="多行文本溢出省略"><a href="#多行文本溢出省略" class="headerlink" title="多行文本溢出省略"></a>多行文本溢出省略</h3><p>多行文本溢出的时候，我们可以分为两种情况：</p><ul><li>基于高度截断</li><li>基于行数截断</li></ul><h4 id="基于高度截断"><a href="#基于高度截断" class="headerlink" title="基于高度截断"></a>基于高度截断</h4><h4 id="伪元素-定位"><a href="#伪元素-定位" class="headerlink" title="伪元素 + 定位"></a>伪元素 + 定位</h4><p>核心的<code>css</code>代码结构如下：</p><ul><li>position: relative：为伪元素绝对定位</li><li>overflow: hidden：文本溢出限定的宽度就隐藏内容）</li><li>position: absolute：给省略号绝对定位</li><li>line-height: 20px：结合元素高度,高度固定的情况下,设定行高, 控制显示行数</li><li>height: 40px：设定当前元素高度</li><li>::after {} ：设置省略号样式</li></ul><p>代码如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.demo</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">line-height</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.demo</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">content</span>: <span class="string">&quot;...&quot;</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;demo&#x27;</span>&gt;</span>这是一段很长的文本<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现原理很好理解，就是通过伪元素绝对定位到行尾并遮住文字，再通过 <code>overflow: hidden</code> 隐藏多余文字</p><p>这种实现具有以下优点：</p><ul><li>兼容性好，对各大主流浏览器有好的支持</li><li>响应式截断，根据不同宽度做出调整</li></ul><p>一般文本存在英文的时候，可以设置<code>word-break: break-all</code>使一个单词能够在换行时进行拆分</p><h4 id="基于行数截断"><a href="#基于行数截断" class="headerlink" title="基于行数截断"></a>基于行数截断</h4><p>纯<code>css</code>实现也非常简单，核心的<code>css</code>代码如下：</p><ul><li>-webkit-line-clamp: 2：用来限制在一个块元素显示的文本的行数，为了实现该效果，它需要组合其他的WebKit属性）</li><li>display: -webkit-box：和1结合使用，将对象作为弹性伸缩盒子模型显示 </li><li>-webkit-box-orient: vertical：和1结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 </li><li>overflow: hidden：文本溢出限定的宽度就隐藏内容</li><li>text-overflow: ellipsis：多行文本的情况下，用省略号“…”隐藏溢出范围的文本</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-radius</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">        -webkit-line-clamp: <span class="number">2</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: -webkit-box;</span></span><br><span class="line"><span class="language-css">        -webkit-box-orient: vertical;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-overflow</span>: ellipsis;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本</span><br><span class="line">    这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本</span><br><span class="line">&lt;/p &gt;</span><br></pre></td></tr></table></figure><p>可以看到，上述使用了<code>webkit</code>的<code>CSS</code>属性扩展，所以兼容浏览器范围是<code>PC</code>端的<code>webkit</code>内核的浏览器，由于移动端大多数是使用<code>webkit</code>，所以移动端常用该形式</p><p>需要注意的是，如果文本为一段很长的英文或者数字，则需要添加<code>word-wrap: break-word</code>属性</p><p>还能通过使用<code>javascript</code>实现配合<code>css</code>，实现代码如下所示：</p><p>css结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.p-after</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;...&quot;</span>; </span><br><span class="line">    <span class="attribute">position</span>: absolute; </span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>; </span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>; </span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left, transparent, <span class="number">#fff</span> <span class="number">55%</span>);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(left, transparent, <span class="number">#fff</span> <span class="number">55%</span>);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(left, transparent, <span class="number">#fff</span> <span class="number">55%</span>);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, transparent, <span class="number">#fff</span> <span class="number">55%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javascript代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="comment">//获取文本的行高，并获取文本的高度，假设我们规定的行数是五行，那么对超过行数的部分进行限制高度，并加上省略号</span></span><br><span class="line">   $(<span class="string">&#x27;p&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params">i, obj</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> lineHeight = <span class="built_in">parseInt</span>($(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&quot;line-height&quot;</span>));</span><br><span class="line">        <span class="keyword">var</span> height = <span class="built_in">parseInt</span>($(<span class="variable language_">this</span>).<span class="title function_">height</span>());</span><br><span class="line">        <span class="keyword">if</span>((height / lineHeight) &gt;<span class="number">3</span> )&#123;</span><br><span class="line">            $(<span class="variable language_">this</span>).<span class="title function_">addClass</span>(<span class="string">&quot;p-after&quot;</span>)</span><br><span class="line">            $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&quot;height&quot;</span>,<span class="string">&quot;60px&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            $(<span class="variable language_">this</span>).<span class="title function_">removeClass</span>(<span class="string">&quot;p-after&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://www.zoo.team/article/text-overflow">https://www.zoo.team/article/text-overflow</a></p></li><li><p><a href="https://segmentfault.com/a/1190000017078153">https://segmentfault.com/a/1190000017078153</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_single_multi_line </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css选择器有哪些？优先级？哪些属性可以继承？</title>
      <link href="/2018/11/06/css-selector/"/>
      <url>/2018/11/06/css-selector/</url>
      
        <content type="html"><![CDATA[<h1 id="css选择器有哪些？优先级？哪些属性可以继承？"><a href="#css选择器有哪些？优先级？哪些属性可以继承？" class="headerlink" title="css选择器有哪些？优先级？哪些属性可以继承？"></a>css选择器有哪些？优先级？哪些属性可以继承？</h1><h2 id="一、选择器"><a href="#一、选择器" class="headerlink" title="一、选择器"></a>一、选择器</h2><p>CSS选择器是CSS规则的第一部分</p><p>它是元素和其他部分组合起来告诉浏览器哪个HTML元素应当是被选为应用规则中的CSS属性值的方式</p><p>选择器所选择的元素，叫做“选择器的对象”</p><p>我们从一个<code>Html</code>结构开始</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;one_1&quot;</span>&gt;</span></span><br><span class="line">        &lt;/p &gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;one_1&quot;</span>&gt;</span></span><br><span class="line">        &lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于<code>css</code>属性选择器常用的有：</p><ul><li><p>id选择器（#box），选择id为box的元素</p></li><li><p>类选择器（.one），选择类名为one的所有元素</p></li><li><p>标签选择器（div），选择标签为div的所有元素</p></li><li><p>后代选择器（#box div），选择id为box元素内部所有的div元素</p></li><li><p>子选择器（.one&gt;one_1），选择父元素为.one的所有.one_1的元素</p></li><li><p>相邻同胞选择器（.one+.two），选择紧接在.one之后的所有.two元素</p></li><li><p>群组选择器（div,p），选择div、p的所有元素</p></li></ul><p>还有一些使用频率相对没那么多的选择器：</p><ul><li>伪类选择器</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:link</span> ：选择未被访问的链接</span><br><span class="line"><span class="selector-pseudo">:visited</span>：选取已被访问的链接</span><br><span class="line"><span class="selector-pseudo">:active</span>：选择活动链接</span><br><span class="line"><span class="selector-pseudo">:hover</span> ：鼠标指针浮动在上面的元素</span><br><span class="line"><span class="selector-pseudo">:focus</span> ：选择具有焦点的</span><br><span class="line"><span class="selector-pseudo">:first</span>-child：父元素的首个子元素</span><br></pre></td></tr></table></figure><ul><li>伪元素选择器</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:first</span>-letter ：用于选取指定选择器的首字母</span><br><span class="line"><span class="selector-pseudo">:first</span>-line ：选取指定选择器的首行</span><br><span class="line"><span class="selector-pseudo">:before</span> : 选择器在被选元素的内容前面插入内容</span><br><span class="line">:after : 选择器在被选元素的内容后面插入内容</span><br></pre></td></tr></table></figure><ul><li>属性选择器</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute]</span> 选择带有attribute属性的元素</span><br><span class="line"><span class="selector-attr">[attribute=value]</span> 选择所有使用attribute=value的元素</span><br><span class="line"><span class="selector-attr">[attribute~=value]</span> 选择attribute属性包含value的元素</span><br><span class="line"><span class="selector-attr">[attribute|=value]</span>：选择attribute属性以value开头的元素</span><br></pre></td></tr></table></figure><p>在<code>CSS3</code>中新增的选择器有如下：</p><ul><li>层次选择器（p~ul），选择前面有p元素的每个ul元素</li><li>伪类选择器</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:first</span>-of-type 表示一组同级元素中其类型的第一个元素</span><br><span class="line"><span class="selector-pseudo">:last-of-type</span> 表示一组同级元素中其类型的最后一个元素</span><br><span class="line"><span class="selector-pseudo">:only-of-type</span> 表示没有同类型兄弟元素的元素</span><br><span class="line"><span class="selector-pseudo">:only-child</span> 表示没有任何兄弟的元素</span><br><span class="line"><span class="selector-pseudo">:nth-child</span>(n) 根据元素在一组同级中的位置匹配元素</span><br><span class="line"><span class="selector-pseudo">:nth-last-of-type</span>(n) 匹配给定类型的元素，基于它们在一组兄弟元素中的位置，从末尾开始计数</span><br><span class="line"><span class="selector-pseudo">:last-child</span> 表示一组兄弟元素中的最后一个元素</span><br><span class="line"><span class="selector-pseudo">:root</span> 设置<span class="selector-tag">HTML</span>文档</span><br><span class="line"><span class="selector-pseudo">:empty</span> 指定空的元素</span><br><span class="line"><span class="selector-pseudo">:enabled</span> 选择可用元素</span><br><span class="line"><span class="selector-pseudo">:disabled</span> 选择被禁用元素</span><br><span class="line"><span class="selector-pseudo">:checked</span> 选择选中的元素</span><br><span class="line"><span class="selector-pseudo">:not</span>(selector) 选择与 &lt;selector&gt; 不匹配的所有元素</span><br></pre></td></tr></table></figure><ul><li>属性选择器</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute*=value]</span>：选择attribute属性值包含value的所有元素</span><br><span class="line"><span class="selector-attr">[attribute^=value]</span>：选择attribute属性开头为value的所有元素</span><br><span class="line"><span class="selector-attr">[attribute$=value]</span>：选择attribute属性结尾为value的所有元素</span><br></pre></td></tr></table></figure><h2 id="二、优先级"><a href="#二、优先级" class="headerlink" title="二、优先级"></a>二、优先级</h2><p>相信大家对<code>CSS</code>选择器的优先级都不陌生：</p><blockquote><p>内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</p></blockquote><p>到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p><ul><li><p>如果存在内联样式，那么 A &#x3D; 1, 否则 A &#x3D; 0</p></li><li><p>B的值等于 ID选择器出现的次数</p></li><li><p>C的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数</p></li><li><p>D 的值等于 标签选择器 和 伪元素 出现的总次数</p></li></ul><p>这里举个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#nav-global</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span> &gt; <span class="selector-tag">a</span><span class="selector-class">.nav-link</span></span><br></pre></td></tr></table></figure><p>套用上面的算法，依次求出 <code>A</code> <code>B</code> <code>C</code> <code>D</code> 的值：</p><ul><li><p>因为没有内联样式 ，所以 A &#x3D; 0</p></li><li><p>ID选择器总共出现了1次， B &#x3D; 1</p></li><li><p>类选择器出现了1次， 属性选择器出现了0次，伪类选择器出现0次，所以 C &#x3D; (1 + 0 + 0) &#x3D; 1</p></li><li><p>标签选择器出现了3次， 伪元素出现了0次，所以 D &#x3D; (3 + 0) &#x3D; 3</p></li></ul><p>上面算出的<code>A</code> 、 <code>B</code>、<code>C</code>、<code>D</code> 可以简记作：<code>(0, 1, 1, 3)</code></p><p>知道了优先级是如何计算之后，就来看看比较规则：</p><ul><li>从左往右依次进行比较 ，较大者优先级更高</li><li>如果相等，则继续往右移动一位进行比较</li><li>如果4位全部相等，则后面的会覆盖前面的</li></ul><p>经过上面的优先级计算规则，我们知道内联样式的优先级最高，如果外部样式需要覆盖内联样式，就需要使用<code>!important</code></p><h2 id="三、继承属性"><a href="#三、继承属性" class="headerlink" title="三、继承属性"></a>三、继承属性</h2><p>在<code>css</code>中，继承是指的是给父元素设置一些属性，后代元素会自动拥有这些属性</p><p>关于继承属性，可以分成：</p><ul><li>字体系列属性</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font</span>:组合字体</span><br><span class="line">font-family:规定元素的字体系列</span><br><span class="line">font-weight:设置字体的粗细</span><br><span class="line">font-size:设置字体的尺寸</span><br><span class="line">font-style:定义字体的风格</span><br><span class="line">font-variant:偏大或偏小的字体</span><br></pre></td></tr></table></figure><ul><li>文本系列属性</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-indent</span>：文本缩进</span><br><span class="line"><span class="attribute">text-align</span>：文本水平对刘</span><br><span class="line"><span class="attribute">line-height</span>：行高</span><br><span class="line"><span class="attribute">word-spacing</span>：增加或减少单词间的空白</span><br><span class="line"><span class="attribute">letter-spacing</span>：增加或减少字符间的空白</span><br><span class="line"><span class="attribute">text-transform</span>：控制文本大小写</span><br><span class="line"><span class="attribute">direction</span>：规定文本的书写方向</span><br><span class="line"><span class="attribute">color</span>：文本颜色</span><br></pre></td></tr></table></figure><ul><li>元素可见性</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">visibility</span></span><br></pre></td></tr></table></figure><ul><li>表格布局属性</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">caption-side</span>：定位表格标题位置</span><br><span class="line"><span class="attribute">border-collapse</span>：合并表格边框</span><br><span class="line"><span class="attribute">border-spacing</span>：设置相邻单元格的边框间的距离</span><br><span class="line"><span class="attribute">empty-cells</span>：单元格的边框的出现与消失</span><br><span class="line"><span class="attribute">table-layout</span>：表格的宽度由什么决定</span><br></pre></td></tr></table></figure><ul><li>列表属性</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">list-style-type</span>：文字前面的小点点样式</span><br><span class="line"><span class="attribute">list-style-position</span>：小点点位置</span><br><span class="line"><span class="attribute">list-style</span>：以上的属性可通过这属性集合</span><br></pre></td></tr></table></figure><ul><li>引用</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">quotes</span>：设置嵌套引用的引号类型</span><br></pre></td></tr></table></figure><ul><li>光标属性</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cursor</span>：箭头可以变成需要的形状</span><br></pre></td></tr></table></figure><p>继承中比较特殊的几点：</p><ul><li><p>a 标签的字体颜色不能被继承</p></li><li><p>h1-h6标签字体的大下也是不能被继承的</p></li></ul><h3 id="无继承的属性"><a href="#无继承的属性" class="headerlink" title="无继承的属性"></a>无继承的属性</h3><ul><li><p>display</p></li><li><p>文本属性：vertical-align、text-decoration</p></li><li><p>盒子模型的属性：宽度、高度、内外边距、边框等</p></li><li><p>背景属性：背景图片、颜色、位置等</p></li><li><p>定位属性：浮动、清除浮动、定位position等</p></li><li><p>生成内容属性：content、counter-reset、counter-increment</p></li><li><p>轮廓样式属性：outline-style、outline-width、outline-color、outline</p></li><li><p>页面样式属性：size、page-break-before、page-break-after</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.html.cn/qa/css3/13444.html">https://www.html.cn/qa/css3/13444.html</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_selector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flexbox（弹性盒布局模型）,以及适用场景？</title>
      <link href="/2018/11/06/css-flexbox/"/>
      <url>/2018/11/06/css-flexbox/</url>
      
        <content type="html"><![CDATA[<h1 id="flexbox（弹性盒布局模型）-以及适用场景？"><a href="#flexbox（弹性盒布局模型）-以及适用场景？" class="headerlink" title="flexbox（弹性盒布局模型）,以及适用场景？"></a>flexbox（弹性盒布局模型）,以及适用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>Flexible Box</code> 简称 <code>flex</code>，意为”弹性布局”，可以简便、完整、响应式地实现各种页面布局</p><p>采用Flex布局的元素，称为<code>flex</code>容器<code>container</code></p><p>它的所有子元素自动成为容器成员，称为<code>flex</code>项目<code>item</code></p><p> <img src="https://static.vue-js.com/fbc5f590-9837-11eb-ab90-d9ae814b240d.png"></p><p>容器中默认存在两条轴，主轴和交叉轴，呈90度关系。项目默认沿主轴排列，通过<code>flex-direction</code>来决定主轴的方向</p><p>每根轴都有起点和终点，这对于元素的对齐非常重要</p><h2 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h2><p>关于<code>flex</code>常用的属性，我们可以划分为容器属性和容器成员属性</p><p>容器属性有：</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>决定主轴的方向(即项目的排列方向)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;   </span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>属性对应如下：</p><ul><li>row（默认值）：主轴为水平方向，起点在左端</li><li>row-reverse：主轴为水平方向，起点在右端</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿</li></ul><p>如下图所示：</p><p> <img src="https://static.vue-js.com/0c9abc70-9838-11eb-ab90-d9ae814b240d.png"></p><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>弹性元素永远沿主轴排列，那么如果主轴排不下，通过<code>flex-wrap</code>决定容器内项目是否可换行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;  </span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>属性对应如下：</p><ul><li>nowrap（默认值）：不换行</li><li>wrap：换行，第一行在下方</li><li>wrap-reverse：换行，第一行在上方</li></ul><p>默认情况是不换行，但这里也不会任由元素直接溢出容器，会涉及到元素的弹性伸缩</p><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>定义了项目在主轴上的对齐方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性对应如下：</p><ul><li>flex-start（默认值）：左对齐</li><li>flex-end：右对齐</li><li>center：居中</li><li>space-between：两端对齐，项目之间的间隔都相等</li><li>space-around：两个项目两侧间隔相等</li></ul><p>效果图如下：</p><p> <img src="https://static.vue-js.com/2d5ca950-9838-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>定义项目在交叉轴上如何对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性对应如下：</p><ul><li>flex-start：交叉轴的起点对齐</li><li>flex-end：交叉轴的终点对齐</li><li>center：交叉轴的中点对齐</li><li>baseline: 项目的第一行文字的基线对齐</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</li></ul><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性对应如吓：</p><ul><li>flex-start：与交叉轴的起点对齐</li><li>flex-end：与交叉轴的终点对齐</li><li>center：与交叉轴的中点对齐</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li><li>stretch（默认值）：轴线占满整个交叉轴</li></ul><p>效果图如下：</p><p> <img src="https://static.vue-js.com/39bcb0f0-9838-11eb-ab90-d9ae814b240d.png"></p><p>容器成员属性如下：</p><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>定义项目的排列顺序。数值越小，排列越靠前，默认为0</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>上面讲到当容器设为<code>flex-wrap: nowrap;</code>不换行的时候，容器宽度有不够分的情况，弹性元素会根据<code>flex-grow</code>来决定</p><p>定义项目的放大比例（容器宽度&gt;元素总宽度时如何伸展）</p><p>默认为<code>0</code>，即如果存在剩余空间，也不放大</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）</p><p> <img src="https://static.vue-js.com/48c8c5c0-9838-11eb-ab90-d9ae814b240d.png"></p><p>如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍</p><p> <img src="https://static.vue-js.com/5b822b20-9838-11eb-ab90-d9ae814b240d.png"></p><p>弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论<code>flex-grow</code>是什么值都不会生效</p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>定义了项目的缩小比例（容器宽度&lt;元素总宽度时如何收缩），默认为1，即如果空间不足，该项目将缩小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小</p><p>如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小</p><p> <img src="https://static.vue-js.com/658c5be0-9838-11eb-85f6-6fac77c0c9b3.png"></p><p>在容器宽度有剩余时，<code>flex-shrink</code>也是不会生效的</p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在<code>flex-grow</code>和<code>flex-shrink</code>生效前的尺寸</p><p>浏览器根据这个属性，计算主轴是否有多余空间，默认值为<code>auto</code>，即项目的本来大小，如设置了<code>width</code>则元素尺寸由<code>width/height</code>决定（主轴方向），没有设置则由内容决定</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当设置为0的是，会根据内容撑开</p><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间</p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>，也是比较难懂的一个复合属性</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些属性有：</p><ul><li>flex: 1 &#x3D; flex: 1 1 0%</li><li>flex: 2 &#x3D; flex: 2 1 0%</li><li>flex: auto &#x3D; flex: 1 1 auto</li><li>flex: none &#x3D; flex: 0 0 auto，常用于固定尺寸不伸缩</li></ul><p><code>flex:1</code> 和 <code>flex:auto</code> 的区别，可以归结于<code>flex-basis:0</code>和<code>flex-basis:auto</code>的区别</p><p>当设置为0时（绝对弹性元素），此时相当于告诉<code>flex-grow</code>和<code>flex-shrink</code>在伸缩的时候不需要考虑我的尺寸</p><p>当设置为<code>auto</code>时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑</p><p>注意：建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值</p><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性</p><p>默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p> <img src="https://static.vue-js.com/6f8304a0-9838-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>在以前的文章中，我们能够通过<code>flex</code>简单粗暴的实现元素水平垂直方向的居中，以及在两栏三栏自适应布局中通过<code>flex</code>完成，这里就不再展开代码的演示</p><p>包括现在在移动端、小程序这边的开发，都建议使用<code>flex</code>进行布局</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex">https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_flexbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>em/px/rem/vh/vw区别?</title>
      <link href="/2018/10/06/css-em-px-rem-vh-vw/"/>
      <url>/2018/10/06/css-em-px-rem-vh-vw/</url>
      
        <content type="html"><![CDATA[<h1 id="em-px-rem-vh-vw区别"><a href="#em-px-rem-vh-vw区别" class="headerlink" title="em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别?"></a>em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别?</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>传统的项目开发中，我们只会用到<code>px</code>、<code>%</code>、<code>em</code>这几个单位，它可以适用于大部分的项目开发，且拥有比较良好的兼容性</p><p>从<code>CSS3</code>开始，浏览器对计量单位的支持又提升到了另外一个境界，新增了<code>rem</code>、<code>vh</code>、<code>vw</code>、<code>vm</code>等一些新的计量单位</p><p>利用这些新的单位开发出比较良好的响应式页面，适应多种不同分辨率的终端，包括移动设备等</p><h2 id="二、单位"><a href="#二、单位" class="headerlink" title="二、单位"></a>二、单位</h2><p>在<code>css</code>单位中，可以分为长度单位、绝对单位，如下表所指示</p><table><thead><tr><th>CSS单位</th><th></th></tr></thead><tbody><tr><td>相对长度单位</td><td>em、ex、ch、rem、vw、vh、vmin、vmax、%</td></tr><tr><td>绝对长度单位</td><td>cm、mm、in、px、pt、pc</td></tr></tbody></table><p>这里我们主要讲述px、em、rem、vh、vw</p><h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>px，表示像素，所谓像素就是呈现在我们显示器上的一个个小点，每个像素点都是大小等同的，所以像素为计量单位被分在了绝对长度单位中</p><p>有些人会把<code>px</code>认为是相对长度，原因在于在移动端中存在设备像素比，<code>px</code>实际显示的大小是不确定的</p><p>这里之所以认为<code>px</code>为绝对单位，在于<code>px</code>的大小和元素的其他属性无关</p><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（<code>1em = 16px</code>）</p><p>为了简化 <code>font-size</code> 的换算，我们需要在<code>css</code>中的 <code>body</code> 选择器中声明<code>font-size</code>&#x3D; <code>62.5%</code>，这就使 em 值变为 <code>16px*62.5% = 10px</code></p><p>这样 <code>12px = 1.2em</code>, <code>10px = 1em</code>, 也就是说只需要将你的原来的<code> px</code> 数值除以 10，然后换上 <code>em </code>作为单位就行了</p><p>特点：</p><ul><li>em 的值并不是固定的</li><li>em 会继承父级元素的字体大小</li><li>em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸</li><li>任意浏览器的默认字体高都是 16px</li></ul><p>举个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;big&quot;</span>&gt;</span></span><br><span class="line">    我是14px=1.4rem<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;small&quot;</span>&gt;</span>我是12px=1.2rem<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>样式为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">10px</span>;  &#125; <span class="comment">/*  公式16px*62.5%=10px  */</span>  </span><br><span class="line">    <span class="selector-class">.big</span>&#123;<span class="attribute">font-size</span>: <span class="number">1.4rem</span>&#125;</span><br><span class="line">    <span class="selector-class">.small</span>&#123;<span class="attribute">font-size</span>: <span class="number">1.2rem</span>&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这时候<code>.big</code>元素的<code>font-size</code>为14px，而<code>.small</code>元素的<code>font-size</code>为12px</p><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>rem，相对单位，相对的只是HTML根元素<code>font-size</code>的值</p><p>同理，如果想要简化<code>font-size</code>的转化，我们可以在根元素<code>html</code>中加入<code>font-size: 62.5%</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">62.5%</span>;  &#125; <span class="comment">/*  公式16px*62.5%=10px  */</span> </span><br></pre></td></tr></table></figure><p>这样页面中1rem&#x3D;10px、1.2rem&#x3D;12px、1.4rem&#x3D;14px、1.6rem&#x3D;16px;使得视觉、使用、书写都得到了极大的帮助</p><p>特点：</p><ul><li>rem单位可谓集相对大小和绝对大小的优点于一身</li><li>和em不同的是rem总是相对于根元素，而不像em一样使用级联的方式来计算尺寸</li></ul><h3 id="vh、vw"><a href="#vh、vw" class="headerlink" title="vh、vw"></a>vh、vw</h3><p>vw ，就是根据窗口的宽度，分成100等份，100vw就表示满宽，50vw就表示一半宽。（vw 始终是针对窗口的宽），同理，<code>vh</code>则为窗口的高度</p><p>这里的窗口分成几种情况：</p><ul><li><p>在桌面端，指的是浏览器的可视区域</p></li><li><p>移动端指的就是布局视口</p></li></ul><p>像<code>vw</code>、<code>vh</code>，比较容易混淆的一个单位是<code>%</code>，不过百分比宽泛的讲是相对于父元素：</p><ul><li>对于普通定位元素就是我们理解的父元素</li><li>对于position: absolute;的元素是相对于已定位的父元素</li><li>对于position: fixed;的元素是相对于 ViewPort（可视窗口）</li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><strong>px</strong>：绝对单位，页面按精确像素展示</p><p><strong>em</strong>：相对单位，基准点为父节点字体的大小，如果自身定义了<code>font-size</code>按自身来计算，整个页面内<code>1em</code>不是一个固定的值</p><p><strong>rem</strong>：相对单位，可理解为<code>root em</code>, 相对根节点<code>html</code>的字体大小来计算</p><p><strong>vh、vw</strong>：主要用于页面视口大小布局，在页面布局上更加方便简单</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_em_px_rem_vh_vw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Css预编语言的理解？有哪些区别?</title>
      <link href="/2018/08/06/css-sass-less-stylus/"/>
      <url>/2018/08/06/css-sass-less-stylus/</url>
      
        <content type="html"><![CDATA[<h1 id="对Css预编语言的理解？有哪些区别"><a href="#对Css预编语言的理解？有哪些区别" class="headerlink" title="对Css预编语言的理解？有哪些区别?"></a>对Css预编语言的理解？有哪些区别?</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>Css</code> 作为一门标记性语言，语法相对简单，对使用者的要求较低，但同时也带来一些问题</p><p>需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于非前端开发工程师来讲，往往会因为缺少 <code>Css</code> 编写经验而很难写出组织良好且易于维护的 <code>Css</code> 代码</p><p><code>Css</code>预处理器便是针对上述问题的解决方案</p><h4 id="预处理语言"><a href="#预处理语言" class="headerlink" title="预处理语言"></a>预处理语言</h4><p>扩充了 <code>Css</code> 语言，增加了诸如变量、混合（mixin）、函数等功能，让 <code>Css</code> 更易维护、方便</p><p>本质上，预处理是<code>Css</code>的超集</p><p>包含一套自定义的语法及一个解析器，根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 <code>Css</code> 文件</p><h2 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h2><p><code>Css</code>预编译语言在前端里面有三大优秀的预编处理器，分别是：</p><ul><li>sass</li><li>less</li><li>stylus</li></ul><h3 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h3><p>2007 年诞生，最早也是最成熟的 <code>Css </code>预处理器，拥有 Ruby 社区的支持和 <code>Compass</code> 这一最强大的 <code>Css </code>框架，目前受 <code>LESS</code> 影响，已经进化到了全面兼容 <code>Css</code> 的 <code>Scss</code></p><p>文件后缀名为<code>.sass</code>与<code>scss</code>，可以严格按照 sass 的缩进方式省去大括号和分号</p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>2009年出现，受<code>SASS</code>的影响较大，但又使用 <code>Css</code> 的语法，让大部分开发者和设计师更容易上手，在 <code>Ruby </code>社区之外支持者远超过 <code>SASS</code></p><p>其缺点是比起 <code>SASS </code>来，可编程功能不够，不过优点是简单和兼容 <code>Css</code>，反过来也影响了 <code>SASS </code>演变到了<code> Scss</code> 的时代</p><h3 id="stylus"><a href="#stylus" class="headerlink" title="stylus"></a>stylus</h3><p><code>Stylus </code>是一个<code>Css</code>的预处理框架，2010 年产生，来自 <code>Node.js </code>社区，主要用来给 <code>Node</code> 项目进行 <code>Css</code> 预处理支持</p><p>所以<code> Stylus</code> 是一种新型语言，可以创建健壮的、动态的、富有表现力的<code> Css</code>。比较年轻，其本质上做的事情与<code>SASS/LESS</code>等类似</p><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>虽然各种预处理器功能强大，但使用最多的，还是以下特性：</p><ul><li>变量（variables）</li><li>作用域（scope）</li><li>代码混合（ mixins）</li><li>嵌套（nested rules）</li><li>代码模块化（Modules）</li></ul><p>因此，下面就展开这些方面的区别</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>less和scss</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sass</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span></span><br><span class="line">  <span class="attribute">display</span>: block</span><br></pre></td></tr></table></figure><p>stylus</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span></span><br><span class="line">  <span class="attribute">display</span>: block</span><br></pre></td></tr></table></figure><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>三者的嵌套语法都是一致的，甚至连引用父级选择器的标记 &amp; 也相同</p><p>区别只是 Sass 和 Stylus 可以用没有大括号的方式书写</p><p>less</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  &amp;<span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量无疑为 Css 增加了一种有效的复用方式，减少了原来在 Css 中无法避免的重复「硬编码」</p><p><code>less</code>声明的变量必须以<code>@</code>开头，后面紧跟变量名和变量值，而且变量名和变量值需要使用冒号<code>:</code>分隔开</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@red</span>: #c00;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: @red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sass</code>声明的变量跟<code>less</code>十分的相似，只是变量名前面使用<code>@</code>开头</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$red: <span class="number">#c00</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: $red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>stylus</code>声明的变量没有任何的限定，可以使用<code>$</code>开头，结尾的分号<code>;</code>可有可无，但变量与变量值之间需要使用<code>=</code></p><p>在<code>stylus</code>中我们不建议使用<code>@</code>符号开头声明变量</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">red = <span class="selector-id">#c00</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">strong</span></span><br><span class="line">  <span class="attribute">color</span>: red</span><br></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><code>Css</code> 预编译器把变量赋予作用域，也就是存在生命周期。就像 <code>js </code>一样，它会先从局部作用域查找变量，依次向上级作用域查找</p><p><code>sass</code>中不存在全局变量</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$<span class="attribute">color</span>: black;</span><br><span class="line"><span class="selector-class">.scoped</span> &#123;</span><br><span class="line">  $bg: blue;</span><br><span class="line">  $<span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">color</span>: $color;</span><br><span class="line">  <span class="attribute">background-color</span>:$bg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.unscoped</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:$color;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scoped</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:white;<span class="comment">/*是白色*/</span></span><br><span class="line">  <span class="attribute">background-color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.unscoped</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:white;<span class="comment">/*白色（无全局变量概念）*/</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>所以，在<code>sass</code>中最好不要定义相同的变量名</p><p><code>less</code>与<code>stylus</code>的作用域跟<code>javascript</code>十分的相似，首先会查找局部定义的变量，如果没有找到，会像冒泡一样，一级一级往下查找，直到根为止</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@color</span>: black;</span><br><span class="line"><span class="selector-class">.scoped</span> &#123;</span><br><span class="line">  <span class="keyword">@bg</span>: blue;</span><br><span class="line">  <span class="keyword">@color</span>: white;</span><br><span class="line">  <span class="attribute">color</span>: @color;</span><br><span class="line">  <span class="attribute">background-color</span>:@bg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.unscoped</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:@color;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scoped</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:white;<span class="comment">/*白色（调用了局部变量）*/</span></span><br><span class="line">  <span class="attribute">background-color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.unscoped</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:black;<span class="comment">/*黑色（调用了全局变量）*/</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><p>混入（mixin）应该说是预处理器最精髓的功能之一了，简单点来说，<code>Mixins</code>可以将一部分样式抽出，作为单独定义的模块，被很多选择器重复使用</p><p>可以在<code>Mixins</code>中定义变量或者默认参数</p><p>在<code>less</code>中，混合的用法是指将定义好的<code>ClassA</code>中引入另一个已经定义的<code>Class</code>，也能使用够传递参数，参数变量为<code>@</code>声明</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.alert</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.highlight</span>(<span class="keyword">@color</span>: red) &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: @color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.heads-up</span> &#123;</span><br><span class="line">  <span class="selector-class">.alert</span>;</span><br><span class="line">  <span class="selector-class">.highlight</span>(red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.alert</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heads-up</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Sass</code>声明<code>mixins</code>时需要使用<code>@mixinn</code>，后面紧跟<code>mixin</code>的名，也可以设置参数，参数名为变量<code>$</code>声明的形式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> large-text &#123;</span><br><span class="line">  <span class="attribute">font</span>: &#123;</span><br><span class="line">    family: Arial;</span><br><span class="line">    size: <span class="number">20px</span>;</span><br><span class="line">    weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.page-title</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> large-text;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>stylus</code>中的混合和前两款<code>Css</code>预处理器语言的混合略有不同，他可以不使用任何符号，就是直接声明<code>Mixins</code>名，然后在定义参数和默认值之间用等号（&#x3D;）来连接</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error(borderWidth= <span class="number">2px</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: borderWidth solid <span class="number">#F00</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#F00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.generic-error</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">4px</span>;</span><br><span class="line">  error(); <span class="comment">/* 调用error mixins */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.login-error</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">  error(<span class="number">5px</span>); <span class="comment">/* 调用error mixins，并将参数$borderWidth的值指定为5px */</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="代码模块化"><a href="#代码模块化" class="headerlink" title="代码模块化"></a>代码模块化</h3><p>模块化就是将<code>Css</code>代码分成一个个模块</p><p><code>scss</code>、<code>less</code>、<code>stylus</code>三者的使用方法都如下所示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./common&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./github-markdown&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./mixin&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./variables&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://jelly.jd.com/article/5dcb9c73641a030153732a89">https://jelly.jd.com/article/5dcb9c73641a030153732a89</a></li><li><a href="https://zhuanlan.zhihu.com/p/23382462">https://zhuanlan.zhihu.com/p/23382462</a></li><li><a href="https://baike.baidu.com/item/Less/17570158">https://baike.baidu.com/item/Less/17570158</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_sass_less_stylus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备像素、css像素、设备独立像素、dpr、ppi 之间的区别？</title>
      <link href="/2018/08/06/css-dp-px-dpr-ppi/"/>
      <url>/2018/08/06/css-dp-px-dpr-ppi/</url>
      
        <content type="html"><![CDATA[<h1 id="设备像素、css像素、设备独立像素、dpr、ppi-之间的区别？"><a href="#设备像素、css像素、设备独立像素、dpr、ppi-之间的区别？" class="headerlink" title="设备像素、css像素、设备独立像素、dpr、ppi 之间的区别？"></a>设备像素、css像素、设备独立像素、dpr、ppi 之间的区别？</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>在<code>css</code>中我们通常使用px作为单位，在PC浏览器中<code>css</code>的1个像素都是对应着电脑屏幕的1个物理像素</p><p>这会造成一种错觉，我们会认为<code>css</code>中的像素就是设备的物理像素</p><p>但实际情况却并非如此，<code>css</code>中的像素只是一个抽象的单位，在不同的设备或不同的环境中，<code>css</code>中的1px所代表的设备物理像素是不同的</p><p>当我们做移动端开发时，同为1px的设置，在不同分辨率的移动设备上显示效果却有很大差异</p><p>这背后就涉及了css像素、设备像素、设备独立像素、dpr、ppi的概念</p><h2 id="二、介绍"><a href="#二、介绍" class="headerlink" title="二、介绍"></a>二、介绍</h2><h3 id="CSS像素"><a href="#CSS像素" class="headerlink" title="CSS像素"></a>CSS像素</h3><p>CSS像素（css pixel, px）: 适用于web编程，在 CSS 中以 px 为后缀，是一个长度单位</p><p>在 CSS 规范中，长度单位可以分为两类，绝对单位以及相对单位</p><p>px是一个相对单位，相对的是设备像素（device pixel）</p><p>一般情况，页面缩放比为1，1个CSS像素等于1个设备独立像素</p><p><code>CSS</code>像素又具有两个方面的相对性：</p><ul><li>在同一个设备上，每1个 CSS 像素所代表的设备像素是可以变化的（比如调整屏幕的分辨率）</li><li>在不同的设备之间，每1个 CSS 像素所代表的设备像素是可以变化的（比如两个不同型号的手机）</li></ul><p>在页面进行缩放操作也会 引起<code>css</code>中<code>px</code>的变化，假设页面放大一倍，原来的 1px 的东西变成 2px，在实际宽度不变的情况下1px 变得跟原来的 2px 的长度（长宽）一样了（元素会占据更多的设备像素）</p><p>假设原来需要 320px 才能填满的宽度现在只需要 160px</p><p>px会受到下面的因素的影响而变化：</p><ul><li>每英寸像素（PPI）</li><li>设备像素比（DPR）</li></ul><h3 id="设备像素"><a href="#设备像素" class="headerlink" title="设备像素"></a>设备像素</h3><p>设备像素（device pixels），又称为物理像素</p><p>指设备能控制显示的最小物理单位，不一定是一个小正方形区块，也没有标准的宽高，只是用于显示丰富色彩的一个“点”而已</p><p>可以参考公园里的景观变色彩灯，一个彩灯(物理像素)由红、蓝、绿小灯组成，三盏小灯不同的亮度混合出各种色彩</p><p> <img src="https://static.vue-js.com/cffc6570-91f2-11eb-ab90-d9ae814b240d.png"></p><p>从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，单位为<code>pt</code></p><h3 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h3><p>设备独立像素（Device Independent Pixel）：与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括了CSS像素</p><p>在<code>javaScript</code>中可以通过<code>window.screen.width/ window.screen.height</code> 查看</p><p>比如我们会说“电脑屏幕在 2560x1600分辨率下不适合玩游戏，我们把它调为 1440x900”，这里的“分辨率”（非严谨说法）指的就是设备独立像素</p><p>一个设备独立像素里可能包含1个或者多个物理像素点，包含的越多则屏幕看起来越清晰</p><p>至于为什么出现设备独立像素这种虚拟像素单位概念，下面举个例子：</p><p>iPhone 3GS 和 iPhone 4&#x2F;4s 的尺寸都是 3.5 寸，但 iPhone 3GS 的分辨率是 320x480，iPhone 4&#x2F;4s 的分辨率是 640x960</p><p>这意味着，iPhone 3GS 有 320 个物理像素，iPhone 4&#x2F;4s 有 640 个物理像素</p><p>如果我们按照真实的物理像素进行布局，比如说我们按照 320 物理像素进行布局，到了 640 物理像素的手机上就会有一半的空白，为了避免这种问题，就产生了虚拟像素单位</p><p>我们统一 iPhone 3GS 和 iPhone 4&#x2F;4s 都是 320 个虚拟像素，只是在 iPhone 3GS 上，最终 1 个虚拟像素换算成 1 个物理像素，在 iphone 4s 中，1 个虚拟像素最终换算成 2 个物理像素</p><p>至于 1 个虚拟像素被换算成几个物理像素，这个数值我们称之为设备像素比，也就是下面介绍的<code>dpr</code></p><h3 id="dpr"><a href="#dpr" class="headerlink" title="dpr"></a>dpr</h3><p>dpr（device pixel ratio），设备像素比，代表设备独立像素到设备像素的转换关系，在<code>JavaScript</code>中可以通过 <code>window.devicePixelRatio</code> 获取</p><p>计算公式如下：</p><p> <img src="https://static.vue-js.com/dd45e2b0-91f2-11eb-ab90-d9ae814b240d.png"></p><p>当设备像素比为1:1时，使用1（1×1）个设备像素显示1个CSS像素</p><p>当设备像素比为2:1时，使用4（2×2）个设备像素显示1个CSS像素</p><p>当设备像素比为3:1时，使用9（3×3）个设备像素显示1个CSS像素</p><p>如下图所示：</p><p><img src="https://static.vue-js.com/e63cceb0-91f2-11eb-ab90-d9ae814b240d.png"></p><p>当<code>dpr</code>为3，那么<code>1px</code>的<code>CSS</code>像素宽度对应<code>3px</code>的物理像素的宽度，1px的<code>CSS</code>像素高度对应<code>3px</code>的物理像素高度</p><h3 id="ppi"><a href="#ppi" class="headerlink" title="ppi"></a>ppi</h3><p>ppi （pixel per inch），每英寸像素，表示每英寸所包含的像素点数目，更确切的说法应该是像素密度。数值越高，说明屏幕能以更高密度显示图像</p><p>计算公式如下：</p><p> <img src="https://static.vue-js.com/f734adf0-91f2-11eb-ab90-d9ae814b240d.png"></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>无缩放情况下，1个CSS像素等于1个设备独立像素</p><p>设备像素由屏幕生产之后就不发生改变，而设备独立像素是一个虚拟单位会发生改变</p><p>PC端中，1个设备独立像素 &#x3D; 1个设备像素 （在100%，未缩放的情况下）</p><p>在移动端中，标准屏幕（160ppi）下 1个设备独立像素 &#x3D; 1个设备像素</p><p>设备像素比（dpr） &#x3D; 设备像素 &#x2F; 设备独立像素</p><p>每英寸像素（ppi），值越大，图像越清晰</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSS_pixel">https://developer.mozilla.org/zh-CN/docs/Glossary/CSS_pixel</a></li><li><a href="https://hijiangtao.github.io/2017/07/09/Device-Viewport-and-Pixel-Introduction/">https://hijiangtao.github.io/2017/07/09/Device-Viewport-and-Pixel-Introduction/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_dp_px_dpr_ppi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么理解回流跟重绘？什么场景下会触发？</title>
      <link href="/2018/06/06/css-layout-paint/"/>
      <url>/2018/06/06/css-layout-paint/</url>
      
        <content type="html"><![CDATA[<h1 id="怎么理解回流跟重绘？什么场景下会触发？"><a href="#怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="怎么理解回流跟重绘？什么场景下会触发？"></a>怎么理解回流跟重绘？什么场景下会触发？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>在<code>HTML</code>中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘：</p><ul><li><p>回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置</p></li><li><p>重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制</p></li></ul><p>具体的浏览器解析渲染机制如下所示：</p><p> <img src="https://static.vue-js.com/2b56a950-9cdc-11eb-ab90-d9ae814b240d.png"></p><ul><li><p>解析HTML，生成DOM树，解析CSS，生成CSSOM树</p></li><li><p>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</p></li><li><p>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</p></li><li><p>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</p></li><li><p>Display:将像素发送给GPU，展示在页面上</p></li></ul><p>在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变</p><p>当我们对 <code>DOM</code> 的修改引发了 <code>DOM </code>几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来</p><p>当我们对 <code>DOM </code>的修改导致了样式的变化（<code>color</code>或<code>background-color</code>），却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了重绘</p><h2 id="二、如何触发"><a href="#二、如何触发" class="headerlink" title="二、如何触发"></a>二、如何触发</h2><p>要想减少回流和重绘的次数，首先要了解回流和重绘是如何触发的</p><h3 id="回流触发时机"><a href="#回流触发时机" class="headerlink" title="回流触发时机"></a>回流触发时机</h3><p>回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：</p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代</li><li>页面一开始渲染的时候（这避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul><p>还有一些容易被忽略的操作：获取一些特定属性的值</p><blockquote><p>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</p></blockquote><p>这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流</p><p>除此还包括<code>getComputedStyle </code>方法，原理是一样的</p><h3 id="重绘触发时机"><a href="#重绘触发时机" class="headerlink" title="重绘触发时机"></a>重绘触发时机</h3><p>触发回流一定会触发重绘</p><p>可以把页面理解为一个黑板，黑板上有一朵画好的小花。现在我们要把这朵从左边移到了右边，那我们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜色（重绘）</p><p>除此之外还有一些其他引起重绘行为：</p><ul><li><p>颜色的修改</p></li><li><p>文本方向的修改</p></li><li><p>阴影的修改</p></li></ul><h3 id="浏览器优化机制"><a href="#浏览器优化机制" class="headerlink" title="浏览器优化机制"></a>浏览器优化机制</h3><p>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列</p><p>当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的<code>offsetTop</code>等方法都会返回最新的数据</p><p>因此浏览器不得不清空队列，触发回流重绘来返回正确的值</p><h2 id="三、如何减少"><a href="#三、如何减少" class="headerlink" title="三、如何减少"></a>三、如何减少</h2><p>我们了解了如何触发回流和重绘的场景，下面给出避免回流的经验：</p><ul><li>如果想设定元素的样式，通过改变元素的 <code>class</code> 类名 (尽可能在 DOM 树的最里层)</li><li>避免设置多项内联样式</li><li>应用元素的动画，使用 <code>position</code> 属性的 <code>fixed</code> 值或 <code>absolute</code> 值(如前文示例所提)</li><li>避免使用 <code>table</code> 布局，<code>table</code> 中每个元素的大小以及内容的改动，都会导致整个 <code>table</code> 的重新计算</li><li>对于那些复杂的动画，对其设置 <code>position: fixed/absolute</code>，尽可能地使元素脱离文档流，从而减少对其他元素的影响</li><li>使用css3硬件加速，可以让<code>transform</code>、<code>opacity</code>、<code>filters</code>这些动画不会引起回流重绘</li><li>避免使用 CSS 的 <code>JavaScript</code> 表达式</li></ul><p>在使用 <code>JavaScript</code> 动态插入多个节点时, 可以使用<code>DocumentFragment</code>. 创建后一次插入. 就能避免多次的渲染性能</p><p>但有时候，我们会无可避免地进行回流或者重绘，我们可以更好使用它们</p><p>例如，多次修改一个把元素布局的时候，我们很可能会如下操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;el&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">top</span>  = el.<span class="property">offsetTop</span>  + <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">left</span> = el.<span class="property">offsetLeft</span> + <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次循环都需要获取多次<code>offset</code>属性，比较糟糕，可以使用变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存offsetLeft与offsetTop的值</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;el&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> offLeft = el.<span class="property">offsetLeft</span>, offTop = el.<span class="property">offsetTop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JS层面进行计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">  offLeft += <span class="number">10</span></span><br><span class="line">  offTop  += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性将计算结果应用到DOM上</span></span><br><span class="line">el.<span class="property">style</span>.<span class="property">left</span> = offLeft + <span class="string">&quot;px&quot;</span></span><br><span class="line">el.<span class="property">style</span>.<span class="property">top</span> = offTop  + <span class="string">&quot;px&quot;</span></span><br></pre></td></tr></table></figure><p>我们还可避免改变样式，使用类名去合并样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">container.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;10px solid red&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br></pre></td></tr></table></figure><p>使用类名去合并样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.basic_style</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">10px</span> solid red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    container.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;basic_style&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前者每次单独操作，都去触发一次渲染树更改（新浏览器不会），</p><p>都去触发一次渲染树更改，从而导致相应的回流与重绘过程</p><p>合并之后，等于我们将所有的更改一次性发出</p><p>我们还可以通过通过设置元素属性<code>display: none</code>，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">container.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;10px solid red&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br></pre></td></tr></table></figure><p>离线操作后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">container.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;10px solid red&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br><span class="line">container.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://juejin.cn/post/6844903942137053192">https://juejin.cn/post/6844903942137053192</a></p></li><li><p><a href="https://segmentfault.com/a/1190000017329980">https://segmentfault.com/a/1190000017329980</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_layout_paint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如果要做优化，CSS提高性能的方法有哪些？</title>
      <link href="/2018/06/06/css-performance/"/>
      <url>/2018/06/06/css-performance/</url>
      
        <content type="html"><![CDATA[<h1 id="如果要做优化，CSS提高性能的方法有哪些？"><a href="#如果要做优化，CSS提高性能的方法有哪些？" class="headerlink" title="如果要做优化，CSS提高性能的方法有哪些？"></a>如果要做优化，CSS提高性能的方法有哪些？</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>每一个网页都离不开<code>css</code>，但是很多人又认为，<code>css</code>主要是用来完成页面布局的，像一些细节或者优化，就不需要怎么考虑，实际上这种想法是不正确的</p><p>作为页面渲染和内容展现的重要环节，<code>css</code>影响着用户对整个网站的第一体验</p><p>因此，在整个产品研发过程中，<code>css</code>性能优化同样需要贯穿全程</p><h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><p>实现方式有很多种，主要有如下：</p><ul><li>内联首屏关键CSS</li><li>异步加载CSS</li><li>资源压缩</li><li>合理使用选择器</li><li>减少使用昂贵的属性</li><li>不要使用@import</li></ul><h3 id="内联首屏关键CSS"><a href="#内联首屏关键CSS" class="headerlink" title="内联首屏关键CSS"></a>内联首屏关键CSS</h3><p>在打开一个页面，页面首要内容出现在屏幕的时间影响着用户的体验，而通过内联<code>css</code>关键代码能够使浏览器在下载完<code>html</code>后就能立刻渲染</p><p>而如果外部引用<code>css</code>代码，在解析<code>html</code>结构过程中遇到外部<code>css</code>文件，才会开始下载<code>css</code>代码，再渲染</p><p>所以，<code>CSS</code>内联使用使渲染时间提前</p><p>注意：但是较大的<code>css</code>代码并不合适内联（初始拥塞窗口、没有缓存），而其余代码则采取外部引用方式</p><h3 id="异步加载CSS"><a href="#异步加载CSS" class="headerlink" title="异步加载CSS"></a>异步加载CSS</h3><p>在<code>CSS</code>文件请求、下载、解析完成之前，<code>CSS</code>会阻塞渲染，浏览器将不会渲染任何已处理的内容</p><p>前面加载内联代码后，后面的外部引用<code>css</code>则没必要阻塞浏览器渲染。这时候就可以采取异步加载的方案，主要有如下：</p><ul><li>使用javascript将link标签插到head标签最后</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建link标签</span></span><br><span class="line"><span class="keyword">const</span> myCSS = <span class="variable language_">document</span>.<span class="title function_">createElement</span>( <span class="string">&quot;link&quot;</span> );</span><br><span class="line">myCSS.<span class="property">rel</span> = <span class="string">&quot;stylesheet&quot;</span>;</span><br><span class="line">myCSS.<span class="property">href</span> = <span class="string">&quot;mystyles.css&quot;</span>;</span><br><span class="line"><span class="comment">// 插入到header的最后位置</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">insertBefore</span>( myCSS, <span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">childNodes</span>[ <span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">childNodes</span>.<span class="property">length</span> - <span class="number">1</span> ].<span class="property">nextSibling</span> );</span><br></pre></td></tr></table></figure><ul><li>设置link标签media属性为noexis，浏览器会认为当前样式表不适用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完成后，将<code>media</code>的值设为<code>screen</code>或<code>all</code>，从而让浏览器开始解析CSS</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyles.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;noexist&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;this.media=&#x27;all&#x27;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将rel设回stylesheet</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;alternate stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyles.css&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;this.rel=&#x27;stylesheet&#x27;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="资源压缩"><a href="#资源压缩" class="headerlink" title="资源压缩"></a>资源压缩</h3><p>利用<code>webpack</code>、<code>gulp/grunt</code>、<code>rollup</code>等模块化工具，将<code>css</code>代码进行压缩，使文件变小，大大降低了浏览器的加载时间</p><h3 id="合理使用选择器"><a href="#合理使用选择器" class="headerlink" title="合理使用选择器"></a>合理使用选择器</h3><p><code>css</code>匹配的规则是从右往左开始匹配，例如<code>#markdown .content h3</code>匹配规则如下：</p><ul><li>先找到h3标签元素</li><li>然后去除祖先不是.content的元素</li><li>最后去除祖先不是#markdown的元素</li></ul><p>如果嵌套的层级更多，页面中的元素更多，那么匹配所要花费的时间代价自然更高</p><p>所以我们在编写选择器的时候，可以遵循以下规则：</p><ul><li>不要嵌套使用过多复杂选择器，最好不要三层以上</li><li>使用id选择器就没必要再进行嵌套</li><li>通配符和属性选择器效率最低，避免使用</li></ul><h3 id="减少使用昂贵的属性"><a href="#减少使用昂贵的属性" class="headerlink" title="减少使用昂贵的属性"></a>减少使用昂贵的属性</h3><p>在页面发生重绘的时候，昂贵属性如<code>box-shadow</code>&#x2F;<code>border-radius</code>&#x2F;<code>filter</code>&#x2F;透明度&#x2F;<code>:nth-child</code>等，会降低浏览器的渲染性能</p><h3 id="不要使用-import"><a href="#不要使用-import" class="headerlink" title="不要使用@import"></a>不要使用@import</h3><p>css样式文件有两种引入方式，一种是<code>link</code>元素，另一种是<code>@import</code></p><p><code>@import</code>会影响浏览器的并行下载，使得页面在加载时增加额外的延迟，增添了额外的往返耗时</p><p>而且多个<code>@import</code>可能会导致下载顺序紊乱</p><p>比如一个css文件<code>index.css</code>包含了以下内容：<code>@import url(&quot;reset.css&quot;)</code></p><p>那么浏览器就必须先把<code>index.css</code>下载、解析和执行后，才下载、解析和执行第二个文件<code>reset.css</code></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>减少重排操作，以及减少不必要的重绘</li><li>了解哪些属性可以继承而来，避免对这些属性重复编写</li><li>cssSprite，合成所有icon图片，用宽高加上backgroud-position的背景图方式显现出我们要的icon图，减少了http请求</li><li>把小的icon图片转成base64编码</li><li>CSS3动画或者过渡尽量使用transform和opacity来实现动画，不要使用left和top属性</li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><code>css</code>实现性能的方式可以从选择器嵌套、属性特性、减少<code>http</code>这三面考虑，同时还要注意<code>css</code>代码的加载顺序</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.zhihu.com/question/19886806">https://www.zhihu.com/question/19886806</a></li><li><a href="https://juejin.cn/post/6844903649605320711#heading-1">https://juejin.cn/post/6844903649605320711#heading-1</a></li><li><a href="https://vue3js.cn/interview/">https://vue3js.cn/interview/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？</title>
      <link href="/2018/05/06/css-column-layout/"/>
      <url>/2018/05/06/css-column-layout/</url>
      
        <content type="html"><![CDATA[<h1 id="如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？"><a href="#如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？" class="headerlink" title="如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？"></a>如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>在日常布局中，无论是两栏布局还是三栏布局，使用的频率都非常高</p><h3 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h3><p>两栏布局实现效果就是将页面分割成左右宽度不等的两列，宽度较小的列设置为固定宽度，剩余宽度由另一列撑满，</p><p>比如 <code>Ant Design</code> 文档，蓝色区域为主要内容布局容器，侧边栏为次要内容布局容器</p><blockquote><p>这里称宽度较小的列父元素为次要布局容器，宽度较大的列父元素为主要布局容器</p></blockquote><p> <img src="https://static.vue-js.com/fcb8ac50-976e-11eb-85f6-6fac77c0c9b3.png"></p><p>这种布局适用于内容上具有明显主次关系的网页</p><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><p>三栏布局按照左中右的顺序进行排列，通常中间列最宽，左右两列次之</p><p>大家最常见的就是<code>github</code>：</p><p> <img src="https://static.vue-js.com/0bf016e0-976f-11eb-ab90-d9ae814b240d.png"></p><h2 id="二、两栏布局"><a href="#二、两栏布局" class="headerlink" title="二、两栏布局"></a>二、两栏布局</h2><p>两栏布局非常常见，往往是以一个定宽栏和一个自适应的栏并排展示存在</p><p>实现思路也非常的简单：</p><ul><li>使用 float 左浮左边栏</li><li>右边模块使用 margin-left 撑出内容块做内容展示</li><li>为父级元素添加BFC，防止下方元素飞到上方内容</li></ul><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: hidden; 添加BFC</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: gray;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-left</span>: <span class="number">210px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: lightgray;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有一种更为简单的使用则是采取：flex弹性布局</p><h3 id="flex弹性布局"><a href="#flex弹性布局" class="headerlink" title="flex弹性布局"></a>flex弹性布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>flex</code>可以说是最好的方案了，代码少，使用简单</p><p>注意的是，<code>flex</code>容器的一个默认属性值:<code>align-items: stretch;</code></p><p>这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: <code>align-items: flex-start</code></p><h2 id="三、三栏布局"><a href="#三、三栏布局" class="headerlink" title="三、三栏布局"></a>三、三栏布局</h2><p>实现三栏布局中间自适应的布局方式有：</p><ul><li>两边使用 float，中间使用 margin</li><li>两边使用 absolute，中间使用 margin</li><li>两边使用 float 和负 margin</li><li>display: table 实现</li><li>flex实现</li><li>grid网格布局</li></ul><h3 id="两边使用-float，中间使用-margin"><a href="#两边使用-float，中间使用-margin" class="headerlink" title="两边使用 float，中间使用 margin"></a>两边使用 float，中间使用 margin</h3><p>需要将中间的内容放在<code>html</code>结构最后，否则右侧会臣在中间内容的下方</p><p>实现代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.wrap</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#eee</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: hidden; &lt;!-- 生成BFC，计算高度时考虑浮动的元素 --&gt;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: coral;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: lightblue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-left</span>: <span class="number">220px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: lightpink;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-right</span>: <span class="number">140px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原理如下：</p><ul><li>两边固定宽度，中间宽度自适应。</li><li>利用中间元素的margin值控制两边的间距</li><li>宽度小于左右部分宽度之和时，右侧部分会被挤下去</li></ul><p>这种实现方式存在缺陷：</p><ul><li><p>主体内容是最后加载的。</p></li><li><p>右边在主体内容之前，如果是响应式设计，不能简单的换行展示</p></li></ul><h3 id="两边使用-absolute，中间使用-margin"><a href="#两边使用-absolute，中间使用-margin" class="headerlink" title="两边使用 absolute，中间使用 margin"></a>两边使用 absolute，中间使用 margin</h3><p>基于绝对定位的三栏布局：注意绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑HTML中结构的顺序</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  </span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.right</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">110px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: black;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左边固定宽度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右边固定宽度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>中间自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现流程：</p><ul><li>左右两边使用绝对定位，固定在两侧。</li><li>中间占满一行，但通过 margin和左右两边留出10px的间隔</li></ul><h3 id="两边使用-float-和负-margin"><a href="#两边使用-float-和负-margin" class="headerlink" title="两边使用 float 和负 margin"></a>两边使用 float 和负 margin</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.right</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.main-wrapper</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">110px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: black;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: -<span class="number">100px</span>; <span class="comment">/* 同自身宽度 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>中间自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左边固定宽度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右边固定宽度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现过程：</p><ul><li>中间使用了双层标签，外层是浮动的，以便左中右能在同一行展示</li><li>左边通过使用负 margin-left:-100%，相当于中间的宽度，所以向上偏移到左侧</li><li>右边通过使用负 margin-left:-100px，相当于自身宽度，所以向上偏移到最右侧</li></ul><p>缺点：</p><ul><li>增加了 .main-wrapper 一层，结构变复杂</li><li>使用负 margin，调试也相对麻烦</li></ul><h3 id="使用-display-table-实现"><a href="#使用-display-table-实现" class="headerlink" title="使用 display: table 实现"></a>使用 display: table 实现</h3><p><code>&lt;table&gt;</code> 标签用于展示行列数据，不适合用于布局。但是可以使用 <code>display: table</code> 来实现布局的效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: table;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">table-layout</span>: fixed;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.right</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: black;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左边固定宽度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>中间自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右边固定宽度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现原理：</p><ul><li>层通过 display: table设置为表格，设置 table-layout: fixed&#96;表示列宽自身宽度决定，而不是自动计算。</li><li>内层的左中右通过 display: table-cell设置为表格单元。</li><li>左右设置固定宽度，中间设置 width: 100% 填充剩下的宽度</li></ul><h3 id="使用flex实现"><a href="#使用flex实现" class="headerlink" title="使用flex实现"></a>使用flex实现</h3><p>利用<code>flex</code>弹性布局，可以简单实现中间自适应</p><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.wrap</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">justify-content</span>: space-between;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.right</span>,</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: coral;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: lightblue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#555</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现过程：</p><ul><li>仅需将容器设置为<code>display:flex;</code>，</li><li>盒内元素两端对其，将中间元素设置为<code>100%</code>宽度，或者设为<code>flex:1</code>，即可填充空白</li><li>盒内元素的高度撑开容器的高度</li></ul><p>优点：</p><ul><li>结构简单直观</li><li>可以结合 flex的其他功能实现更多效果，例如使用 order属性调整显示顺序，让主体内容优先加载，但展示在中间</li></ul><h3 id="grid网格布局"><a href="#grid网格布局" class="headerlink" title="grid网格布局"></a>grid网格布局</h3><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.wrap</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-template-columns</span>: <span class="number">300px</span> auto <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.right</span>,</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: coral;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: lightblue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#555</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>跟<code>flex</code>弹性布局一样的简单</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://zhuqingguang.github.io/2017/08/16/adapting-two-layout/">https://zhuqingguang.github.io/2017/08/16/adapting-two-layout/</a></p></li><li><p><a href="https://segmentfault.com/a/1190000008705541">https://segmentfault.com/a/1190000008705541</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_column_layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍一下grid网格布局</title>
      <link href="/2018/04/16/css-grid/"/>
      <url>/2018/04/16/css-grid/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍一下grid网格布局"><a href="#介绍一下grid网格布局" class="headerlink" title="介绍一下grid网格布局"></a>介绍一下grid网格布局</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>Grid</code> 布局即网格布局，是一个二维的布局方式，由纵横相交的两组网格线形成的框架性布局结构，能够同时处理行与列</p><p>擅长将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系</p><p> <img src="https://static.vue-js.com/59680a40-9a94-11eb-85f6-6fac77c0c9b3.png"></p><p>这与之前讲到的<code>flex</code>一维布局不相同</p><p>设置<code>display:grid/inline-grid</code>的元素就是网格布局容器，这样就能出发浏览器渲染引擎的网格布局算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;sub-item&quot;</span>&gt;</span>&lt;/p &gt;</span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br></pre></td></tr></table></figure><p>上述代码实例中，<code>.container</code>元素就是网格布局容器，<code>.item</code>元素就是网格的项目，由于网格元素只能是容器的顶层子元素，所以<code>p</code>元素并不是网格元素</p><p>这里提一下，网格线概念，有助于下面对<code>grid-column</code>系列属性的理解</p><p>网格线，即划分网格的线，如下图所示：</p><p> <img src="https://static.vue-js.com/61be7080-9a94-11eb-ab90-d9ae814b240d.png"></p><p>上图是一个 2 x 3 的网格，共有3根水平网格线和4根垂直网格线</p><h2 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h2><p>同样，<code>Grid</code> 布局属性可以分为两大类：</p><ul><li>容器属性，</li><li>项目属性</li></ul><p>关于容器属性有如下：</p><h3 id="display-属性"><a href="#display-属性" class="headerlink" title="display 属性"></a>display 属性</h3><p>文章开头讲到，在元素上设置<code>display：grid</code> 或 <code>display：inline-grid</code> 来创建一个网格容器</p><ul><li><p>display：grid 则该容器是一个块级元素</p></li><li><p>display: inline-grid 则容器元素为行内元素</p></li></ul><h3 id="grid-template-columns-属性，grid-template-rows-属性"><a href="#grid-template-columns-属性，grid-template-rows-属性" class="headerlink" title="grid-template-columns 属性，grid-template-rows 属性"></a>grid-template-columns 属性，grid-template-rows 属性</h3><p><code>grid-template-columns</code> 属性设置列宽，<code>grid-template-rows</code> 属性设置行高</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="comment">/*  声明了三列，宽度分别为 200px 200px 200px */</span></span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">200px</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="comment">/*  声明了两行，行高分别为 50px 50px  */</span></span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上表示固定列宽为 200px 200px 200px，行高为 50px 50px</p><p>上述代码可以看到重复写单元格宽高，通过使用<code>repeat()</code>函数，可以简写重复的值</p><ul><li>第一个参数是重复的次数</li><li>第二个参数是重复的值</li></ul><p>所以上述代码可以简写成</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>,<span class="number">200px</span>);</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>:<span class="built_in">repeat</span>(<span class="number">2</span>,<span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上述的<code>repeact</code>关键字，还有：</p><ul><li>auto-fill：示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格</li></ul><blockquote><p><code>grid-template-columns: repeat(auto-fill, 200px)</code> 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素</p></blockquote><ul><li>fr：片段，为了方便表示比例关系</li></ul><blockquote><p><code>grid-template-columns: 200px 1fr 2fr</code> 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1&#x2F;3 和 2&#x2F;3</p></blockquote><ul><li>minmax：产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。第一个参数就是最小值，第二个参数就是最大值</li></ul><blockquote><p><code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code></p></blockquote><ul><li>auto：由浏览器自己决定长度</li></ul><blockquote><p><code>grid-template-columns: 100px auto 100px</code> 表示第一第三列为 100px，中间由浏览器决定长度</p></blockquote><h3 id="grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性"><a href="#grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性" class="headerlink" title="grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性"></a>grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性</h3><p><code>grid-row-gap</code> 属性、<code>grid-column-gap</code> 属性分别设置行间距和列间距。<code>grid-gap</code> 属性是两者的简写形式</p><p><code>grid-row-gap: 10px</code> 表示行间距是 10px</p><p><code>grid-column-gap: 20px</code> 表示列间距是 20px</p><p><code>grid-gap: 10px 20px</code> 等同上述两个属性</p><h3 id="grid-template-areas-属性"><a href="#grid-template-areas-属性" class="headerlink" title="grid-template-areas 属性"></a>grid-template-areas 属性</h3><p>用于定义区域，一个区域由一个或者多个单元格组成</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: <span class="string">&#x27;a b c&#x27;</span></span><br><span class="line">                       <span class="string">&#x27;d e f&#x27;</span></span><br><span class="line">                       <span class="string">&#x27;g h i&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码先划分出9个单元格，然后将其定名为<code>a</code>到<code>i</code>的九个区域，分别对应这九个单元格。</p><p>多个单元格合并成一个区域的写法如下</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">grid-template-areas</span>: <span class="string">&#x27;a a a&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;b b b&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;c c c&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码将9个单元格分成<code>a</code>、<code>b</code>、<code>c</code>三个区域</p><p>如果某些区域不需要利用，则使用”点”（<code>.</code>）表示</p><h3 id="grid-auto-flow-属性"><a href="#grid-auto-flow-属性" class="headerlink" title="grid-auto-flow 属性"></a>grid-auto-flow 属性</h3><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。</p><p>顺序就是由<code>grid-auto-flow</code>决定，默认为行，代表”先行后列”，即先填满第一行，再开始放入第二行</p><p> <img src="https://static.vue-js.com/70fb3240-9a94-11eb-ab90-d9ae814b240d.png"></p><p>当修改成<code>column</code>后，放置变为如下：</p><p><img src="https://static.vue-js.com/7c26ffa0-9a94-11eb-ab90-d9ae814b240d.png"></p><h3 id="justify-items-属性，-align-items-属性，-place-items-属性"><a href="#justify-items-属性，-align-items-属性，-place-items-属性" class="headerlink" title="justify-items 属性， align-items 属性， place-items 属性"></a>justify-items 属性， align-items 属性， place-items 属性</h3><p><code>justify-items</code> 属性设置单元格内容的水平位置（左中右），<code>align-items</code> 属性设置单元格的垂直位置（上中下）</p><p>两者属性的值完成相同</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  justify-items: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-items</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性对应如下：</p><ul><li>start：对齐单元格的起始边缘</li><li>end：对齐单元格的结束边缘</li><li>center：单元格内部居中</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）</li></ul><p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式</p><h3 id="justify-content-属性，-align-content-属性，-place-content-属性"><a href="#justify-content-属性，-align-content-属性，-place-content-属性" class="headerlink" title="justify-content 属性， align-content 属性， place-content 属性"></a>justify-content 属性， align-content 属性， place-content 属性</h3><p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">  <span class="attribute">align-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个属性的写法完全相同，都可以取下面这些值：</p><ul><li>start - 对齐容器的起始边框</li><li>end - 对齐容器的结束边框</li><li>center - 容器内部居中</li></ul><p> <img src="https://static.vue-js.com/9d1ec990-9a94-11eb-ab90-d9ae814b240d.png"></p><ul><li><p>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍</p></li><li><p>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔</p></li><li><p>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</p></li><li><p>stretch - 项目大小没有指定时，拉伸占据整个网格容器</p></li></ul><p> <img src="https://static.vue-js.com/a620b210-9a94-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="grid-auto-columns-属性和-grid-auto-rows-属性"><a href="#grid-auto-columns-属性和-grid-auto-rows-属性" class="headerlink" title="grid-auto-columns 属性和 grid-auto-rows 属性"></a>grid-auto-columns 属性和 grid-auto-rows 属性</h3><p>有时候，一些项目的指定位置，在现有网格的外部，就会产生显示网格和隐式网格</p><p>比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。超出的部分就是隐式网格</p><p>而<code>grid-auto-rows</code>与<code>grid-auto-columns</code>就是专门用于指定隐式网格的宽高</p><p>关于项目属性，有如下：</p><h3 id="grid-column-start-属性、grid-column-end-属性、grid-row-start-属性以及grid-row-end-属性"><a href="#grid-column-start-属性、grid-column-end-属性、grid-row-start-属性以及grid-row-end-属性" class="headerlink" title="grid-column-start 属性、grid-column-end 属性、grid-row-start 属性以及grid-row-end 属性"></a>grid-column-start 属性、grid-column-end 属性、grid-row-start 属性以及grid-row-end 属性</h3><p>指定网格项目所在的四个边框，分别定位在哪根网格线，从而指定项目的位置</p><ul><li>grid-column-start 属性：左边框所在的垂直网格线</li><li>grid-column-end 属性：右边框所在的垂直网格线</li><li>grid-row-start 属性：上边框所在的水平网格线</li><li>grid-row-end 属性：下边框所在的水平网格线</li></ul><p>举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#container</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item-1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">grid-column-end</span>: <span class="number">4</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过设置<code>grid-column</code>属性，指定1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线</p><p> <img src="https://static.vue-js.com/b7925530-9a94-11eb-ab90-d9ae814b240d.png"></p><h3 id="grid-area-属性"><a href="#grid-area-属性" class="headerlink" title="grid-area 属性"></a>grid-area 属性</h3><p><code>grid-area</code> 属性指定项目放在哪一个区域</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思为将1号项目位于<code>e</code>区域</p><p>与上述讲到的<code>grid-template-areas</code>搭配使用</p><h3 id="justify-self-属性、align-self-属性以及-place-self-属性"><a href="#justify-self-属性、align-self-属性以及-place-self-属性" class="headerlink" title="justify-self 属性、align-self 属性以及 place-self 属性"></a>justify-self 属性、align-self 属性以及 place-self 属性</h3><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p><p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  justify-self: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性都可以取下面四个值。</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）</li></ul><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>文章开头就讲到，<code>Grid</code>是一个强大的布局，如一些常见的 CSS 布局，如居中，两列布局，三列布局等等是很容易实现的，在以前的文章中，也有使用<code>Grid</code>布局完成对应的功能</p><p>关于兼容性问题，结果如下：</p><p> <img src="https://static.vue-js.com/c24a2b10-9a94-11eb-85f6-6fac77c0c9b3.png"></p><p>总体兼容性还不错，但在 IE 10 以下不支持</p><p>目前，<code>Grid</code>布局在手机端支持还不算太友好</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></li><li><a href="https://juejin.cn/post/6854573220306255880#heading-2">https://juejin.cn/post/6854573220306255880#heading-2</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_grid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</title>
      <link href="/2018/04/08/css-center/"/>
      <url>/2018/04/08/css-center/</url>
      
        <content type="html"><![CDATA[<h1 id="元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#元素水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>在开发中经常遇到这个问题，即让某个元素的内容在水平和垂直方向上都居中，内容不仅限于文字，可能是图片或其他元素</p><p>居中是一个非常基础但又是非常重要的应用场景，实现居中的方法存在很多，可以将这些方法分成两个大类：</p><ul><li>居中元素（子元素）的宽高已知</li><li>居中元素宽高未知</li></ul><h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><p>实现元素水平垂直居中的方式：</p><ul><li><p>利用定位+margin:auto</p></li><li><p>利用定位+margin:负值</p></li><li><p>利用定位+transform</p></li><li><p>table布局</p></li><li><p>flex布局</p></li><li><p>grid布局</p></li></ul><h3 id="利用定位-margin-auto"><a href="#利用定位-margin-auto" class="headerlink" title="利用定位+margin:auto"></a>利用定位+margin:auto</h3><p>先上代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.father</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>:<span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#0a3b98</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.son</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>:<span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#f0a238</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">right</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">bottom</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>:auto;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父级设置为相对定位，子级绝对定位 ，并且四个定位属性的值都设置了0，那么这时候如果子级没有设置宽高，则会被拉开到和父级一样宽高</p><p>这里子元素设置了宽高，所以宽高会按照我们的设置来显示，但是实际上子级的虚拟占位已经撑满了整个父级，这时候再给它一个<code>margin：auto</code>它就可以上下左右都居中了</p><h3 id="利用定位-margin-负值"><a href="#利用定位-margin-负值" class="headerlink" title="利用定位+margin:负值"></a>利用定位+margin:负值</h3><p>绝大多数情况下，设置父元素为相对定位， 子元素移动自身50%实现水平垂直居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.son</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-left</span>:-<span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-top</span>:-<span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>整个实现思路如下图所示：</p><p> <img src="https://static.vue-js.com/922dc300-95f9-11eb-ab90-d9ae814b240d.png"></p><ul><li>初始位置为方块1的位置</li><li>当设置left、top为50%的时候，内部子元素为方块2的位置</li><li>设置margin为负数时，使内部子元素到方块3的位置，即中间位置</li></ul><p>这种方案不要求父元素的高度，也就是即使父元素的高度变化了，仍然可以保持在父元素的垂直居中位置，水平方向上是一样的操作</p><p>但是该方案需要知道子元素自身的宽高，但是我们可以通过下面<code>transform</code>属性进行移动</p><h3 id="利用定位-transform"><a href="#利用定位-transform" class="headerlink" title="利用定位+transform"></a>利用定位+transform</h3><p>实现代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-class">.father</span> &#123;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background</span>: skyblue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.son</span> &#123;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">background</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;son&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p><code>translate(-50%, -50%)</code>将会将元素位移自己宽度和高度的-50%</p><p>这种方法其实和最上面被否定掉的margin负值用法一样，可以说是<code>margin</code>负值的替代方案，并不需要知道自身元素的宽高</p><h3 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h3><p>设置父元素为<code>display:table-cell</code>，子元素设置 <code>display: inline-block</code>。利用<code>vertical</code>和<code>text-align</code>可以让所有的行内块级元素水平垂直居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.son</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="flex弹性布局"><a href="#flex弹性布局" class="headerlink" title="flex弹性布局"></a>flex弹性布局</h3><p>还是看看实现的整体代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.son</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>css3</code>中了<code>flex</code>布局，可以非常简单实现垂直水平居中</p><p>这里可以简单看看<code>flex</code>布局的关键属性作用：</p><ul><li><p>display: flex时，表示该容器内部的元素将按照flex进行布局</p></li><li><p>align-items: center表示这些元素将相对于本容器水平居中</p></li><li><p>justify-content: center也是同样的道理垂直居中</p></li></ul><h3 id="grid网格布局"><a href="#grid网格布局" class="headerlink" title="grid网格布局"></a>grid网格布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">align-items</span>:center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里看到，<code>gird</code>网格布局和<code>flex</code>弹性布局都简单粗暴</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上述方法中，不知道元素宽高大小仍能实现水平垂直居中的方法有：</p><ul><li>利用定位+margin:auto</li><li>利用定位+transform</li><li>flex布局</li><li>grid布局</li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>根据元素标签的性质，可以分为：</p><ul><li>内联元素居中布局</li><li>块级元素居中布局</li></ul><h3 id="内联元素居中布局"><a href="#内联元素居中布局" class="headerlink" title="内联元素居中布局"></a>内联元素居中布局</h3><p>水平居中</p><ul><li>行内元素可设置：text-align: center</li><li>flex布局设置父元素：display: flex; justify-content: center</li></ul><p>垂直居中</p><ul><li>单行文本父元素确认高度：height &#x3D;&#x3D;&#x3D; line-height</li><li>多行文本父元素确认高度：display: table-cell; vertical-align: middle</li></ul><h3 id="块级元素居中布局"><a href="#块级元素居中布局" class="headerlink" title="块级元素居中布局"></a>块级元素居中布局</h3><p>水平居中</p><ul><li>定宽: margin: 0 auto</li><li>绝对定位+left:50%+margin:负自身一半</li></ul><p>垂直居中</p><ul><li>position: absolute设置left、top、margin-left、margin-top(定高)</li><li>display: table-cell</li><li>transform: translate(x, y)</li><li>flex(不定高，不定宽)</li><li>grid(不定高，不定宽)，兼容性相对比较差</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903982960214029#heading-10">https://juejin.cn/post/6844903982960214029#heading-10</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_center </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中，有哪些方式可以隐藏页面元素？区别?</title>
      <link href="/2018/04/06/css-hide-attr/"/>
      <url>/2018/04/06/css-hide-attr/</url>
      
        <content type="html"><![CDATA[<h1 id="css中，有哪些方式可以隐藏页面元素？区别"><a href="#css中，有哪些方式可以隐藏页面元素？区别" class="headerlink" title="css中，有哪些方式可以隐藏页面元素？区别?"></a>css中，有哪些方式可以隐藏页面元素？区别?</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在平常的样式排版中，我们经常遇到将某个模块隐藏的场景</p><p>通过<code>css</code>隐藏元素的方法有很多种，它们看起来实现的效果是一致的</p><p>但实际上每一种方法都有一丝轻微的不同，这些不同决定了在一些特定场合下使用哪一种方法</p><h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><p>通过<code>css</code>实现隐藏元素方法有如下：</p><ul><li>display:none</li><li>visibility:hidden</li><li>opacity:0</li><li>设置height、width模型属性为0</li><li>position:absolute</li><li>clip-path</li></ul><h3 id="display-none"><a href="#display-none" class="headerlink" title="display:none"></a>display:none</h3><p>设置元素的<code>display</code>为<code>none</code>是最常用的隐藏元素的方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.hide</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将元素设置为<code>display:none</code>后，元素在页面上将彻底消失</p><p>元素本身占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘</p><p>消失后，自身绑定的事件不会触发，也不会有过渡效果</p><p>特点：元素不可见，不占据空间，无法响应点击事件</p><h3 id="visibility-hidden"><a href="#visibility-hidden" class="headerlink" title="visibility:hidden"></a>visibility:hidden</h3><p>设置元素的<code>visibility</code>为<code>hidden</code>也是一种常用的隐藏元素的方法</p><p>从页面上仅仅是隐藏该元素，DOM结果均会存在，只是当时在一个不可见的状态，不会触发重排，但是会触发重绘</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.hidden</span>&#123;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给人的效果是隐藏了，所以他自身的事件不会触发</p><p>特点：元素不可见，占据页面空间，无法响应点击事件</p><h3 id="opacity-0"><a href="#opacity-0" class="headerlink" title="opacity:0"></a>opacity:0</h3><p><code>opacity</code>属性表示元素的透明度，将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的</p><p>不会引发重排，一般情况下也会引发重绘</p><blockquote><p>如果利用 animation 动画，对 opacity 做变化（animation会默认触发GPU加速），则只会触发 GPU 层面的 composite，不会触发重绘</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.transparent</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于其仍然是存在于页面上的，所以他自身的的事件仍然是可以触发的，但被他遮挡的元素是不能触发其事件的</p><p>需要注意的是：其子元素不能设置opacity来达到显示的效果</p><p>特点：改变元素透明度，元素不可见，占据页面空间，可以响应点击事件</p><h3 id="设置height、width属性为0"><a href="#设置height、width属性为0" class="headerlink" title="设置height、width属性为0"></a>设置height、width属性为0</h3><p>将元素的<code>margin</code>，<code>border</code>，<code>padding</code>，<code>height</code>和<code>width</code>等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其<code>overflow:hidden</code>来隐藏其子元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.hiddenBox</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;     </span><br><span class="line">    <span class="attribute">border</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：元素不可见，不占据页面空间，无法响应点击事件</p><h3 id="position-absolute"><a href="#position-absolute" class="headerlink" title="position:absolute"></a>position:absolute</h3><p>将元素移出可视区域</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.hide</span> &#123;</span><br><span class="line">   <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">top</span>: -<span class="number">9999px</span>;</span><br><span class="line">   <span class="attribute">left</span>: -<span class="number">9999px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：元素不可见，不影响页面布局</p><h3 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a>clip-path</h3><p>通过裁剪的形式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.hide</span> &#123;</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0px</span> <span class="number">0px</span>,<span class="number">0px</span> <span class="number">0px</span>,<span class="number">0px</span> <span class="number">0px</span>,<span class="number">0px</span> <span class="number">0px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：元素不可见，占据页面空间，无法响应点击事件</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>最常用的还是<code>display:none</code>和<code>visibility:hidden</code>，其他的方式只能认为是奇招，它们的真正用途并不是用于隐藏元素，所以并不推荐使用它们</p><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>关于<code>display: none</code>、<code>  visibility: hidden</code>、<code>opacity: 0</code>的区别，如下表所示：</p><table><thead><tr><th align="left"></th><th align="left">display: none</th><th align="left">visibility: hidden</th><th>opacity: 0</th></tr></thead><tbody><tr><td align="left">页面中</td><td align="left">不存在</td><td align="left">存在</td><td>存在</td></tr><tr><td align="left">重排</td><td align="left">会</td><td align="left">不会</td><td>不会</td></tr><tr><td align="left">重绘</td><td align="left">会</td><td align="left">会</td><td>不一定</td></tr><tr><td align="left">自身绑定事件</td><td align="left">不触发</td><td align="left">不触发</td><td>可触发</td></tr><tr><td align="left">transition</td><td align="left">不支持</td><td align="left">支持</td><td>支持</td></tr><tr><td align="left">子元素可复原</td><td align="left">不能</td><td align="left">能</td><td>不能</td></tr><tr><td align="left">被遮挡的元素可触发事件</td><td align="left">能</td><td align="left">能</td><td>不能</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/a-cat/p/9039962.html">https://www.cnblogs.com/a-cat/p/9039962.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_hide_attr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用css完成视差滚动效果?</title>
      <link href="/2018/04/04/css-visul-scrolling/"/>
      <url>/2018/04/04/css-visul-scrolling/</url>
      
        <content type="html"><![CDATA[<h1 id="如何使用css完成视差滚动效果"><a href="#如何使用css完成视差滚动效果" class="headerlink" title="如何使用css完成视差滚动效果?"></a>如何使用css完成视差滚动效果?</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>视差滚动（Parallax Scrolling）是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验</p><p>我们可以把网页解刨成：背景层、内容层、悬浮层</p><p> <img src="https://static.vue-js.com/57c942a0-a1cc-11eb-85f6-6fac77c0c9b3.png"></p><p>当滚动鼠标滑轮的时候，各个图层以不同的速度移动，形成视觉差的效果</p><p> <img src="https://static.vue-js.com/e57ab280-a1dd-11eb-ab90-d9ae814b240d.png" alt="image.png"></p><h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><p>使用<code>css</code>形式实现视觉差滚动效果的方式有：</p><ul><li>background-attachment</li><li>transform:translate3D</li></ul><h3 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h3><p>作用是设置背景图像是否固定或者随着页面的其余部分滚动</p><p>值分别有如下：</p><ul><li>scroll：默认值，背景图像会随着页面其余部分的滚动而移动</li><li>fixed：当页面的其余部分滚动时，背景图像不会移动</li><li>inherit：继承父元素background-attachment属性的值</li></ul><p>完成滚动视觉差就需要将<code>background-attachment</code>属性设置为<code>fixed</code>，让背景相对于视口固定。及时一个元素有滚动机制，背景也不会随着元素的内容而滚动</p><p>也就是说，背景一开始就已经被固定在初始的位置</p><p>核心的<code>css</code>代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-img</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">...</span>);</span><br><span class="line">    <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">background-position</span>: center center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体例子如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">7</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">line-height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">20vh</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.a-img1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">https://images.pexels.com/photos/1097491/pexels-photo-1097491.jpeg</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-attachment</span>: fixed;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-size</span>: cover;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-position</span>: center center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.a-img2</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">https://images.pexels.com/photos/2437299/pexels-photo-2437299.jpeg</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-attachment</span>: fixed;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-size</span>: cover;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-position</span>: center center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.a-img3</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">https://images.pexels.com/photos/1005417/pexels-photo-1005417.jpeg</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-attachment</span>: fixed;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-size</span>: cover;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-position</span>: center center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a-text&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a-img1&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a-text&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a-img2&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a-text&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a-img3&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a-text&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="transform-translate3D"><a href="#transform-translate3D" class="headerlink" title="transform:translate3D"></a>transform:translate3D</h3><p>同样，让我们先来看一下两个概念<code>transform</code>和<code>perspective</code>：</p><ul><li>transform: css3 属性，可以对元素进行变换(2d&#x2F;3d)，包括平移 translate,旋转 rotate,缩放 scale,等等</li><li>perspective: css3 属性，当元素涉及 3d 变换时，perspective 可以定义我们眼睛看到的 3d 立体效果，即空间感</li></ul><p><code>3D</code>视角示意图如下所示：</p><p> <img src="https://static.vue-js.com/24f37dd0-a18d-11eb-85f6-6fac77c0c9b3.png"></p><p>举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100%</span></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 视差元素的父级需要3D视角 */</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">perspective</span>: <span class="number">1px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d; </span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow-y</span>: scroll;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow-x</span>: hidden;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#app</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100vw</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>:<span class="number">200vh</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>:skyblue;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding-top</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.one</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>:<span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>:<span class="number">#409eff</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0px</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-bottom</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.two</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>:<span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>:<span class="number">#67c23a</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(-<span class="number">1px</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-bottom</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.three</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>:<span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>:<span class="number">#e6a23c</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(-<span class="number">2px</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-bottom</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;three&quot;</span>&gt;</span>three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而这种方式实现视觉差动的原理如下：</p><ul><li><p>容器设置上 transform-style: preserve-3d 和 perspective: xpx，那么处于这个容器的子元素就将位于3D空间中，</p></li><li><p>子元素设置不同的 transform: translateZ()，这个时候，不同元素在 3D Z轴方向距离屏幕（我们的眼睛）的距离也就不一样</p></li><li><p>滚动滚动条，由于子元素设置了不同的 transform: translateZ()，那么他们滚动的上下距离 translateY 相对屏幕（我们的眼睛），也是不一样的，这就达到了滚动视差的效果</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://imweb.io/topic/5b73ef73a56e07401e48729d">https://imweb.io/topic/5b73ef73a56e07401e48729d</a></li><li><a href="https://juejin.cn/post/6844903654458146823#heading-5">https://juejin.cn/post/6844903654458146823#heading-5</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_visul_scrolling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你对盒子模型的理解?</title>
      <link href="/2018/03/01/css-box/"/>
      <url>/2018/03/01/css-box/</url>
      
        <content type="html"><![CDATA[<h1 id="你对盒子模型的理解"><a href="#你对盒子模型的理解" class="headerlink" title="你对盒子模型的理解?"></a>你对盒子模型的理解?</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）</p><p>一个盒子由四个部分组成：<code>content</code>、<code>padding</code>、<code>border</code>、<code>margin</code></p><p><img src="https://static.vue-js.com/976789a0-8f9b-11eb-85f6-6fac77c0c9b3.png"></p><p><code>content</code>，即实际内容，显示文本和图像</p><p><code>boreder</code>，即边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成</p><p><code>padding</code>，即内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的<code>background</code>属性影响</p><p><code>margin</code>，即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域</p><p>上述是一个从二维的角度观察盒子，下面再看看看三维图：</p><p> <img src="https://static.vue-js.com/b2548b00-8f9b-11eb-ab90-d9ae814b240d.png"></p><p>下面来段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  盒子模型</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们在浏览器查看元素时，却发现元素的大小变成了<code>240px</code></p><p>这是因为，在<code>CSS</code>中，盒子模型可以分成：</p><ul><li>W3C 标准盒子模型</li><li>IE 怪异盒子模型</li></ul><p>默认情况下，盒子模型为<code>W3C</code> 标准盒子模型</p><h2 id="二、标准盒子模型"><a href="#二、标准盒子模型" class="headerlink" title="二、标准盒子模型"></a>二、标准盒子模型</h2><p>标准盒子模型，是浏览器默认的盒子模型</p><p>下面看看标准盒子模型的模型图：</p><p> <img src="https://static.vue-js.com/c0e1d2e0-8f9b-11eb-85f6-6fac77c0c9b3.png"></p><p>从上图可以看到：</p><ul><li><p>盒子总宽度 &#x3D; width + padding + border + margin;</p></li><li><p>盒子总高度 &#x3D; height + padding + border + margin</p></li></ul><p>也就是，<code>width/height</code> 只是内容高度，不包含 <code>padding</code> 和 <code>border </code>值</p><p>所以上面问题中，设置<code>width</code>为200px，但由于存在<code>padding</code>，但实际上盒子的宽度有240px</p><h2 id="三、IE-怪异盒子模型"><a href="#三、IE-怪异盒子模型" class="headerlink" title="三、IE 怪异盒子模型"></a>三、IE 怪异盒子模型</h2><p>同样看看IE 怪异盒子模型的模型图：</p><p> <img src="https://static.vue-js.com/cfbb3ef0-8f9b-11eb-ab90-d9ae814b240d.png"></p><p>从上图可以看到：</p><ul><li><p>盒子总宽度 &#x3D; width + margin;</p></li><li><p>盒子总高度 &#x3D; height + margin;</p></li></ul><p>也就是，<code>width/height</code> 包含了 <code>padding </code>和 <code>border </code>值</p><h2 id="Box-sizing"><a href="#Box-sizing" class="headerlink" title="Box-sizing"></a>Box-sizing</h2><p>CSS 中的 box-sizing 属性定义了引擎应该如何计算一个元素的总宽度和总高度</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span>: content-box|border-box|inherit:</span><br></pre></td></tr></table></figure><ul><li>content-box 默认值，元素的 width&#x2F;height 不包含padding，border，与标准盒子模型表现一致</li><li>border-box 元素的 width&#x2F;height 包含 padding，border，与怪异盒子模型表现一致</li><li>inherit 指定 box-sizing 属性的值，应该从父元素继承</li></ul><p>回到上面的例子里，设置盒子为 border-box 模型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  盒子模型</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时候，就可以发现盒子的所占据的宽度为200px</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing">https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_box </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈你对BFC的理解？</title>
      <link href="/2018/02/16/css-bfc/"/>
      <url>/2018/02/16/css-bfc/</url>
      
        <content type="html"><![CDATA[<h1 id="谈谈你对BFC的理解？"><a href="#谈谈你对BFC的理解？" class="headerlink" title="谈谈你对BFC的理解？"></a>谈谈你对BFC的理解？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>我们在页面布局的时候，经常出现以下情况：</p><ul><li>这个元素高度怎么没了？</li><li>这两栏布局怎么没法自适应？</li><li>这两个元素的间距怎么有点奇怪的样子？</li><li>……</li></ul><p>原因是元素之间相互的影响，导致了意料之外的情况，这里就涉及到<code>BFC</code>概念</p><p><code>BFC</code>（Block Formatting Context），即块级格式化上下文，它是页面中的一块渲染区域，并且有一套属于自己的渲染规则：</p><ul><li>内部的盒子会在垂直方向上一个接一个的放置</li><li>对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关。</li><li>每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此</li><li>BFC的区域不会与float的元素区域重叠</li><li>计算BFC的高度时，浮动子元素也参与计算</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li></ul><p><code>BFC</code>目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素</p><h2 id="二、触发条件"><a href="#二、触发条件" class="headerlink" title="二、触发条件"></a>二、触发条件</h2><p>触发<code>BFC</code>的条件包含不限于：</p><ul><li>根元素，即HTML元素</li><li>浮动元素：float值为left、right</li><li>overflow值不为 visible，为 auto、scroll、hidden</li><li>display的值为inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid</li><li>position的值为absolute或fixed</li></ul><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>利用<code>BFC</code>的特性，我们将<code>BFC</code>应用在以下场景：</p><h4 id="防止margin重叠（塌陷）"><a href="#防止margin重叠（塌陷）" class="headerlink" title="防止margin重叠（塌陷）"></a>防止margin重叠（塌陷）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: <span class="number">#f55</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Haha&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hehe&lt;/p &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面显示如下：</p><p> <img src="https://static.vue-js.com/d0ce3650-9511-11eb-85f6-6fac77c0c9b3.png"></p><p>两个<code>p</code>元素之间的距离为<code>100px</code>，发生了<code>margin</code>重叠（塌陷），以最大的为准，如果第一个P的<code>margin</code>为80的话，两个P之间的距离还是100，以最大的为准。</p><p>前面讲到，同一个<code>BFC</code>的俩个相邻的盒子的<code>margin</code>会发生重叠</p><p>可以在<code>p</code>外面包裹一层容器，并触发这个容器生成一个<code>BFC</code>，那么两个<code>p</code>就不属于同一个<code>BFC</code>，则不会出现<code>margin</code>重叠</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.wrap</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: hidden;// 新的BFC</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: <span class="number">#f55</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Haha&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hehe&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时候，边距则不会重叠：</p><p> <img src="https://static.vue-js.com/dec44740-9511-11eb-85f6-6fac77c0c9b3.png"></p><h4 id="清除内部浮动"><a href="#清除内部浮动" class="headerlink" title="清除内部浮动"></a>清除内部浮动</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.par</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"> </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#f66</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;par&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面显示如下：</p><p> <img src="https://static.vue-js.com/ec5d4410-9511-11eb-85f6-6fac77c0c9b3.png"></p><p>而<code>BFC</code>在计算高度时，浮动元素也会参与，所以我们可以触发<code>.par</code>元素生成<code>BFC</code>，则内部浮动元素计算高度时候也会计算</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.par</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果如下：</p><p> <img src="https://static.vue-js.com/f6487b20-9511-11eb-ab90-d9ae814b240d.png"></p><h4 id="自适应多栏布局"><a href="#自适应多栏布局" class="headerlink" title="自适应多栏布局"></a>自适应多栏布局</h4><p>这里举个两栏的布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"> </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.aside</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#f66</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"> </span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图如下：</p><p> <img src="https://static.vue-js.com/ffb95210-9511-11eb-ab90-d9ae814b240d.png"></p><p>前面讲到，每个元素的左外边距与包含块的左边界相接触</p><p>因此，虽然<code>.aslide</code>为浮动元素，但是<code>main</code>的左边依然会与包含块的左边相接触</p><p>而<code>BFC</code>的区域不会与浮动盒子重叠</p><p>所以我们可以通过触发<code>main</code>生成<code>BFC</code>，以此适应两栏布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，新的<code>BFC</code>不会与浮动的<code>.aside</code>元素重叠。因此会根据包含块的宽度，和<code>.aside</code>的宽度，自动变窄</p><p>效果如下：</p><p> <img src="https://static.vue-js.com/0a5f2690-9512-11eb-ab90-d9ae814b240d.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>可以看到上面几个案例，都体现了<code>BFC</code>实际就是页面一个独立的容器，里面的子元素不影响外面的元素</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</a></li><li><a href="https://github.com/zuopf769/notebook/blob/master/fe/BFC%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/README.md">https://github.com/zuopf769/notebook/blob/master/fe/BFC%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/README.md</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_bfc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css3动画有哪些？</title>
      <link href="/2018/01/06/css-animation/"/>
      <url>/2018/01/06/css-animation/</url>
      
        <content type="html"><![CDATA[<h1 id="ss3动画有哪些？"><a href="#ss3动画有哪些？" class="headerlink" title="ss3动画有哪些？"></a>ss3动画有哪些？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>CSS动画（CSS Animations）是为层叠样式表建议的允许可扩展标记语言（XML）元素使用CSS的动画的模块</p><p>即指元素从一种样式逐渐过渡为另一种样式的过程</p><p>常见的动画效果有很多，如平移、旋转、缩放等等，复杂动画则是多个简单动画的组合</p><p><code>css</code>实现动画的方式，有如下几种：</p><ul><li>transition 实现渐变动画</li><li>transform 转变动画</li><li>animation 实现自定义动画</li></ul><h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><h3 id="transition-实现渐变动画"><a href="#transition-实现渐变动画" class="headerlink" title="transition 实现渐变动画"></a>transition 实现渐变动画</h3><p><code>transition</code>的属性如下：</p><ul><li>property:填写需要变化的css属性</li><li>duration:完成过渡效果需要的时间单位(s或者ms)</li><li>timing-function:完成效果的速度曲线</li><li>delay: 动画效果的延迟触发时间</li></ul><p>其中<code>timing-function</code>的值有如下：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>linear</td><td>匀速（等于 cubic-bezier(0,0,1,1)）</td></tr><tr><td>ease</td><td>从慢到快再到慢（cubic-bezier(0.25,0.1,0.25,1)）</td></tr><tr><td>ease-in</td><td>慢慢变快（等于 cubic-bezier(0.42,0,1,1)）</td></tr><tr><td>ease-out</td><td>慢慢变慢（等于 cubic-bezier(0,0,0.58,1)）</td></tr><tr><td>ease-in-out</td><td>先变快再到慢（等于 cubic-bezier(0.42,0,0.58,1)），渐显渐隐效果</td></tr><tr><td>cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td><td>在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值</td></tr></tbody></table><p>注意：并不是所有的属性都能使用过渡的，如<code>display:none&lt;-&gt;display:block</code></p><p>举个例子，实现鼠标移动上去发生变化动画效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">       <span class="selector-class">.base</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#0EA9FF</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-width</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-style</span>: solid;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-color</span>: <span class="number">#5daf34</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transition-property</span>: width, height, background-color, border-width;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transition-duration</span>: <span class="number">2s</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transition-timing-function</span>: ease-in;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transition-delay</span>: <span class="number">500ms</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/*简写*/</span></span></span><br><span class="line"><span class="language-css">        <span class="comment">/*transition: all 2s ease-in 500ms;*/</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.base</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#5daf34</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-width</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-color</span>: <span class="number">#3a8ee6</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;base&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="transform-转变动画"><a href="#transform-转变动画" class="headerlink" title="transform 转变动画"></a>transform 转变动画</h3><p>包含四个常用的功能：</p><ul><li>translate：位移</li><li>scale：缩放</li><li>rotate：旋转</li><li>skew：倾斜</li></ul><p>一般配合<code>transition</code>过度使用</p><p>注意的是，<code>transform</code>不支持<code>inline</code>元素，使用前把它变成<code>block</code></p><p>举个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.base</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#0EA9FF</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-width</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-style</span>: solid;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-color</span>: <span class="number">#5daf34</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transition-property</span>: width, height, background-color, border-width;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transition-duration</span>: <span class="number">2s</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transition-timing-function</span>: ease-in;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transition-delay</span>: <span class="number">500ms</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.base2</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: none;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transition-property</span>: transform;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transition-delay</span>: <span class="number">5ms</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.base2</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.8</span>, <span class="number">1.5</span>) <span class="built_in">rotate</span>(<span class="number">35deg</span>) <span class="built_in">skew</span>(<span class="number">5deg</span>) <span class="built_in">translate</span>(<span class="number">15px</span>, <span class="number">25px</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;base base2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到盒子发生了旋转，倾斜，平移，放大</p><h3 id="animation-实现自定义动画"><a href="#animation-实现自定义动画" class="headerlink" title="animation 实现自定义动画"></a>animation 实现自定义动画</h3><p><code>animation</code>是由 8 个属性的简写，分别如下：</p><table><thead><tr><th>属性</th><th>描述</th><th>属性值</th></tr></thead><tbody><tr><td>animation-duration</td><td>指定动画完成一个周期所需要时间，单位秒（s）或毫秒（ms），默认是 0</td><td></td></tr><tr><td>animation-timing-function</td><td>指定动画计时函数，即动画的速度曲线，默认是 “ease”</td><td>linear、ease、ease-in、ease-out、ease-in-out</td></tr><tr><td>animation-delay</td><td>指定动画延迟时间，即动画何时开始，默认是 0</td><td></td></tr><tr><td>animation-iteration-count</td><td>指定动画播放的次数，默认是 1</td><td></td></tr><tr><td>animation-direction 指定动画播放的方向</td><td>默认是 normal</td><td>normal、reverse、alternate、alternate-reverse</td></tr><tr><td>animation-fill-mode</td><td>指定动画填充模式。默认是 none</td><td>forwards、backwards、both</td></tr><tr><td>animation-play-state</td><td>指定动画播放状态，正在运行或暂停。默认是 running</td><td>running、pauser</td></tr><tr><td>animation-name</td><td>指定 @keyframes 动画的名称</td><td></td></tr></tbody></table><p><code>CSS</code> 动画只需要定义一些关键的帧，而其余的帧，浏览器会根据计时函数插值计算出来，</p><p>通过 <code>@keyframes</code> 来定义关键帧</p><p>因此，如果我们想要让元素旋转一圈，只需要定义开始和结束两帧即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rotate&#123;</span><br><span class="line">    <span class="selector-tag">from</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>from</code> 表示最开始的那一帧，<code>to</code> 表示结束时的那一帧</p><p>也可以使用百分比刻画生命周期</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rotate&#123;</span><br><span class="line">    <span class="number">0%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">50%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">180deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好了关键帧后，下来就可以直接用它了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation</span>: rotate <span class="number">2s</span>;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>transition（过度）</td><td>用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同</td></tr><tr><td>transform（变形）</td><td>用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于color一样用来设置元素的“外表”</td></tr><tr><td>translate（移动）</td><td>只是transform的一个属性值，即移动</td></tr><tr><td>animation（动画）</td><td>用于设置动画属性，他是一个简写的属性，包含6个属性</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000022540857">https://segmentfault.com/a/1190000022540857</a></li><li><a href="https://zh.m.wikipedia.org/wiki/CSS%E5%8A%A8%E7%94%BB">https://zh.m.wikipedia.org/wiki/CSS%E5%8A%A8%E7%94%BB</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css_animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对版本管理的理解？常用的版本管理工具有哪些？</title>
      <link href="/2017/06/16/git-Version-control/"/>
      <url>/2017/06/16/git-Version-control/</url>
      
        <content type="html"><![CDATA[<h1 id="对版本管理的理解？常用的版本管理工具有哪些？"><a href="#对版本管理的理解？常用的版本管理工具有哪些？" class="headerlink" title="对版本管理的理解？常用的版本管理工具有哪些？"></a>对版本管理的理解？常用的版本管理工具有哪些？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>版本控制（Version control），是维护工程蓝图的标准作法，能追踪工程蓝图从诞生一直到定案的过程。此外，版本控制也是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编辑的同一程序文件都得到同步</p><p>透过文档控制，能记录任何工程项目内各个模块的改动历程，并为每次改动编上序号</p><p>一种简单的版本控制形式如下：赋给图的初版一个版本等级“A”。当做了第一次改变后，版本等级改为“B”，以此类推</p><p>版本控制能提供项目的设计者，将设计恢复到之前任一状态的选择权</p><p>简言之，你的修改只要提到到版本控制系统，基本都可以找回，版本控制系统就像一台时光机器，可以让你回到任何一个时间点</p><h2 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h2><p>版本控制系统在当今的软件开发中，被认为是理所当然的配备工具之一，根据类别可以分成：</p><ul><li>本地版本控制系统</li><li>集中式版本控制系统</li><li>分布式版本控制系统</li></ul><h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p>结构如下图所示：</p><p> <img src="https://static.vue-js.com/c545ded0-f5ad-11eb-ab90-d9ae814b240d.png"></p><p>优点：</p><ul><li>简单，很多系统中都有内置</li><li>适合管理文本，如系统配置</li></ul><p>缺点：</p><ul><li>其不支持远程操作，因此并不适合多人版本开发</li></ul><h3 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h3><p>结构如下图所示：</p><p> <img src="https://static.vue-js.com/8b4b3040-f5ad-11eb-85f6-6fac77c0c9b3.png"></p><p>优点：</p><ul><li>适合多人团队协作开发</li><li>代码集中化管理</li></ul><p>缺点：</p><ul><li>单点故障</li><li>必须联网，无法单机工作</li></ul><p>代表工具有<code>SVN</code>、<code>CVS</code>：</p><h3 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h3><p><code>TortoiseSVN</code>是一款非常易于使用的跨平台的 版本控制&#x2F;版本控制&#x2F;源代码控制软件</p><h3 id="CVS"><a href="#CVS" class="headerlink" title="CVS"></a>CVS</h3><p><code>CVS</code>是版本控制系统，是源配置管理（SCM）的重要组成部分。使用它，您可以记录源文件和文档的历史记录</p><p>老牌的版本控制系统，它是基于客户端&#x2F;服务器的行为使得其可容纳多用户，构成网络也很方便</p><p>这一特性使得<code>CVS</code>成为位于不同地点的人同时处理数据文件（特别是程序的源代码）时的首选</p><h4 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h4><p>结构如下图：</p><p> <img src="https://static.vue-js.com/4301a260-f5ad-11eb-85f6-6fac77c0c9b3.png"></p><p>优点：</p><ul><li>适合多人团队协作开发</li><li>代码集中化管理</li><li>可以离线工作</li><li>每个计算机都是一个完整仓库</li></ul><p>分布式版本管理系统每个计算机都有一个完整的仓库，可本地提交，可以做到离线工作，则不用像集中管理那样因为断网情况而无法工作</p><p>代表工具为<code>Git</code>、<code>HG</code>：</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p><code>Git</code>是目前世界上最先进的分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务</p><p>特性：易于学习，占用内存小，具有闪电般快速的性能</p><p>使用<code>Git</code>和<code>Gitlab</code>搭建版本控制环境是现在互联网公司最流行的版本控制方式</p><h3 id="HG"><a href="#HG" class="headerlink" title="HG"></a>HG</h3><p><code>Mercurial</code>是一个免费的分布式源代码管理工具。它可以有效地处理任何规模的项目，并提供简单直观的界面</p><p><code>Mercurial </code>是一种轻量级分布式版本控制系统，采用 <code>Python </code>语言实现，易于学习和使用，扩展性强</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>版本控制系统的优点如下：</p><ul><li>记录文件所有历史变化，这是版本控制系统的基本能力</li><li>随时恢复到任意时间点，历史记录功能使我们不怕改错代码了</li><li>支持多功能并行开发，通常版本控制系统都支持分支，保证了并行开发的可行</li><li>多人协作并行开发，对于多人协作项目，支持多人协作开发的版本管理将事半功倍</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://pm.readthedocs.io/vcs/understanding.html">https://pm.readthedocs.io/vcs/understanding.html</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">https://zh.wikipedia.org/wiki/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git_Version_control </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对git stash 的理解？应用场景？</title>
      <link href="/2017/05/06/git-stash/"/>
      <url>/2017/05/06/git-stash/</url>
      
        <content type="html"><![CDATA[<h1 id="对git-stash-的理解？应用场景？"><a href="#对git-stash-的理解？应用场景？" class="headerlink" title="对git stash 的理解？应用场景？"></a>对git stash 的理解？应用场景？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>stash，译为存放，在 git 中，可以理解为保存当前工作进度，会把暂存区和工作区的改动进行保存，这些修改会保存在一个栈上</p><p>后续你可以在任何时候任何分支重新将某次的修改推出来，重新应用这些更改的代码</p><p>默认情况下，<code>git stash</code>会缓存下列状态的文件：</p><ul><li>添加到暂存区的修改（staged changes）</li><li>Git跟踪的但并未添加到暂存区的修改（unstaged changes）</li></ul><p>但以下状态的文件不会缓存：</p><ul><li>在工作目录中新的文件（untracked files）</li><li>被忽略的文件（ignored files）</li></ul><p>如果想要上述的文件都被缓存，可以使用<code>-u</code>或者<code>--include-untracked</code>可以工作目录新的文件，使用<code>-a</code>或者<code>--all</code>命令可以当前目录下的所有修改</p><h2 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h2><p>关于<code>git stash</code>常见的命令如下：</p><ul><li><p>git stash</p></li><li><p>git stash save</p></li><li><p>git stash list</p></li><li><p>git stash pop</p></li><li><p>git stash apply</p></li><li><p>git stash show</p></li><li><p>git stash drop</p></li><li><p>git stash clear</p></li></ul><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>保存当前工作进度，会把暂存区和工作区的改动保存起来</p><h3 id="git-stash-save"><a href="#git-stash-save" class="headerlink" title="git stash save"></a>git stash save</h3><p><code>git stash save</code>可以用于存储修改.并且将<code>git</code>的工作状态切回到<code>HEAD</code>也就是上一次合法提交上</p><p>如果给定具体的文件路径,<code>git stash</code>只会处理路径下的文件.其他的文件不会被存储，其存在一些参数：</p><ul><li><p>–keep-index 或者 -k 只会存储为加入 git 管理的文件</p></li><li><p>–include-untracked 为追踪的文件也会被缓存,当前的工作空间会被恢复为完全清空的状态</p></li><li><p>-a 或者 –all 命令可以当前目录下的所有修改，包括被 git 忽略的文件</p></li></ul><h3 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a>git stash list</h3><p>显示保存进度的列表。也就意味着，<code>git stash</code>命令可以多次执行，当多次使用<code>git stash</code>命令后，栈里会充满未提交的代码，如下：</p><p> <img src="https://static.vue-js.com/50216dd0-fccf-11eb-bc6f-3f06e1491664.png"></p><p>其中，<code>stash@&#123;0&#125;</code>、<code>stash@&#123;1&#125;</code>就是当前<code>stash</code>的名称</p><h3 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a>git stash pop</h3><p><code>git stash pop</code> 从栈中读取最近一次保存的内容，也就是栈顶的<code>stash</code>会恢复到工作区</p><p>也可以通过 <code>git stash pop</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p><p>如果从<code>stash</code>中恢复的内容和当前目录中的内容发生了冲突，则需要手动修复冲突或者创建新的分支来解决冲突</p><h3 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a>git stash apply</h3><p>将堆栈中的内容应用到当前目录，不同于<code>git stash pop</code>，该命令不会将内容从堆栈中删除</p><p>也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况</p><p>同样，可以通过<code>git stash apply</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p><h3 id="git-stash-show"><a href="#git-stash-show" class="headerlink" title="git stash show"></a>git stash show</h3><p>查看堆栈中最新保存的<code>stash</code>和当前目录的差异</p><p>通过使用<code>git stash show -p</code>查看详细的不同</p><p>通过使用<code>git stash show stash@&#123;1&#125;</code>查看指定的<code>stash</code>和当前目录差异</p><p> <img src="https://static.vue-js.com/458620a0-fccf-11eb-bc6f-3f06e1491664.png"></p><h3 id="git-stash-drop"><a href="#git-stash-drop" class="headerlink" title="git stash drop"></a>git stash drop</h3><p><code>git stash drop</code> + <code>stash</code>名称表示从堆栈中移除某个指定的stash</p><h3 id="git-stash-clear"><a href="#git-stash-clear" class="headerlink" title="git stash clear"></a>git stash clear</h3><p>删除所有存储的进度</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支或者拉下远端的代码去做一点别的事情</p><p>但是你创建一次未完成的代码的<code>commit</code>提交，这时候就可以使用<code>git stash</code></p><p>例如以下场景：</p><p>当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过<code>git pull</code>解决</p><p>但是如果可能发生冲突怎么办.直接<code>git pull</code>会拒绝覆盖当前的修改，这时候就可以依次使用下述的命令：</p><ul><li>git stash</li><li>git pull</li><li>git stash pop</li></ul><p>或者当你开发到一半，现在要修改别的分支问题的时候，你也可以使用<code>git stash</code>缓存当前区域的代码</p><ul><li>git stash：保存开发到一半的代码</li><li>git commit -m ‘修改问题’</li><li>git stash pop：将代码追加到最新的提交之后</li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git_stash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对git reset 和 git revert 的理解？区别？</title>
      <link href="/2017/04/19/git-reset-git-revert/"/>
      <url>/2017/04/19/git-reset-git-revert/</url>
      
        <content type="html"><![CDATA[<h1 id="对git-reset-和-git-revert-的理解？区别？"><a href="#对git-reset-和-git-revert-的理解？区别？" class="headerlink" title="对git reset 和 git revert 的理解？区别？"></a>对git reset 和 git revert 的理解？区别？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><code>reset</code>用于回退版本，可以遗弃不再使用的提交</p><p>执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容</p><p> <img src="https://static.vue-js.com/ab4d0c00-ff72-11eb-bc6f-3f06e1491664.png"></p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交</p><p> <img src="https://static.vue-js.com/bd12c290-ff72-11eb-991d-334fd31f0201.png"></p><h2 id="二、如何用"><a href="#二、如何用" class="headerlink" title="二、如何用"></a>二、如何用</h2><h3 id="git-reset-1"><a href="#git-reset-1" class="headerlink" title="git reset"></a>git reset</h3><p>当没有指定<code>ID</code>的时候，默认使用<code>HEAD</code>，如果指定<code>ID</code>，那么就是基于指向<code>ID</code>去变动暂存区或工作区的内容</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 没有指定ID, 暂存区的内容会被当前ID版本号的内容覆盖，工作区不变</span><br><span class="line">git reset</span><br><span class="line"></span><br><span class="line">// 指定ID，暂存区的内容会被指定ID版本号的内容覆盖，工作区不变</span><br><span class="line">git reset &lt;ID&gt; </span><br></pre></td></tr></table></figure><p>日志<code>ID</code>可以通过查询，可以<code>git log</code>进行查询，如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commit a7700083ace1204ccdff9f71631fb34c9913f7c5 (HEAD -&gt; master)</span><br><span class="line"><span class="function">Author: <span class="title">linguanghui</span> &lt;<span class="title">linguanghui</span>@<span class="title">baidu.com</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">Date</span>:   <span class="title">Tue</span> <span class="title">Aug</span> 17 22:34:40 2021 +0800</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">second</span> <span class="title">commit</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">commit</span> <span class="title">e31118663ce66717edd8a179688a7f3dde5a9393</span></span></span><br><span class="line"><span class="function"><span class="title">Author</span>: <span class="title">linguanghui</span> &lt;<span class="title">linguanghui</span>@<span class="title">baidu.com</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">Date</span>:   <span class="title">Tue</span> <span class="title">Aug</span> 17 22:20:01 2021 +0800</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">first</span> <span class="title">commit</span></span></span><br></pre></td></tr></table></figure><p>常见命令如下：</p><ul><li><p>–mixed（默认）：默认的时候，只有暂存区变化</p></li><li><p>–hard参数：如果使用 –hard 参数，那么工作区也会变化</p></li><li><p>–soft：如果使用 –soft 参数，那么暂存区和工作区都不会变化</p></li></ul><p> <img src="https://static.vue-js.com/225b41e0-ff73-11eb-bc6f-3f06e1491664.png"></p><h3 id="git-revert-1"><a href="#git-revert-1" class="headerlink" title="git revert"></a>git revert</h3><p>跟<code>git reset</code>用法基本一致，<code>git revert</code> 撤销某次操作，此次操作之前和之后的 <code>commit</code>和<code>history</code>都会保留，并且把这次撤销，作为一次最新的提交，如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit_id&gt; </span><br></pre></td></tr></table></figure><p>如果撤销前一个版本，可以通过如下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure><p>撤销前前一次，如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD^</span><br></pre></td></tr></table></figure><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，<code>git reset</code>被设计为重设本地更改</p><p>因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销</p><p>两者主要区别如下：</p><ul><li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</li><li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容</li><li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别</li></ul><blockquote><p>git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并</p><p>但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入</p></blockquote><ul><li>如果回退分支的代码以后还需要的情况则使用<code>git revert</code>， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用<code>git reset</code></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903542931587086">https://juejin.cn/post/6844903542931587086</a></li><li><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html#reset">https://marklodato.github.io/visual-git-guide/index-zh-cn.html#reset</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git_reset_git_revert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你对git rebase 和 git merge的理解？区别？</title>
      <link href="/2017/04/06/git-rebase-git-merge/"/>
      <url>/2017/04/06/git-rebase-git-merge/</url>
      
        <content type="html"><![CDATA[<h1 id="你对git-rebase-和-git-merge的理解？区别？"><a href="#你对git-rebase-和-git-merge的理解？区别？" class="headerlink" title="你对git rebase 和 git merge的理解？区别？"></a>你对git rebase 和 git merge的理解？区别？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>在使用 <code>git</code> 进行版本管理的项目中，当完成一个特性的开发并将其合并到 <code>master</code> 分支时，会有两种方式：</p><ul><li>git merge</li><li>git rebase</li></ul><p><code>git rebase</code> 与 <code>git merge</code>都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同</p><p>用法上两者也十分的简单：</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>将当前分支合并到指定分支，命令用法如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge xxx</span><br></pre></td></tr></table></figure><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>将当前分支移植到指定分支或指定<code>commit</code>之上，用法如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>常见的参数有<code>--continue</code>，用于解决冲突之后，继续执行<code>rebase</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><h3 id="git-merge-1"><a href="#git-merge-1" class="headerlink" title="git merge"></a>git merge</h3><p>通过<code>git merge</code>将当前分支与<code>xxx</code>分支合并，产生的新的<code>commit</code>对象有两个父节点</p><p>如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并</p><p>举个例子，<code>bugfix</code>分支是从<code>master</code>分支分叉出来的，如下所示：</p><p> <img src="https://static.vue-js.com/88410a30-fdd4-11eb-991d-334fd31f0201.png"></p><p>合并<code> bugfix</code>分支到<code>master</code>分支时，如果<code>master</code>分支的状态没有被更改过，即 <code>bugfix</code>分支的历史记录包含<code>master</code>分支所有的历史记录</p><p>所以通过把<code>master</code>分支的位置移动到<code>bugfix</code>的最新分支上，就完成合并</p><p>如果<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p><p> <img src="https://static.vue-js.com/929eb220-fdd4-11eb-991d-334fd31f0201.png"></p><p>这时候使用<code>git merge</code>的时候，会生成一个新的提交，并且<code>master</code>分支的<code>HEAD</code>会移动到新的分支上，如下：</p><p> <img src="https://static.vue-js.com/9fdfa3e0-fdd4-11eb-991d-334fd31f0201.png"></p><p>从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照</p><h3 id="git-rebase-1"><a href="#git-rebase-1" class="headerlink" title="git rebase"></a>git rebase</h3><p>同样，<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p><p> <img src="https://static.vue-js.com/ab2d5120-fdd4-11eb-bc6f-3f06e1491664.png"></p><p>通过<code>git rebase</code>，会变成如下情况：</p><p> <img src="https://static.vue-js.com/b72aed70-fdd4-11eb-991d-334fd31f0201.png"></p><p>在移交过程中，如果发生冲突，需要修改各自的冲突，如下：</p><p> <img src="https://static.vue-js.com/c9ba0e80-fdd4-11eb-bc6f-3f06e1491664.png"></p><p><code>rebase</code>之后，<code>master</code>的<code>HEAD</code>位置不变。因此，要合并<code>master</code>分支和<code>bugfix</code>分支</p><p> <img src="https://static.vue-js.com/dc660660-fdd4-11eb-991d-334fd31f0201.png"></p><p>从上面可以看到，<code>rebase</code>会找到不同的分支的最近共同祖先，如上图的<code>B</code></p><p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交<code>X</code>和<code>Y</code>也没有被销毁，只是简单地不能再被访问或者使用）</p><p>然后将当前分支指向目标最新位置<code>D</code>, 然后将之前另存为临时文件的修改依序应用</p><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>从上面可以看到，<code>merge</code>和<code>rebasea</code>都是合并历史记录，但是各自特性不同：</p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>通过<code>merge</code>合并分支会新增一个<code>merge commit</code>，然后将两个分支的历史联系起来</p><p>其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂</p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p><code>rebase </code>会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交</p><p>主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 <code>git merge</code>所需的不必要的合并提交</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/361182707">https://zhuanlan.zhihu.com/p/361182707</a></li><li><a href="https://yuweijun.github.io/git-zh/1-git-branching.html#_rebasing">https://yuweijun.github.io/git-zh/1-git-branching.html#_rebasing</a></li><li><a href="https://backlog.com/git-tutorial/cn/stepup/stepup1_4.html">https://backlog.com/git-tutorial/cn/stepup/stepup1_4.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git_rebase_git_merge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git pull 和 git fetch 的理解？有什么区别？</title>
      <link href="/2017/03/27/git-pull-git-fetch/"/>
      <url>/2017/03/27/git-pull-git-fetch/</url>
      
        <content type="html"><![CDATA[<h1 id="git-pull-和-git-fetch-的理解？有什么区别？"><a href="#git-pull-和-git-fetch-的理解？有什么区别？" class="headerlink" title="git pull 和 git fetch 的理解？有什么区别？"></a>git pull 和 git fetch 的理解？有什么区别？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>先回顾两个命令的定义</p><ul><li>git fetch 命令用于从另一个存储库下载对象和引用</li><li>git pull 命令用于从另一个存储库或本地分支获取并集成(整合)</li></ul><p>再来看一次<code>git</code>的工作流程图，如下所示：</p><p> <img src="https://static.vue-js.com/d523ba60-fac2-11eb-991d-334fd31f0201.png"></p><p>可以看到，<code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中</p><p>而<code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决</p><p>在我们本地的<code>git</code>文件中对应也存储了<code>git</code>本地仓库分支的<code>commit ID </code>和 跟踪的远程分支的<code>commit ID</code>，对应文件如下：</p><ul><li>.git&#x2F;refs&#x2F;head&#x2F;[本地分支]</li><li>.git&#x2F;refs&#x2F;remotes&#x2F;[正在跟踪的分支]</li></ul><p>使用 <code>git fetch</code>更新代码，本地的库中<code>master</code>的<code>commitID</code>不变</p><p>但是与<code>git</code>上面关联的那个<code>orign/master</code>的<code>commit ID</code>发生改变</p><p>这时候我们本地相当于存储了两个代码的版本号，我们还要通过<code>merge</code>去合并这两个不同的代码版本</p><p> <img src="https://static.vue-js.com/fd23ff70-fb12-11eb-bc6f-3f06e1491664.png"></p><p>也就是<code>fetch</code>的时候本地的<code>master</code>没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地<code>merge</code>合并这两个版本号的代码</p><p>相比之下，使用<code>git pull</code>就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：</p><p> <img src="https://static.vue-js.com/091b8140-fb13-11eb-bc6f-3f06e1491664.png"></p><h2 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h2><p>一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到<code>git pull</code>或者<code>git fetch</code>命令</p><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>用法如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>例如从远程的<code>origin</code>仓库的<code>master</code>分支下载代码到本地并新建一个<code>temp</code>分支</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master:temp</span><br></pre></td></tr></table></figure><p>如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来到本地当前分支</p><p>这里<code>git fetch</code>不会进行合并，执行后需要手动执行<code>git merge</code>合并，如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge temp</span><br></pre></td></tr></table></figure><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><p>两者的用法十分相似，<code>pull</code>用法如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>例如将远程主机<code>origin</code>的<code>master</code>分支拉取过来，与本地的<code>branchtest</code>分支合并，命令如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master:branchtest</span><br></pre></td></tr></table></figure><p>同样如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来与本地当前分支合并</p><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>相同点：</p><ul><li>在作用上他们的功能是大致相同的，都是起到了更新代码的作用</li></ul><p>不同点：</p><ul><li>git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull &#x3D; git fetch + git merge</li><li>相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/123370920">https://zhuanlan.zhihu.com/p/123370920</a></li><li><a href="https://segmentfault.com/a/1190000017030384">https://segmentfault.com/a/1190000017030384</a></li><li><a href="https://juejin.cn/post/6844903921794859021">https://juejin.cn/post/6844903921794859021</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git_pull/git_fetch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝浅拷贝的区别？如何实现一个深拷贝？</title>
      <link href="/2017/03/13/js-copy/"/>
      <url>/2017/03/13/js-copy/</url>
      
        <content type="html"><![CDATA[<h1 id="深拷贝浅拷贝的区别？如何实现一个深拷贝？"><a href="#深拷贝浅拷贝的区别？如何实现一个深拷贝？" class="headerlink" title="深拷贝浅拷贝的区别？如何实现一个深拷贝？"></a>深拷贝浅拷贝的区别？如何实现一个深拷贝？</h1><h2 id="一、数据类型存储"><a href="#一、数据类型存储" class="headerlink" title="一、数据类型存储"></a>一、数据类型存储</h2><p>前面文章我们讲到，<code>JavaScript</code>中存在两大数据类型：</p><ul><li>基本类型</li><li>引用类型</li></ul><p>基本类型数据保存在在栈内存中</p><p>引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中</p><h2 id="二、浅拷贝"><a href="#二、浅拷贝" class="headerlink" title="二、浅拷贝"></a>二、浅拷贝</h2><p>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p><p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p><p>即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址</p><p>下面简单实现一个浅拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(prop))&#123;</span><br><span class="line">            newObj[prop] = obj[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>JavaScript</code>中，存在浅拷贝的现象有：</p><ul><li><code>Object.assign</code></li><li><code>Array.prototype.slice()</code>, <code>Array.prototype.concat()</code></li><li>使用拓展运算符实现的复制</li></ul><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">nature</span>: [<span class="string">&#x27;smart&#x27;</span>, <span class="string">&#x27;good&#x27;</span>],</span><br><span class="line">    <span class="attr">names</span>: &#123;</span><br><span class="line">        <span class="attr">name1</span>: <span class="string">&#x27;fx&#x27;</span>,</span><br><span class="line">        <span class="attr">name2</span>: <span class="string">&#x27;xka&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">love</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fx is a great girl&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, fxObj);</span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fxArr = [<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> fxArrs = fxArr.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">fxArrs[<span class="number">1</span>] = <span class="string">&quot;love&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArr) <span class="comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArrs) <span class="comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fxArr = [<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> fxArrs = fxArr.<span class="title function_">concat</span>()</span><br><span class="line">fxArrs[<span class="number">1</span>] = <span class="string">&quot;love&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArr) <span class="comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArrs) <span class="comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fxArr = [<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> fxArrs = [...fxArr]</span><br><span class="line">fxArrs[<span class="number">1</span>] = <span class="string">&quot;love&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArr) <span class="comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArrs) <span class="comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="三、深拷贝"><a href="#三、深拷贝" class="headerlink" title="三、深拷贝"></a>三、深拷贝</h2><p>深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p><p>常见的深拷贝方式有：</p><ul><li><p>_.cloneDeep()</p></li><li><p>jQuery.extend()</p></li><li><p>JSON.stringify()</p></li><li><p>手写循环递归</p></li></ul><h3 id="cloneDeep"><a href="#cloneDeep" class="headerlink" title="_.cloneDeep()"></a>_.cloneDeep()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = _.<span class="title function_">cloneDeep</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">f</span> === obj2.<span class="property">b</span>.<span class="property">f</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="jQuery-extend"><a href="#jQuery-extend" class="headerlink" title="jQuery.extend()"></a>jQuery.extend()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = $.<span class="title function_">extend</span>(<span class="literal">true</span>, &#123;&#125;, obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">f</span> === obj2.<span class="property">b</span>.<span class="property">f</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2=<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1));</span><br></pre></td></tr></table></figure><p>但是这种方式存在弊端，会忽略<code>undefined</code>、<code>symbol</code>和<code>函数</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="attr">name1</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">name3</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="attr">name4</span>:  <span class="title class_">Symbol</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123;name: &quot;A&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="循环递归"><a href="#循环递归" class="headerlink" title="循环递归"></a>循环递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> obj; <span class="comment">// 如果是null或者undefined我就不进行拷贝操作</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line">  <span class="comment">// 可能是对象或者普通的值  如果是函数的话是不需要深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="comment">// 是对象的话就要进行深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">get</span>(obj)) <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line">  <span class="comment">// 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身</span></span><br><span class="line">  hash.<span class="title function_">set</span>(obj, cloneObj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 实现一个递归拷贝</span></span><br><span class="line">      cloneObj[key] = <span class="title function_">deepClone</span>(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、区别"><a href="#四、区别" class="headerlink" title="四、区别"></a>四、区别</h2><p>下面首先借助两张图，可以更加清晰看到浅拷贝与深拷贝的区别</p><p> <img src="https://static.vue-js.com/d9862c00-69b8-11eb-ab90-d9ae814b240d.png"></p><p>从上图发现，浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样</p><p>浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    name : <span class="string">&#x27;init&#x27;</span>,</span><br><span class="line">    arr : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj3=<span class="title function_">shallowClone</span>(obj1) <span class="comment">// 一个浅拷贝方法</span></span><br><span class="line">obj3.<span class="property">name</span> = <span class="string">&quot;update&quot;</span>;</span><br><span class="line">obj3.<span class="property">arr</span>[<span class="number">1</span>] = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ; <span class="comment">// 新旧对象还是共享同一块内存</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1&#x27;</span>,obj1) <span class="comment">// obj1 &#123; name: &#x27;init&#x27;,  arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj3&#x27;</span>,obj3) <span class="comment">// obj3 &#123; name: &#x27;update&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br></pre></td></tr></table></figure><p>但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    name : <span class="string">&#x27;init&#x27;</span>,</span><br><span class="line">    arr : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj4=<span class="title function_">deepClone</span>(obj1) <span class="comment">// 一个深拷贝方法</span></span><br><span class="line">obj4.<span class="property">name</span> = <span class="string">&quot;update&quot;</span>;</span><br><span class="line">obj4.<span class="property">arr</span>[<span class="number">1</span>] = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ; <span class="comment">// 新对象跟原对象不共享内存</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1&#x27;</span>,obj1) <span class="comment">// obj1 &#123; name: &#x27;init&#x27;, arr: [ 1, [ 2, 3 ], 4 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj4&#x27;</span>,obj4) <span class="comment">// obj4 &#123; name: &#x27;update&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>前提为拷贝类型为引用类型的情况下：</p><ul><li><p>浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址</p></li><li><p>深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_copy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 中 HEAD、工作树和索引之间的区别？</title>
      <link href="/2017/03/03/git-HEAD-tree-index/"/>
      <url>/2017/03/03/git-HEAD-tree-index/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-中-HEAD、工作树和索引之间的区别？"><a href="#Git-中-HEAD、工作树和索引之间的区别？" class="headerlink" title="Git 中 HEAD、工作树和索引之间的区别？"></a>Git 中 HEAD、工作树和索引之间的区别？</h1><h2 id="一、HEAD"><a href="#一、HEAD" class="headerlink" title="一、HEAD"></a>一、HEAD</h2><p>在<code>git</code>中，可以存在很多分支，其本质上是一个指向<code>commit</code>对象的可变指针，而<code>Head</code>是一个特别的指针，是一个指向你正在工作中的本地分支的指针</p><p>简单来讲，就是你现在在哪儿，HEAD 就指向哪儿</p><p>例如当前我们处于<code>master</code>分支，所以<code>HEAD</code>这个指针指向了<code>master</code>分支指针</p><p> <img src="https://static.vue-js.com/36cb0da0-fa40-11eb-991d-334fd31f0201.png"></p><p>然后通过调用<code>git checkout test</code>切换到<code>test</code>分支，那么<code>HEAD</code>则指向<code>test</code>分支，如下图：</p><p> <img src="https://static.vue-js.com/3e86ba80-fa40-11eb-991d-334fd31f0201.png"></p><p>但我们在<code>test</code>分支再一次<code>commit</code>信息的时候，<code>HEAD</code>指针仍然指向了<code>test</code>分支指针，而<code>test</code>分支指针已经指向了最新创建的提交，如下图：</p><p> <img src="https://static.vue-js.com/439839b0-fa66-11eb-991d-334fd31f0201.png"></p><p>这个<code>HEAD</code>存储的位置就在<code>.git/HEAD</code>目录中，查看信息可以看到<code>HEAD</code>指向了另一个文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line"><span class="function">ref: <span class="title">refs</span>/<span class="title">heads</span>/<span class="title">master</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">$ <span class="title">cat</span> .<span class="title">git</span>/<span class="title">refs</span>/<span class="title">heads</span>/<span class="title">master</span></span></span><br><span class="line"><span class="function">7406<span class="title">a10efcc169bbab17827aeda189aa20376f7f</span></span></span><br></pre></td></tr></table></figure><p>这个文件的内容是一串哈希码，而这个哈希码正是<code>master</code>分支上最新的提交所对应的哈希码</p><p>所以，当我们切换分支的时候，<code>HEAD</code>指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</p><p>所以，HEAD指针 ——–&gt; 分支指针 ——–&gt; 最新提交</p><h2 id="二、工作树和索引"><a href="#二、工作树和索引" class="headerlink" title="二、工作树和索引"></a>二、工作树和索引</h2><p>在<code>Git</code>管理下，大家实际操作的目录被称为工作树，也就是工作区域</p><p>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域</p><p> <img src="https://static.vue-js.com/46e5ac40-fa40-11eb-bc6f-3f06e1491664.png"></p><p><code>Git</code>在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库</p><p>因此，要提交文件，首先需要把文件加入到索引区域中。</p><p>所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交</p><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>从所在的位置来看：</p><ul><li><p>HEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</p></li><li><p>工作树是查看和编辑的（源）文件的实际内容</p></li><li><p>索引是放置你想要提交给 git仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过git commit 则将索引区域的文件提交到 git 仓库中</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://backlog.com/git-tutorial/cn/intro/intro1_4.html">https://backlog.com/git-tutorial/cn/intro/intro1_4.html</a></li><li><a href="https://juejin.cn/post/6844903598522908686">https://juejin.cn/post/6844903598522908686</a></li><li><a href="https://www.zsythink.net/archives/3412">https://www.zsythink.net/archives/3412</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git_HEAD_tree_index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说你对Git的理解？</title>
      <link href="/2017/02/06/git-Git/"/>
      <url>/2017/02/06/git-Git/</url>
      
        <content type="html"><![CDATA[<h1 id="说说你对Git的理解？"><a href="#说说你对Git的理解？" class="headerlink" title="说说你对Git的理解？"></a>说说你对Git的理解？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>git，是一个分布式版本控制软件，最初目的是为更好地管理<code>Linux</code>内核开发而设计</p><p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复</p><p> <img src="https://static.vue-js.com/29240f40-f79c-11eb-991d-334fd31f0201.png"></p><p>项目开始，只有一个原始版仓库，别的机器可以<code>clone</code>这个原始版本库，那么所有<code>clone</code>的机器，它们的版本库其实都是一样的，并没有主次之分</p><p>所以在实现团队协作的时候，只要有一台电脑充当服务器的角色，其他每个人都从这个“服务器”仓库<code>clone</code>一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交</p><p><code>github</code>实际就可以充当这个服务器角色，其是一个开源协作社区，提供<code>Git</code>仓库托管服务，既可以让别人参与你的开源项目，也可以参与别人的开源项目</p><h2 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h2><p>当我们通过<code>git init</code>创建或者<code>git clone</code>一个项目的时候，项目目录会隐藏一个<code>.git</code>子目录，其作用是用来跟踪管理版本库的</p><p><code>Git</code> 中所有数据在存储前都计算校验和，然后以校验和来引用，所以在我们修改或者删除文件的时候，<code>git</code>能够知道</p><p><code>Git </code>用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）， 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来，如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24b9da6552252987aa493b52f8696cd6d3b00373</span><br></pre></td></tr></table></figure><p>当我们修改文件的时候，<code>git</code>就会修改文件的状态，可以通过<code>git status</code>进行查询，状态情况如下：</p><ul><li>已修改（modified）：表示修改了文件，但还没保存到数据库中。</li><li>已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li><li>已提交（committed）：表示数据已经安全的保存在本地数据库中。</li></ul><p>文件状态对应的，不同状态的文件在<code>Git</code>中处于不同的工作区域，主要分成了四部分：</p><ul><li>工作区：相当于本地写代码的区域，如 git clone 一个项目到本地，相当于本地克隆了远程仓库项目的一个副本</li><li>暂存区：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中</li><li>本地仓库：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库</li><li>远程仓库：远程的仓库，如 github</li></ul><p> <img src="https://static.vue-js.com/3273c9a0-f79c-11eb-bc6f-3f06e1491664.png"></p><h2 id="三、命令"><a href="#三、命令" class="headerlink" title="三、命令"></a>三、命令</h2><p>从上图可以看到，<code>git</code>日常简单的使用就只有上图6个命令：</p><ul><li>add</li><li>commit </li><li>push</li><li>pull</li><li>clone</li><li>checkout</li></ul><p>但实际上还有很多命令，如果想要熟练使用，还有60个多命令，通过这些命令的配合使用，能够提高个人工作效率和团队协助能力</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/Git">https://zh.wikipedia.org/wiki/Git</a></li><li><a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git_Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git中 fork, clone,branch这三个概念，有什么区别?</title>
      <link href="/2017/01/16/git-fork-clone-branch/"/>
      <url>/2017/01/16/git-fork-clone-branch/</url>
      
        <content type="html"><![CDATA[<h1 id="Git中-fork-clone-branch这三个概念，有什么区别"><a href="#Git中-fork-clone-branch这三个概念，有什么区别" class="headerlink" title="Git中 fork, clone,branch这三个概念，有什么区别?"></a>Git中 fork, clone,branch这三个概念，有什么区别?</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p><code>fork</code>，英语翻译过来就是叉子，动词形式则是分叉，如下图，从左到右，一条直线变成多条直线</p><p> <img src="https://static.vue-js.com/ad04ade0-f7ad-11eb-991d-334fd31f0201.png"></p><p>转到<code>git</code>仓库中，<code>fork</code>则可以代表分叉、克隆 出一个（仓库的）新拷贝</p><p> <img src="https://static.vue-js.com/b4b31450-f7ad-11eb-991d-334fd31f0201.png"></p><p>包含了原来的仓库（即upstream repository，上游仓库）所有内容，如分支、Tag、提交</p><p>如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p><code>clone</code>，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</p><p>执行<code>clone</code>命令后，会在当前目录下创建一个名为<code>xxx</code>的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝</p><p>默认配置下远程 <code>Git</code> 仓库中的每一个文件的每一个版本都将被拉取下来</p><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><p><code>branch</code>，译为分支，其作用简单而言就是开启另一个分支， 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线</p><p><code> Git</code> 处理分支的方式十分轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷</p><p>在我们开发中，默认只有一条<code>master</code>分支，如下图所示：</p><p> <img src="https://static.vue-js.com/7fa8e9c0-f923-11eb-991d-334fd31f0201.png"></p><p>通过<code>git branch </code>可以创建一个分支，但并不会自动切换到新分支中去</p><p> <img src="https://static.vue-js.com/89efd560-f923-11eb-bc6f-3f06e1491664.png"></p><p>通过<code>git checkout</code>可以切换到另一个<code>testing</code>分支</p><p> <img src="https://static.vue-js.com/91d1cef0-f923-11eb-bc6f-3f06e1491664.png"></p><h2 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h2><h3 id="fork-1"><a href="#fork-1" class="headerlink" title="fork"></a>fork</h3><p>当你在<code>github</code>发现感兴趣开源项目的时候，可以通过点击<code>github</code>仓库中右上角<code>fork</code>标识的按钮，如下图：</p><p> <img src="https://static.vue-js.com/bc4c4510-f7ad-11eb-991d-334fd31f0201.png"></p><p>点击这个操作后会将这个仓库的文件、提交历史、issues和其余东西的仓库复制到自己的<code>github</code>仓库中，而你本地仓库是不会存在任何更改</p><p>然后你就可以通过<code>git clone</code>对你这个复制的远程仓库进行克隆</p><p>后续更改任何东西都可以在本地完成，如<code>git add</code>、<code>git commit</code>一系列的操作，然后通过<code>push</code>命令推到自己的远程仓库</p><p>如果希望对方接受你的修改，可以通过发送<code>pull requests</code>给对方，如果对方接受。则会将你的修改内容更新到仓库中</p><p> <img src="https://static.vue-js.com/c5265a40-f7ad-11eb-991d-334fd31f0201.png"></p><p>整体流程如下图：</p><p> <img src="https://static.vue-js.com/ced8ce10-f7ad-11eb-bc6f-3f06e1491664.png"></p><h3 id="clone-1"><a href="#clone-1" class="headerlink" title="clone"></a>clone</h3><p>在<code>github</code>中，开源项目右侧存在<code>code</code>按钮，点击后则会显示开源项目<code>url</code>信息，如下图所示：</p><p> <img src="https://static.vue-js.com/d8685090-f7ad-11eb-bc6f-3f06e1491664.png"></p><p>通过<code>git clone xxx</code>则能完成远程项目的下载</p><h3 id="branch-1"><a href="#branch-1" class="headerlink" title="branch"></a>branch</h3><p>可通过<code>git branch</code>进行查看当前的分支状态，</p><p>如果给了<code>--list</code>，或者没有非选项参数，现有的分支将被列出；当前的分支将以绿色突出显示，并标有星号</p><p>以及通过<code>git branch</code>创建一个新的分支出来</p><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>其三者区别如下：</p><ul><li>fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”</li><li>clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</li><li>branch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93">https://git-scm.com/book/zh/v2/Git-基础-获取-Git-仓库</a></li><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B">https://git-scm.com/book/zh/v2/Git-分支-分支简介</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git_fork_clone_branch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用的命令有哪些？</title>
      <link href="/2017/01/06/git-command/"/>
      <url>/2017/01/06/git-command/</url>
      
        <content type="html"><![CDATA[<h1 id="Git常用的命令有哪些？"><a href="#Git常用的命令有哪些？" class="headerlink" title="Git常用的命令有哪些？"></a>Git常用的命令有哪些？</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><code>git </code>的操作可以通过命令的形式如执行，日常使用就如下图6个命令即可</p><p> <img src="https://static.vue-js.com/fe150520-f7af-11eb-991d-334fd31f0201.png"></p><p>实际上，如果想要熟练使用，超过60多个命令需要了解，下面则介绍下常见的的<code>git </code>命令</p><h2 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>Git </code>自带一个 <code>git config</code> 的工具来帮助设置控制 <code>Git </code>外观和行为的配置变量，在我们安装完<code>git</code>之后，第一件事就是设置你的用户名和邮件地址</p><p>后续每一个提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改</p><p>设置提交代码时的用户信息命令如下：</p><ul><li>git config [–global] user.name “[name]” </li><li>git config [–global] user.email “[email address]”</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>一个<code>git</code>项目的初始有两个途径，分别是：</p><ul><li>git init [project-name]：创建或在当前目录初始化一个git代码库</li><li>git clone url：下载一个项目和它的整个代码历史</li></ul><h3 id="日常基本操作"><a href="#日常基本操作" class="headerlink" title="日常基本操作"></a>日常基本操作</h3><p>在日常工作中，代码常用的基本操作如下：</p><ul><li>git init 初始化仓库，默认为 master 分支</li><li>git add . 提交全部文件修改到缓存区</li><li>git add &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区</li><li>git diff  查看当前代码 add后，会 add 哪些内容</li><li>git diff –staged查看现在 commit 提交后，会提交哪些内容</li><li>git status 查看当前分支状态</li><li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</li><li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</li><li>git commit -m “&lt;注释&gt;” 提交代码到本地仓库，并写提交注释</li><li>git commit -v 提交时显示所有diff信息</li><li>git commit –amend [file1] [file2] 重做上一次commit，并包括指定文件的新变化</li></ul><p>关于提交信息的格式，可以遵循以下的规则：</p><ul><li>feat: 新特性，添加功能</li><li>fix: 修改 bug</li><li>refactor: 代码重构</li><li>docs: 文档修改</li><li>style: 代码格式修改, 注意不是 css 修改</li><li>test: 测试用例修改</li><li>chore: 其他修改, 比如构建流程, 依赖管理</li></ul><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul><li>git branch 查看本地所有分支</li><li>git branch -r 查看远程所有分支</li><li>git branch -a 查看本地和远程所有分支</li><li>git merge &lt;分支名&gt; 合并分支</li><li>git merge –abort 合并分支出现冲突时，取消合并，一切回到合并前的状态</li><li>git branch &lt;新分支名&gt; 基于当前分支，新建一个分支</li><li>git checkout –orphan &lt;新分支名&gt; 新建一个空分支（会保留之前分支的所有文件）</li><li>git branch -D &lt;分支名&gt; 删除本地某个分支</li><li>git push &lt;远程库名&gt; :&lt;分支名&gt; 删除远程某个分支</li><li>git branch &lt;新分支名称&gt; &lt;提交ID&gt; 从提交历史恢复某个删掉的某个分支</li><li>git branch -m &lt;原分支名&gt; &lt;新分支名&gt; 分支更名</li><li>git checkout &lt;分支名&gt; 切换到本地某个分支</li><li>git checkout &lt;远程库名&gt;&#x2F;&lt;分支名&gt; 切换到线上某个分支</li><li>git checkout -b &lt;新分支名&gt; 把基于当前分支新建分支，并切换为这个分支</li></ul><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><p>远程操作常见的命令：</p><ul><li>git fetch [remote] 下载远程仓库的所有变动</li><li>git remote -v 显示所有远程仓库</li><li>git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并</li><li>git fetch 获取线上最新版信息记录，不合并</li><li>git push [remote] [branch] 上传本地指定分支到远程仓库</li><li>git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突</li><li>git push [remote] –all 推送所有分支到远程仓库</li></ul><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><ul><li><p>git checkout [file] 恢复暂存区的指定文件到工作区</p></li><li><p>git checkout [commit] [file]  恢复某个commit的指定文件到暂存区和工作区</p></li><li><p>git checkout . 恢复暂存区的所有文件到工作区</p></li><li><p>git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p></li><li><p>git reset –hard 重置暂存区与工作区，与上一次commit保持一致</p></li><li><p>git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p></li><li><p>git revert [commit]  后者的所有变化都将被前者抵消，并且应用到当前分支</p></li></ul><blockquote><p><code>reset</code>：真实硬性回滚，目标版本后面的提交记录全部丢失了</p><p><code>revert</code>：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有</p></blockquote><h3 id="存储操作"><a href="#存储操作" class="headerlink" title="存储操作"></a>存储操作</h3><p>你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作，但又不想提交这些杂乱的代码，这时候可以将代码进行存储</p><ul><li><p>git stash 暂时将未提交的变化移除</p></li><li><p>git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏</p></li><li><p>git stash list 查看所有储藏中的工作</p></li><li><p>git stash apply &lt;储藏的名称&gt;  取出储藏中对应的工作状态进行恢复，不会删除储藏</p></li><li><p>git stash clear 清空所有储藏中的工作</p></li><li><p>git stash drop &lt;储藏的名称&gt;  删除对应的某个储藏</p></li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><code>git</code>常用命令速查表如下所示：</p><p> <img src="https://static.vue-js.com/0a10f3c0-f7b0-11eb-991d-334fd31f0201.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p></li><li><p><a href="https://segmentfault.com/a/1190000017875714">https://segmentfault.com/a/1190000017875714</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git_command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 发生冲突的场景？如何解决？</title>
      <link href="/2017/01/02/git-conflict/"/>
      <url>/2017/01/02/git-conflict/</url>
      
        <content type="html"><![CDATA[<h1 id="git-发生冲突的场景？如何解决？"><a href="#git-发生冲突的场景？如何解决？" class="headerlink" title="git 发生冲突的场景？如何解决？"></a>git 发生冲突的场景？如何解决？</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>一般情况下，出现分支的场景有如下：</p><ul><li>多个分支代码合并到一个分支时</li><li>多个分支向同一个远端分支推送</li></ul><p>具体情况就是，多个分支修改了同一个文件（任何地方）或者多个分支修改了同一个文件的名称</p><p>如果两个分支中分别修改了不同文件中的部分，是不会产生冲突，直接合并即可</p><p>应用在命令中，就是<code>push</code>、<code>pull</code>、<code>stash</code>、<code>rebase</code>等命令下都有可能产生冲突情况，从本质上来讲，都是<code>merge</code>和<code>patch</code>（应用补丁）时产生冲突</p><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>在本地主分值<code>master</code>创建一个<code>a.txt</code>文件，文件起始位置写上<code>master commit</code>，如下：</p><p> <img src="https://static.vue-js.com/959ade20-fdb3-11eb-991d-334fd31f0201.png"></p><p>然后提交到仓库：</p><ul><li>git add a.txt</li><li>git commit -m ‘master first commit’</li></ul><p>创建一个新的分支<code>featurel1</code>分支，并进行切换，如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b featurel1</span><br></pre></td></tr></table></figure><p>然后修改<code>a.txt</code>文件首行文字为 <code>featurel commit</code>，然后添加到暂存区，并开始进行提交到仓库：</p><ul><li>git add a.txt</li><li>git commit -m ‘featurel  first change’</li></ul><p>然后通过<code>git checkout master</code>切换到主分支，通过<code>git merge</code>进行合并，发现不会冲突</p><p>此时<code>a.txt</code>文件的内容变成<code>featurel commit</code>，没有出现冲突情况，这是因为<code>git</code>在内部发生了快速合并</p><blockquote><p>如果当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作</p><p>git 不创建任何新的提交(commit)，只是将当前分支指向合并进来的分支</p></blockquote><p>如果此时切换到<code>featurel</code>分支，将文件的内容修改成<code>featrue second commit</code>，然后提交到本地仓库</p><p>然后切换到主分支，如果此时在<code>a.txt</code>文件再次修改，修改成<code>mastet second commit</code>，然后再次提交到本地仓库</p><p>此时，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了下图所示：</p><p> <img src="https://static.vue-js.com/a05488c0-fdb3-11eb-991d-334fd31f0201.png"></p><p>这种情况下，无法执行快速合并，只能试图把各自的修改合并起来，但这种合并就可能会有冲突</p><p>现在通过<code>git merge featurel</code>进行分支合并，如下所示：</p><p> <img src="https://static.vue-js.com/b0991d90-fdb3-11eb-bc6f-3f06e1491664.png"></p><p>从冲突信息可以看到，<code>a.txt</code>发生冲突，必须手动解决冲突之后再提交</p><p>而<code>git status</code>同样可以告知我们冲突的文件：</p><p> <img src="https://static.vue-js.com/c5823430-fdb3-11eb-991d-334fd31f0201.png"></p><p>打开<code>a.txt</code>文件，可以看到如下内容：</p><p> <img src="https://static.vue-js.com/ce7a0a90-fdb3-11eb-bc6f-3f06e1491664.png"></p><p><code>git</code>用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容：</p><ul><li>&lt;&lt;&lt;&lt;&lt;&lt;&lt; 和 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 之间的区域就是当前更改的内容</li><li>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 之间的区域就是传入进来更改的内容</li></ul><p>现在要做的事情就是将冲突的内容进行更改，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，<code>Git </code>就会将它们标记为冲突已解决然后再提交：</p><ul><li>git add a.txt</li><li>git commit -m “conflict fixed”</li></ul><p>此时<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><p> <img src="https://static.vue-js.com/d7421e60-fdb3-11eb-bc6f-3f06e1491664.png"></p><p>使用<code>git log</code>命令可以看到合并的信息：</p><p> <img src="https://static.vue-js.com/e0dfd1b0-fdb3-11eb-991d-334fd31f0201.png"></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>当<code>Git</code>无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成</p><p>解决冲突就是把<code>Git</code>合并失败的文件手动编辑为我们希望的内容，再提交</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900004111093344">https://www.liaoxuefeng.com/wiki/896043488029600/900004111093344</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git_conflict </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
